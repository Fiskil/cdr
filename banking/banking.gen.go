// Package banking provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package banking

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// Defines values for BankingAccountOpenStatus.
const (
	BankingAccountOpenStatusCLOSED BankingAccountOpenStatus = "CLOSED"
	BankingAccountOpenStatusOPEN   BankingAccountOpenStatus = "OPEN"
)

// Defines values for BankingAccountDetailV2FeaturesFeatureType.
const (
	BankingAccountDetailV2FeaturesFeatureTypeADDITIONALCARDS               BankingAccountDetailV2FeaturesFeatureType = "ADDITIONAL_CARDS"
	BankingAccountDetailV2FeaturesFeatureTypeBALANCETRANSFERS              BankingAccountDetailV2FeaturesFeatureType = "BALANCE_TRANSFERS"
	BankingAccountDetailV2FeaturesFeatureTypeBILLPAYMENT                   BankingAccountDetailV2FeaturesFeatureType = "BILL_PAYMENT"
	BankingAccountDetailV2FeaturesFeatureTypeBONUSREWARDS                  BankingAccountDetailV2FeaturesFeatureType = "BONUS_REWARDS"
	BankingAccountDetailV2FeaturesFeatureTypeCARDACCESS                    BankingAccountDetailV2FeaturesFeatureType = "CARD_ACCESS"
	BankingAccountDetailV2FeaturesFeatureTypeCASHBACKOFFER                 BankingAccountDetailV2FeaturesFeatureType = "CASHBACK_OFFER"
	BankingAccountDetailV2FeaturesFeatureTypeCOMPLEMENTARYPRODUCTDISCOUNTS BankingAccountDetailV2FeaturesFeatureType = "COMPLEMENTARY_PRODUCT_DISCOUNTS"
	BankingAccountDetailV2FeaturesFeatureTypeDIGITALBANKING                BankingAccountDetailV2FeaturesFeatureType = "DIGITAL_BANKING"
	BankingAccountDetailV2FeaturesFeatureTypeDIGITALWALLET                 BankingAccountDetailV2FeaturesFeatureType = "DIGITAL_WALLET"
	BankingAccountDetailV2FeaturesFeatureTypeDONATEINTEREST                BankingAccountDetailV2FeaturesFeatureType = "DONATE_INTEREST"
	BankingAccountDetailV2FeaturesFeatureTypeEXTRAREPAYMENTS               BankingAccountDetailV2FeaturesFeatureType = "EXTRA_REPAYMENTS"
	BankingAccountDetailV2FeaturesFeatureTypeFRAUDPROTECTION               BankingAccountDetailV2FeaturesFeatureType = "FRAUD_PROTECTION"
	BankingAccountDetailV2FeaturesFeatureTypeFREETXNS                      BankingAccountDetailV2FeaturesFeatureType = "FREE_TXNS"
	BankingAccountDetailV2FeaturesFeatureTypeFREETXNSALLOWANCE             BankingAccountDetailV2FeaturesFeatureType = "FREE_TXNS_ALLOWANCE"
	BankingAccountDetailV2FeaturesFeatureTypeGUARANTOR                     BankingAccountDetailV2FeaturesFeatureType = "GUARANTOR"
	BankingAccountDetailV2FeaturesFeatureTypeINSTALMENTPLAN                BankingAccountDetailV2FeaturesFeatureType = "INSTALMENT_PLAN"
	BankingAccountDetailV2FeaturesFeatureTypeINSURANCE                     BankingAccountDetailV2FeaturesFeatureType = "INSURANCE"
	BankingAccountDetailV2FeaturesFeatureTypeINTERESTFREE                  BankingAccountDetailV2FeaturesFeatureType = "INTEREST_FREE"
	BankingAccountDetailV2FeaturesFeatureTypeINTERESTFREETRANSFERS         BankingAccountDetailV2FeaturesFeatureType = "INTEREST_FREE_TRANSFERS"
	BankingAccountDetailV2FeaturesFeatureTypeLOYALTYPROGRAM                BankingAccountDetailV2FeaturesFeatureType = "LOYALTY_PROGRAM"
	BankingAccountDetailV2FeaturesFeatureTypeNOTIFICATIONS                 BankingAccountDetailV2FeaturesFeatureType = "NOTIFICATIONS"
	BankingAccountDetailV2FeaturesFeatureTypeNPPENABLED                    BankingAccountDetailV2FeaturesFeatureType = "NPP_ENABLED"
	BankingAccountDetailV2FeaturesFeatureTypeNPPPAYID                      BankingAccountDetailV2FeaturesFeatureType = "NPP_PAYID"
	BankingAccountDetailV2FeaturesFeatureTypeOFFSET                        BankingAccountDetailV2FeaturesFeatureType = "OFFSET"
	BankingAccountDetailV2FeaturesFeatureTypeOTHER                         BankingAccountDetailV2FeaturesFeatureType = "OTHER"
	BankingAccountDetailV2FeaturesFeatureTypeOVERDRAFT                     BankingAccountDetailV2FeaturesFeatureType = "OVERDRAFT"
	BankingAccountDetailV2FeaturesFeatureTypeREDRAW                        BankingAccountDetailV2FeaturesFeatureType = "REDRAW"
	BankingAccountDetailV2FeaturesFeatureTypeRELATIONSHIPMANAGEMENT        BankingAccountDetailV2FeaturesFeatureType = "RELATIONSHIP_MANAGEMENT"
	BankingAccountDetailV2FeaturesFeatureTypeUNLIMITEDTXNS                 BankingAccountDetailV2FeaturesFeatureType = "UNLIMITED_TXNS"
)

// Defines values for BankingAccountDetailV2OpenStatus.
const (
	BankingAccountDetailV2OpenStatusCLOSED BankingAccountDetailV2OpenStatus = "CLOSED"
	BankingAccountDetailV2OpenStatusOPEN   BankingAccountDetailV2OpenStatus = "OPEN"
)

// Defines values for BankingAccountDetailV2SpecificAccountUType.
const (
	CreditCard  BankingAccountDetailV2SpecificAccountUType = "creditCard"
	Loan        BankingAccountDetailV2SpecificAccountUType = "loan"
	TermDeposit BankingAccountDetailV2SpecificAccountUType = "termDeposit"
)

// Defines values for BankingDigitalWalletPayeeProvider.
const (
	BankingDigitalWalletPayeeProviderOTHER    BankingDigitalWalletPayeeProvider = "OTHER"
	BankingDigitalWalletPayeeProviderPAYPALAU BankingDigitalWalletPayeeProvider = "PAYPAL_AU"
)

// Defines values for BankingDigitalWalletPayeeType.
const (
	BankingDigitalWalletPayeeTypeCONTACTNAME BankingDigitalWalletPayeeType = "CONTACT_NAME"
	BankingDigitalWalletPayeeTypeEMAIL       BankingDigitalWalletPayeeType = "EMAIL"
	BankingDigitalWalletPayeeTypeTELEPHONE   BankingDigitalWalletPayeeType = "TELEPHONE"
)

// Defines values for BankingDomesticPayeePayeeAccountUType.
const (
	Account BankingDomesticPayeePayeeAccountUType = "account"
	Card    BankingDomesticPayeePayeeAccountUType = "card"
	PayId   BankingDomesticPayeePayeeAccountUType = "payId"
)

// Defines values for BankingDomesticPayeePayIdType.
const (
	BankingDomesticPayeePayIdTypeABN           BankingDomesticPayeePayIdType = "ABN"
	BankingDomesticPayeePayIdTypeEMAIL         BankingDomesticPayeePayIdType = "EMAIL"
	BankingDomesticPayeePayIdTypeORGIDENTIFIER BankingDomesticPayeePayIdType = "ORG_IDENTIFIER"
	BankingDomesticPayeePayIdTypeTELEPHONE     BankingDomesticPayeePayIdType = "TELEPHONE"
)

// Defines values for BankingLoanAccountV2RepaymentType.
const (
	BankingLoanAccountV2RepaymentTypeINTERESTONLY         BankingLoanAccountV2RepaymentType = "INTEREST_ONLY"
	BankingLoanAccountV2RepaymentTypePRINCIPALANDINTEREST BankingLoanAccountV2RepaymentType = "PRINCIPAL_AND_INTEREST"
)

// Defines values for BankingPayeeDetailV2PayeeUType.
const (
	BankingPayeeDetailV2PayeeUTypeBiller        BankingPayeeDetailV2PayeeUType = "biller"
	BankingPayeeDetailV2PayeeUTypeDigitalWallet BankingPayeeDetailV2PayeeUType = "digitalWallet"
	BankingPayeeDetailV2PayeeUTypeDomestic      BankingPayeeDetailV2PayeeUType = "domestic"
	BankingPayeeDetailV2PayeeUTypeInternational BankingPayeeDetailV2PayeeUType = "international"
)

// Defines values for BankingPayeeDetailV2Type.
const (
	BankingPayeeDetailV2TypeBILLER        BankingPayeeDetailV2Type = "BILLER"
	BankingPayeeDetailV2TypeDIGITALWALLET BankingPayeeDetailV2Type = "DIGITAL_WALLET"
	BankingPayeeDetailV2TypeDOMESTIC      BankingPayeeDetailV2Type = "DOMESTIC"
	BankingPayeeDetailV2TypeINTERNATIONAL BankingPayeeDetailV2Type = "INTERNATIONAL"
)

// Defines values for BankingPayeeV2Type.
const (
	BankingPayeeV2TypeBILLER        BankingPayeeV2Type = "BILLER"
	BankingPayeeV2TypeDIGITALWALLET BankingPayeeV2Type = "DIGITAL_WALLET"
	BankingPayeeV2TypeDOMESTIC      BankingPayeeV2Type = "DOMESTIC"
	BankingPayeeV2TypeINTERNATIONAL BankingPayeeV2Type = "INTERNATIONAL"
)

// Defines values for BankingProductCategory.
const (
	BankingProductCategoryBUSINESSLOANS           BankingProductCategory = "BUSINESS_LOANS"
	BankingProductCategoryCREDANDCHRGCARDS        BankingProductCategory = "CRED_AND_CHRG_CARDS"
	BankingProductCategoryLEASES                  BankingProductCategory = "LEASES"
	BankingProductCategoryMARGINLOANS             BankingProductCategory = "MARGIN_LOANS"
	BankingProductCategoryOVERDRAFTS              BankingProductCategory = "OVERDRAFTS"
	BankingProductCategoryPERSLOANS               BankingProductCategory = "PERS_LOANS"
	BankingProductCategoryREGULATEDTRUSTACCOUNTS  BankingProductCategory = "REGULATED_TRUST_ACCOUNTS"
	BankingProductCategoryRESIDENTIALMORTGAGES    BankingProductCategory = "RESIDENTIAL_MORTGAGES"
	BankingProductCategoryTERMDEPOSITS            BankingProductCategory = "TERM_DEPOSITS"
	BankingProductCategoryTRADEFINANCE            BankingProductCategory = "TRADE_FINANCE"
	BankingProductCategoryTRANSANDSAVINGSACCOUNTS BankingProductCategory = "TRANS_AND_SAVINGS_ACCOUNTS"
	BankingProductCategoryTRAVELCARDS             BankingProductCategory = "TRAVEL_CARDS"
)

// Defines values for BankingProductConstraintConstraintType.
const (
	MAXBALANCE     BankingProductConstraintConstraintType = "MAX_BALANCE"
	MAXLIMIT       BankingProductConstraintConstraintType = "MAX_LIMIT"
	MINBALANCE     BankingProductConstraintConstraintType = "MIN_BALANCE"
	MINLIMIT       BankingProductConstraintConstraintType = "MIN_LIMIT"
	OPENINGBALANCE BankingProductConstraintConstraintType = "OPENING_BALANCE"
)

// Defines values for BankingProductDepositRateDepositRateType.
const (
	BankingProductDepositRateDepositRateTypeBONUS        BankingProductDepositRateDepositRateType = "BONUS"
	BankingProductDepositRateDepositRateTypeBUNDLEBONUS  BankingProductDepositRateDepositRateType = "BUNDLE_BONUS"
	BankingProductDepositRateDepositRateTypeFIXED        BankingProductDepositRateDepositRateType = "FIXED"
	BankingProductDepositRateDepositRateTypeFLOATING     BankingProductDepositRateDepositRateType = "FLOATING"
	BankingProductDepositRateDepositRateTypeINTRODUCTORY BankingProductDepositRateDepositRateType = "INTRODUCTORY"
	BankingProductDepositRateDepositRateTypeMARKETLINKED BankingProductDepositRateDepositRateType = "MARKET_LINKED"
	BankingProductDepositRateDepositRateTypeVARIABLE     BankingProductDepositRateDepositRateType = "VARIABLE"
)

// Defines values for BankingProductDiscountDiscountType.
const (
	BALANCE         BankingProductDiscountDiscountType = "BALANCE"
	DEPOSITS        BankingProductDiscountDiscountType = "DEPOSITS"
	ELIGIBILITYONLY BankingProductDiscountDiscountType = "ELIGIBILITY_ONLY"
	FEECAP          BankingProductDiscountDiscountType = "FEE_CAP"
	PAYMENTS        BankingProductDiscountDiscountType = "PAYMENTS"
)

// Defines values for BankingProductDiscountEligibilityDiscountEligibilityType.
const (
	BankingProductDiscountEligibilityDiscountEligibilityTypeBUSINESS         BankingProductDiscountEligibilityDiscountEligibilityType = "BUSINESS"
	BankingProductDiscountEligibilityDiscountEligibilityTypeEMPLOYMENTSTATUS BankingProductDiscountEligibilityDiscountEligibilityType = "EMPLOYMENT_STATUS"
	BankingProductDiscountEligibilityDiscountEligibilityTypeINTRODUCTORY     BankingProductDiscountEligibilityDiscountEligibilityType = "INTRODUCTORY"
	BankingProductDiscountEligibilityDiscountEligibilityTypeMAXAGE           BankingProductDiscountEligibilityDiscountEligibilityType = "MAX_AGE"
	BankingProductDiscountEligibilityDiscountEligibilityTypeMINAGE           BankingProductDiscountEligibilityDiscountEligibilityType = "MIN_AGE"
	BankingProductDiscountEligibilityDiscountEligibilityTypeMININCOME        BankingProductDiscountEligibilityDiscountEligibilityType = "MIN_INCOME"
	BankingProductDiscountEligibilityDiscountEligibilityTypeMINTURNOVER      BankingProductDiscountEligibilityDiscountEligibilityType = "MIN_TURNOVER"
	BankingProductDiscountEligibilityDiscountEligibilityTypeNATURALPERSON    BankingProductDiscountEligibilityDiscountEligibilityType = "NATURAL_PERSON"
	BankingProductDiscountEligibilityDiscountEligibilityTypeOTHER            BankingProductDiscountEligibilityDiscountEligibilityType = "OTHER"
	BankingProductDiscountEligibilityDiscountEligibilityTypePENSIONRECIPIENT BankingProductDiscountEligibilityDiscountEligibilityType = "PENSION_RECIPIENT"
	BankingProductDiscountEligibilityDiscountEligibilityTypeRESIDENCYSTATUS  BankingProductDiscountEligibilityDiscountEligibilityType = "RESIDENCY_STATUS"
	BankingProductDiscountEligibilityDiscountEligibilityTypeSTAFF            BankingProductDiscountEligibilityDiscountEligibilityType = "STAFF"
	BankingProductDiscountEligibilityDiscountEligibilityTypeSTUDENT          BankingProductDiscountEligibilityDiscountEligibilityType = "STUDENT"
)

// Defines values for BankingProductEligibilityEligibilityType.
const (
	BankingProductEligibilityEligibilityTypeBUSINESS         BankingProductEligibilityEligibilityType = "BUSINESS"
	BankingProductEligibilityEligibilityTypeEMPLOYMENTSTATUS BankingProductEligibilityEligibilityType = "EMPLOYMENT_STATUS"
	BankingProductEligibilityEligibilityTypeMAXAGE           BankingProductEligibilityEligibilityType = "MAX_AGE"
	BankingProductEligibilityEligibilityTypeMINAGE           BankingProductEligibilityEligibilityType = "MIN_AGE"
	BankingProductEligibilityEligibilityTypeMININCOME        BankingProductEligibilityEligibilityType = "MIN_INCOME"
	BankingProductEligibilityEligibilityTypeMINTURNOVER      BankingProductEligibilityEligibilityType = "MIN_TURNOVER"
	BankingProductEligibilityEligibilityTypeNATURALPERSON    BankingProductEligibilityEligibilityType = "NATURAL_PERSON"
	BankingProductEligibilityEligibilityTypeOTHER            BankingProductEligibilityEligibilityType = "OTHER"
	BankingProductEligibilityEligibilityTypePENSIONRECIPIENT BankingProductEligibilityEligibilityType = "PENSION_RECIPIENT"
	BankingProductEligibilityEligibilityTypeRESIDENCYSTATUS  BankingProductEligibilityEligibilityType = "RESIDENCY_STATUS"
	BankingProductEligibilityEligibilityTypeSTAFF            BankingProductEligibilityEligibilityType = "STAFF"
	BankingProductEligibilityEligibilityTypeSTUDENT          BankingProductEligibilityEligibilityType = "STUDENT"
)

// Defines values for BankingProductFeatureV2FeatureType.
const (
	BankingProductFeatureV2FeatureTypeADDITIONALCARDS               BankingProductFeatureV2FeatureType = "ADDITIONAL_CARDS"
	BankingProductFeatureV2FeatureTypeBALANCETRANSFERS              BankingProductFeatureV2FeatureType = "BALANCE_TRANSFERS"
	BankingProductFeatureV2FeatureTypeBILLPAYMENT                   BankingProductFeatureV2FeatureType = "BILL_PAYMENT"
	BankingProductFeatureV2FeatureTypeBONUSREWARDS                  BankingProductFeatureV2FeatureType = "BONUS_REWARDS"
	BankingProductFeatureV2FeatureTypeCARDACCESS                    BankingProductFeatureV2FeatureType = "CARD_ACCESS"
	BankingProductFeatureV2FeatureTypeCASHBACKOFFER                 BankingProductFeatureV2FeatureType = "CASHBACK_OFFER"
	BankingProductFeatureV2FeatureTypeCOMPLEMENTARYPRODUCTDISCOUNTS BankingProductFeatureV2FeatureType = "COMPLEMENTARY_PRODUCT_DISCOUNTS"
	BankingProductFeatureV2FeatureTypeDIGITALBANKING                BankingProductFeatureV2FeatureType = "DIGITAL_BANKING"
	BankingProductFeatureV2FeatureTypeDIGITALWALLET                 BankingProductFeatureV2FeatureType = "DIGITAL_WALLET"
	BankingProductFeatureV2FeatureTypeDONATEINTEREST                BankingProductFeatureV2FeatureType = "DONATE_INTEREST"
	BankingProductFeatureV2FeatureTypeEXTRAREPAYMENTS               BankingProductFeatureV2FeatureType = "EXTRA_REPAYMENTS"
	BankingProductFeatureV2FeatureTypeFRAUDPROTECTION               BankingProductFeatureV2FeatureType = "FRAUD_PROTECTION"
	BankingProductFeatureV2FeatureTypeFREETXNS                      BankingProductFeatureV2FeatureType = "FREE_TXNS"
	BankingProductFeatureV2FeatureTypeFREETXNSALLOWANCE             BankingProductFeatureV2FeatureType = "FREE_TXNS_ALLOWANCE"
	BankingProductFeatureV2FeatureTypeGUARANTOR                     BankingProductFeatureV2FeatureType = "GUARANTOR"
	BankingProductFeatureV2FeatureTypeINSTALMENTPLAN                BankingProductFeatureV2FeatureType = "INSTALMENT_PLAN"
	BankingProductFeatureV2FeatureTypeINSURANCE                     BankingProductFeatureV2FeatureType = "INSURANCE"
	BankingProductFeatureV2FeatureTypeINTERESTFREE                  BankingProductFeatureV2FeatureType = "INTEREST_FREE"
	BankingProductFeatureV2FeatureTypeINTERESTFREETRANSFERS         BankingProductFeatureV2FeatureType = "INTEREST_FREE_TRANSFERS"
	BankingProductFeatureV2FeatureTypeLOYALTYPROGRAM                BankingProductFeatureV2FeatureType = "LOYALTY_PROGRAM"
	BankingProductFeatureV2FeatureTypeNOTIFICATIONS                 BankingProductFeatureV2FeatureType = "NOTIFICATIONS"
	BankingProductFeatureV2FeatureTypeNPPENABLED                    BankingProductFeatureV2FeatureType = "NPP_ENABLED"
	BankingProductFeatureV2FeatureTypeNPPPAYID                      BankingProductFeatureV2FeatureType = "NPP_PAYID"
	BankingProductFeatureV2FeatureTypeOFFSET                        BankingProductFeatureV2FeatureType = "OFFSET"
	BankingProductFeatureV2FeatureTypeOTHER                         BankingProductFeatureV2FeatureType = "OTHER"
	BankingProductFeatureV2FeatureTypeOVERDRAFT                     BankingProductFeatureV2FeatureType = "OVERDRAFT"
	BankingProductFeatureV2FeatureTypeREDRAW                        BankingProductFeatureV2FeatureType = "REDRAW"
	BankingProductFeatureV2FeatureTypeRELATIONSHIPMANAGEMENT        BankingProductFeatureV2FeatureType = "RELATIONSHIP_MANAGEMENT"
	BankingProductFeatureV2FeatureTypeUNLIMITEDTXNS                 BankingProductFeatureV2FeatureType = "UNLIMITED_TXNS"
)

// Defines values for BankingProductFeeFeeType.
const (
	BankingProductFeeFeeTypeDEPOSIT     BankingProductFeeFeeType = "DEPOSIT"
	BankingProductFeeFeeTypeEVENT       BankingProductFeeFeeType = "EVENT"
	BankingProductFeeFeeTypeEXIT        BankingProductFeeFeeType = "EXIT"
	BankingProductFeeFeeTypePAYMENT     BankingProductFeeFeeType = "PAYMENT"
	BankingProductFeeFeeTypePERIODIC    BankingProductFeeFeeType = "PERIODIC"
	BankingProductFeeFeeTypePURCHASE    BankingProductFeeFeeType = "PURCHASE"
	BankingProductFeeFeeTypeTRANSACTION BankingProductFeeFeeType = "TRANSACTION"
	BankingProductFeeFeeTypeUPFRONT     BankingProductFeeFeeType = "UPFRONT"
	BankingProductFeeFeeTypeVARIABLE    BankingProductFeeFeeType = "VARIABLE"
	BankingProductFeeFeeTypeWITHDRAWAL  BankingProductFeeFeeType = "WITHDRAWAL"
)

// Defines values for BankingProductLendingRateV2InterestPaymentDue.
const (
	INADVANCE BankingProductLendingRateV2InterestPaymentDue = "IN_ADVANCE"
	INARREARS BankingProductLendingRateV2InterestPaymentDue = "IN_ARREARS"
)

// Defines values for BankingProductLendingRateV2LendingRateType.
const (
	BankingProductLendingRateV2LendingRateTypeBUNDLEDISCOUNTFIXED    BankingProductLendingRateV2LendingRateType = "BUNDLE_DISCOUNT_FIXED"
	BankingProductLendingRateV2LendingRateTypeBUNDLEDISCOUNTVARIABLE BankingProductLendingRateV2LendingRateType = "BUNDLE_DISCOUNT_VARIABLE"
	BankingProductLendingRateV2LendingRateTypeCASHADVANCE            BankingProductLendingRateV2LendingRateType = "CASH_ADVANCE"
	BankingProductLendingRateV2LendingRateTypeDISCOUNT               BankingProductLendingRateV2LendingRateType = "DISCOUNT"
	BankingProductLendingRateV2LendingRateTypeFIXED                  BankingProductLendingRateV2LendingRateType = "FIXED"
	BankingProductLendingRateV2LendingRateTypeFLOATING               BankingProductLendingRateV2LendingRateType = "FLOATING"
	BankingProductLendingRateV2LendingRateTypeINTRODUCTORY           BankingProductLendingRateV2LendingRateType = "INTRODUCTORY"
	BankingProductLendingRateV2LendingRateTypeMARKETLINKED           BankingProductLendingRateV2LendingRateType = "MARKET_LINKED"
	BankingProductLendingRateV2LendingRateTypePENALTY                BankingProductLendingRateV2LendingRateType = "PENALTY"
	BankingProductLendingRateV2LendingRateTypePURCHASE               BankingProductLendingRateV2LendingRateType = "PURCHASE"
	BankingProductLendingRateV2LendingRateTypeVARIABLE               BankingProductLendingRateV2LendingRateType = "VARIABLE"
)

// Defines values for BankingProductLendingRateV2LoanPurpose.
const (
	INVESTMENT    BankingProductLendingRateV2LoanPurpose = "INVESTMENT"
	OWNEROCCUPIED BankingProductLendingRateV2LoanPurpose = "OWNER_OCCUPIED"
)

// Defines values for BankingProductLendingRateV2RepaymentType.
const (
	BankingProductLendingRateV2RepaymentTypeINTERESTONLY         BankingProductLendingRateV2RepaymentType = "INTEREST_ONLY"
	BankingProductLendingRateV2RepaymentTypePRINCIPALANDINTEREST BankingProductLendingRateV2RepaymentType = "PRINCIPAL_AND_INTEREST"
)

// Defines values for BankingProductRateTierV3RateApplicationMethod.
const (
	PERTIER      BankingProductRateTierV3RateApplicationMethod = "PER_TIER"
	WHOLEBALANCE BankingProductRateTierV3RateApplicationMethod = "WHOLE_BALANCE"
)

// Defines values for BankingProductRateTierV3UnitOfMeasure.
const (
	DAY     BankingProductRateTierV3UnitOfMeasure = "DAY"
	DOLLAR  BankingProductRateTierV3UnitOfMeasure = "DOLLAR"
	MONTH   BankingProductRateTierV3UnitOfMeasure = "MONTH"
	PERCENT BankingProductRateTierV3UnitOfMeasure = "PERCENT"
)

// Defines values for BankingScheduledPaymentStatus.
const (
	ACTIVE   BankingScheduledPaymentStatus = "ACTIVE"
	INACTIVE BankingScheduledPaymentStatus = "INACTIVE"
	SKIP     BankingScheduledPaymentStatus = "SKIP"
)

// Defines values for BankingScheduledPaymentRecurrenceRecurrenceUType.
const (
	EventBased       BankingScheduledPaymentRecurrenceRecurrenceUType = "eventBased"
	IntervalSchedule BankingScheduledPaymentRecurrenceRecurrenceUType = "intervalSchedule"
	LastWeekDay      BankingScheduledPaymentRecurrenceRecurrenceUType = "lastWeekDay"
	OnceOff          BankingScheduledPaymentRecurrenceRecurrenceUType = "onceOff"
)

// Defines values for BankingScheduledPaymentRecurrenceIntervalScheduleNonBusinessDayTreatment.
const (
	BankingScheduledPaymentRecurrenceIntervalScheduleNonBusinessDayTreatmentAFTER  BankingScheduledPaymentRecurrenceIntervalScheduleNonBusinessDayTreatment = "AFTER"
	BankingScheduledPaymentRecurrenceIntervalScheduleNonBusinessDayTreatmentBEFORE BankingScheduledPaymentRecurrenceIntervalScheduleNonBusinessDayTreatment = "BEFORE"
	BankingScheduledPaymentRecurrenceIntervalScheduleNonBusinessDayTreatmentON     BankingScheduledPaymentRecurrenceIntervalScheduleNonBusinessDayTreatment = "ON"
	BankingScheduledPaymentRecurrenceIntervalScheduleNonBusinessDayTreatmentONLY   BankingScheduledPaymentRecurrenceIntervalScheduleNonBusinessDayTreatment = "ONLY"
)

// Defines values for BankingScheduledPaymentRecurrenceLastWeekdayLastWeekDay.
const (
	FRI BankingScheduledPaymentRecurrenceLastWeekdayLastWeekDay = "FRI"
	MON BankingScheduledPaymentRecurrenceLastWeekdayLastWeekDay = "MON"
	SAT BankingScheduledPaymentRecurrenceLastWeekdayLastWeekDay = "SAT"
	SUN BankingScheduledPaymentRecurrenceLastWeekdayLastWeekDay = "SUN"
	THU BankingScheduledPaymentRecurrenceLastWeekdayLastWeekDay = "THU"
	TUE BankingScheduledPaymentRecurrenceLastWeekdayLastWeekDay = "TUE"
	WED BankingScheduledPaymentRecurrenceLastWeekdayLastWeekDay = "WED"
)

// Defines values for BankingScheduledPaymentRecurrenceLastWeekdayNonBusinessDayTreatment.
const (
	BankingScheduledPaymentRecurrenceLastWeekdayNonBusinessDayTreatmentAFTER  BankingScheduledPaymentRecurrenceLastWeekdayNonBusinessDayTreatment = "AFTER"
	BankingScheduledPaymentRecurrenceLastWeekdayNonBusinessDayTreatmentBEFORE BankingScheduledPaymentRecurrenceLastWeekdayNonBusinessDayTreatment = "BEFORE"
	BankingScheduledPaymentRecurrenceLastWeekdayNonBusinessDayTreatmentON     BankingScheduledPaymentRecurrenceLastWeekdayNonBusinessDayTreatment = "ON"
	BankingScheduledPaymentRecurrenceLastWeekdayNonBusinessDayTreatmentONLY   BankingScheduledPaymentRecurrenceLastWeekdayNonBusinessDayTreatment = "ONLY"
)

// Defines values for BankingScheduledPaymentToToUType.
const (
	BankingScheduledPaymentToToUTypeAccountId     BankingScheduledPaymentToToUType = "accountId"
	BankingScheduledPaymentToToUTypeBiller        BankingScheduledPaymentToToUType = "biller"
	BankingScheduledPaymentToToUTypeDomestic      BankingScheduledPaymentToToUType = "domestic"
	BankingScheduledPaymentToToUTypeInternational BankingScheduledPaymentToToUType = "international"
	BankingScheduledPaymentToToUTypePayeeId       BankingScheduledPaymentToToUType = "payeeId"
)

// Defines values for BankingTermDepositAccountMaturityInstructions.
const (
	HOLDONMATURITY    BankingTermDepositAccountMaturityInstructions = "HOLD_ON_MATURITY"
	PAIDOUTATMATURITY BankingTermDepositAccountMaturityInstructions = "PAID_OUT_AT_MATURITY"
	ROLLEDOVER        BankingTermDepositAccountMaturityInstructions = "ROLLED_OVER"
)

// Defines values for BankingTransactionStatus.
const (
	BankingTransactionStatusPENDING BankingTransactionStatus = "PENDING"
	BankingTransactionStatusPOSTED  BankingTransactionStatus = "POSTED"
)

// Defines values for BankingTransactionType.
const (
	BankingTransactionTypeDIRECTDEBIT      BankingTransactionType = "DIRECT_DEBIT"
	BankingTransactionTypeFEE              BankingTransactionType = "FEE"
	BankingTransactionTypeINTERESTCHARGED  BankingTransactionType = "INTEREST_CHARGED"
	BankingTransactionTypeINTERESTPAID     BankingTransactionType = "INTEREST_PAID"
	BankingTransactionTypeOTHER            BankingTransactionType = "OTHER"
	BankingTransactionTypePAYMENT          BankingTransactionType = "PAYMENT"
	BankingTransactionTypeTRANSFERINCOMING BankingTransactionType = "TRANSFER_INCOMING"
	BankingTransactionTypeTRANSFEROUTGOING BankingTransactionType = "TRANSFER_OUTGOING"
)

// Defines values for BankingTransactionDetailExtendedDataExtensionUType.
const (
	X2p101Payload BankingTransactionDetailExtendedDataExtensionUType = "x2p101Payload"
)

// Defines values for BankingTransactionDetailExtendedDataService.
const (
	X2P101 BankingTransactionDetailExtendedDataService = "X2P1.01"
)

// Defines values for BankingTransactionDetailStatus.
const (
	BankingTransactionDetailStatusPENDING BankingTransactionDetailStatus = "PENDING"
	BankingTransactionDetailStatusPOSTED  BankingTransactionDetailStatus = "POSTED"
)

// Defines values for BankingTransactionDetailType.
const (
	BankingTransactionDetailTypeDIRECTDEBIT      BankingTransactionDetailType = "DIRECT_DEBIT"
	BankingTransactionDetailTypeFEE              BankingTransactionDetailType = "FEE"
	BankingTransactionDetailTypeINTERESTCHARGED  BankingTransactionDetailType = "INTEREST_CHARGED"
	BankingTransactionDetailTypeINTERESTPAID     BankingTransactionDetailType = "INTEREST_PAID"
	BankingTransactionDetailTypeOTHER            BankingTransactionDetailType = "OTHER"
	BankingTransactionDetailTypePAYMENT          BankingTransactionDetailType = "PAYMENT"
	BankingTransactionDetailTypeTRANSFERINCOMING BankingTransactionDetailType = "TRANSFER_INCOMING"
	BankingTransactionDetailTypeTRANSFEROUTGOING BankingTransactionDetailType = "TRANSFER_OUTGOING"
)

// Defines values for CommonPhysicalAddressAddressUType.
const (
	Paf    CommonPhysicalAddressAddressUType = "paf"
	Simple CommonPhysicalAddressAddressUType = "simple"
)

// Defines values for ListAccountsParamsProductCategory.
const (
	ListAccountsParamsProductCategoryBUSINESSLOANS           ListAccountsParamsProductCategory = "BUSINESS_LOANS"
	ListAccountsParamsProductCategoryCREDANDCHRGCARDS        ListAccountsParamsProductCategory = "CRED_AND_CHRG_CARDS"
	ListAccountsParamsProductCategoryLEASES                  ListAccountsParamsProductCategory = "LEASES"
	ListAccountsParamsProductCategoryMARGINLOANS             ListAccountsParamsProductCategory = "MARGIN_LOANS"
	ListAccountsParamsProductCategoryOVERDRAFTS              ListAccountsParamsProductCategory = "OVERDRAFTS"
	ListAccountsParamsProductCategoryPERSLOANS               ListAccountsParamsProductCategory = "PERS_LOANS"
	ListAccountsParamsProductCategoryREGULATEDTRUSTACCOUNTS  ListAccountsParamsProductCategory = "REGULATED_TRUST_ACCOUNTS"
	ListAccountsParamsProductCategoryRESIDENTIALMORTGAGES    ListAccountsParamsProductCategory = "RESIDENTIAL_MORTGAGES"
	ListAccountsParamsProductCategoryTERMDEPOSITS            ListAccountsParamsProductCategory = "TERM_DEPOSITS"
	ListAccountsParamsProductCategoryTRADEFINANCE            ListAccountsParamsProductCategory = "TRADE_FINANCE"
	ListAccountsParamsProductCategoryTRANSANDSAVINGSACCOUNTS ListAccountsParamsProductCategory = "TRANS_AND_SAVINGS_ACCOUNTS"
	ListAccountsParamsProductCategoryTRAVELCARDS             ListAccountsParamsProductCategory = "TRAVEL_CARDS"
)

// Defines values for ListAccountsParamsOpenStatus.
const (
	ListAccountsParamsOpenStatusALL    ListAccountsParamsOpenStatus = "ALL"
	ListAccountsParamsOpenStatusCLOSED ListAccountsParamsOpenStatus = "CLOSED"
	ListAccountsParamsOpenStatusOPEN   ListAccountsParamsOpenStatus = "OPEN"
)

// Defines values for ListBalancesBulkParamsProductCategory.
const (
	ListBalancesBulkParamsProductCategoryBUSINESSLOANS           ListBalancesBulkParamsProductCategory = "BUSINESS_LOANS"
	ListBalancesBulkParamsProductCategoryCREDANDCHRGCARDS        ListBalancesBulkParamsProductCategory = "CRED_AND_CHRG_CARDS"
	ListBalancesBulkParamsProductCategoryLEASES                  ListBalancesBulkParamsProductCategory = "LEASES"
	ListBalancesBulkParamsProductCategoryMARGINLOANS             ListBalancesBulkParamsProductCategory = "MARGIN_LOANS"
	ListBalancesBulkParamsProductCategoryOVERDRAFTS              ListBalancesBulkParamsProductCategory = "OVERDRAFTS"
	ListBalancesBulkParamsProductCategoryPERSLOANS               ListBalancesBulkParamsProductCategory = "PERS_LOANS"
	ListBalancesBulkParamsProductCategoryREGULATEDTRUSTACCOUNTS  ListBalancesBulkParamsProductCategory = "REGULATED_TRUST_ACCOUNTS"
	ListBalancesBulkParamsProductCategoryRESIDENTIALMORTGAGES    ListBalancesBulkParamsProductCategory = "RESIDENTIAL_MORTGAGES"
	ListBalancesBulkParamsProductCategoryTERMDEPOSITS            ListBalancesBulkParamsProductCategory = "TERM_DEPOSITS"
	ListBalancesBulkParamsProductCategoryTRADEFINANCE            ListBalancesBulkParamsProductCategory = "TRADE_FINANCE"
	ListBalancesBulkParamsProductCategoryTRANSANDSAVINGSACCOUNTS ListBalancesBulkParamsProductCategory = "TRANS_AND_SAVINGS_ACCOUNTS"
	ListBalancesBulkParamsProductCategoryTRAVELCARDS             ListBalancesBulkParamsProductCategory = "TRAVEL_CARDS"
)

// Defines values for ListBalancesBulkParamsOpenStatus.
const (
	ListBalancesBulkParamsOpenStatusALL    ListBalancesBulkParamsOpenStatus = "ALL"
	ListBalancesBulkParamsOpenStatusCLOSED ListBalancesBulkParamsOpenStatus = "CLOSED"
	ListBalancesBulkParamsOpenStatusOPEN   ListBalancesBulkParamsOpenStatus = "OPEN"
)

// Defines values for ListDirectDebitsBulkParamsProductCategory.
const (
	ListDirectDebitsBulkParamsProductCategoryBUSINESSLOANS           ListDirectDebitsBulkParamsProductCategory = "BUSINESS_LOANS"
	ListDirectDebitsBulkParamsProductCategoryCREDANDCHRGCARDS        ListDirectDebitsBulkParamsProductCategory = "CRED_AND_CHRG_CARDS"
	ListDirectDebitsBulkParamsProductCategoryLEASES                  ListDirectDebitsBulkParamsProductCategory = "LEASES"
	ListDirectDebitsBulkParamsProductCategoryMARGINLOANS             ListDirectDebitsBulkParamsProductCategory = "MARGIN_LOANS"
	ListDirectDebitsBulkParamsProductCategoryOVERDRAFTS              ListDirectDebitsBulkParamsProductCategory = "OVERDRAFTS"
	ListDirectDebitsBulkParamsProductCategoryPERSLOANS               ListDirectDebitsBulkParamsProductCategory = "PERS_LOANS"
	ListDirectDebitsBulkParamsProductCategoryREGULATEDTRUSTACCOUNTS  ListDirectDebitsBulkParamsProductCategory = "REGULATED_TRUST_ACCOUNTS"
	ListDirectDebitsBulkParamsProductCategoryRESIDENTIALMORTGAGES    ListDirectDebitsBulkParamsProductCategory = "RESIDENTIAL_MORTGAGES"
	ListDirectDebitsBulkParamsProductCategoryTERMDEPOSITS            ListDirectDebitsBulkParamsProductCategory = "TERM_DEPOSITS"
	ListDirectDebitsBulkParamsProductCategoryTRADEFINANCE            ListDirectDebitsBulkParamsProductCategory = "TRADE_FINANCE"
	ListDirectDebitsBulkParamsProductCategoryTRANSANDSAVINGSACCOUNTS ListDirectDebitsBulkParamsProductCategory = "TRANS_AND_SAVINGS_ACCOUNTS"
	ListDirectDebitsBulkParamsProductCategoryTRAVELCARDS             ListDirectDebitsBulkParamsProductCategory = "TRAVEL_CARDS"
)

// Defines values for ListDirectDebitsBulkParamsOpenStatus.
const (
	ListDirectDebitsBulkParamsOpenStatusALL    ListDirectDebitsBulkParamsOpenStatus = "ALL"
	ListDirectDebitsBulkParamsOpenStatusCLOSED ListDirectDebitsBulkParamsOpenStatus = "CLOSED"
	ListDirectDebitsBulkParamsOpenStatusOPEN   ListDirectDebitsBulkParamsOpenStatus = "OPEN"
)

// Defines values for ListPayeesParamsType.
const (
	ListPayeesParamsTypeALL           ListPayeesParamsType = "ALL"
	ListPayeesParamsTypeBILLER        ListPayeesParamsType = "BILLER"
	ListPayeesParamsTypeDIGITALWALLET ListPayeesParamsType = "DIGITAL_WALLET"
	ListPayeesParamsTypeDOMESTIC      ListPayeesParamsType = "DOMESTIC"
	ListPayeesParamsTypeINTERNATIONAL ListPayeesParamsType = "INTERNATIONAL"
)

// Defines values for ListScheduledPaymentsBulkParamsProductCategory.
const (
	ListScheduledPaymentsBulkParamsProductCategoryBUSINESSLOANS           ListScheduledPaymentsBulkParamsProductCategory = "BUSINESS_LOANS"
	ListScheduledPaymentsBulkParamsProductCategoryCREDANDCHRGCARDS        ListScheduledPaymentsBulkParamsProductCategory = "CRED_AND_CHRG_CARDS"
	ListScheduledPaymentsBulkParamsProductCategoryLEASES                  ListScheduledPaymentsBulkParamsProductCategory = "LEASES"
	ListScheduledPaymentsBulkParamsProductCategoryMARGINLOANS             ListScheduledPaymentsBulkParamsProductCategory = "MARGIN_LOANS"
	ListScheduledPaymentsBulkParamsProductCategoryOVERDRAFTS              ListScheduledPaymentsBulkParamsProductCategory = "OVERDRAFTS"
	ListScheduledPaymentsBulkParamsProductCategoryPERSLOANS               ListScheduledPaymentsBulkParamsProductCategory = "PERS_LOANS"
	ListScheduledPaymentsBulkParamsProductCategoryREGULATEDTRUSTACCOUNTS  ListScheduledPaymentsBulkParamsProductCategory = "REGULATED_TRUST_ACCOUNTS"
	ListScheduledPaymentsBulkParamsProductCategoryRESIDENTIALMORTGAGES    ListScheduledPaymentsBulkParamsProductCategory = "RESIDENTIAL_MORTGAGES"
	ListScheduledPaymentsBulkParamsProductCategoryTERMDEPOSITS            ListScheduledPaymentsBulkParamsProductCategory = "TERM_DEPOSITS"
	ListScheduledPaymentsBulkParamsProductCategoryTRADEFINANCE            ListScheduledPaymentsBulkParamsProductCategory = "TRADE_FINANCE"
	ListScheduledPaymentsBulkParamsProductCategoryTRANSANDSAVINGSACCOUNTS ListScheduledPaymentsBulkParamsProductCategory = "TRANS_AND_SAVINGS_ACCOUNTS"
	ListScheduledPaymentsBulkParamsProductCategoryTRAVELCARDS             ListScheduledPaymentsBulkParamsProductCategory = "TRAVEL_CARDS"
)

// Defines values for ListScheduledPaymentsBulkParamsOpenStatus.
const (
	ListScheduledPaymentsBulkParamsOpenStatusALL    ListScheduledPaymentsBulkParamsOpenStatus = "ALL"
	ListScheduledPaymentsBulkParamsOpenStatusCLOSED ListScheduledPaymentsBulkParamsOpenStatus = "CLOSED"
	ListScheduledPaymentsBulkParamsOpenStatusOPEN   ListScheduledPaymentsBulkParamsOpenStatus = "OPEN"
)

// Defines values for ListProductsParamsEffective.
const (
	ListProductsParamsEffectiveALL     ListProductsParamsEffective = "ALL"
	ListProductsParamsEffectiveCURRENT ListProductsParamsEffective = "CURRENT"
	ListProductsParamsEffectiveFUTURE  ListProductsParamsEffective = "FUTURE"
)

// Defines values for ListProductsParamsProductCategory.
const (
	ListProductsParamsProductCategoryBUSINESSLOANS           ListProductsParamsProductCategory = "BUSINESS_LOANS"
	ListProductsParamsProductCategoryCREDANDCHRGCARDS        ListProductsParamsProductCategory = "CRED_AND_CHRG_CARDS"
	ListProductsParamsProductCategoryLEASES                  ListProductsParamsProductCategory = "LEASES"
	ListProductsParamsProductCategoryMARGINLOANS             ListProductsParamsProductCategory = "MARGIN_LOANS"
	ListProductsParamsProductCategoryOVERDRAFTS              ListProductsParamsProductCategory = "OVERDRAFTS"
	ListProductsParamsProductCategoryPERSLOANS               ListProductsParamsProductCategory = "PERS_LOANS"
	ListProductsParamsProductCategoryREGULATEDTRUSTACCOUNTS  ListProductsParamsProductCategory = "REGULATED_TRUST_ACCOUNTS"
	ListProductsParamsProductCategoryRESIDENTIALMORTGAGES    ListProductsParamsProductCategory = "RESIDENTIAL_MORTGAGES"
	ListProductsParamsProductCategoryTERMDEPOSITS            ListProductsParamsProductCategory = "TERM_DEPOSITS"
	ListProductsParamsProductCategoryTRADEFINANCE            ListProductsParamsProductCategory = "TRADE_FINANCE"
	ListProductsParamsProductCategoryTRANSANDSAVINGSACCOUNTS ListProductsParamsProductCategory = "TRANS_AND_SAVINGS_ACCOUNTS"
	ListProductsParamsProductCategoryTRAVELCARDS             ListProductsParamsProductCategory = "TRAVEL_CARDS"
)

// BankingAccount defines model for BankingAccount.
type BankingAccount struct {
	// AccountId A unique ID of the account adhering to the standards for ID permanence
	AccountId string `json:"accountId"`

	// CreationDate Date that the account was created (if known)
	CreationDate *string `json:"creationDate,omitempty"`

	// DisplayName The display name of the account as defined by the bank. This should not incorporate account numbers or PANs. If it does the values should be masked according to the rules of the MaskedAccountString common type.
	DisplayName string `json:"displayName"`

	// IsOwned Flag indicating that the customer associated with the authorisation is an owner of the account. Does not indicate sole ownership, however. If not present then 'true' is assumed
	IsOwned *bool `json:"isOwned,omitempty"`

	// MaskedNumber A masked version of the account. Whether BSB/Account Number, Credit Card PAN or another number
	MaskedNumber string `json:"maskedNumber"`

	// Nickname A customer supplied nick name for the account
	Nickname *string `json:"nickname,omitempty"`

	// OpenStatus Open or closed status for the account. If not present then OPEN is assumed
	OpenStatus *BankingAccountOpenStatus `json:"openStatus,omitempty"`

	// ProductCategory The category to which a product or account belongs. See [here](#product-categories) for more details
	ProductCategory BankingProductCategory `json:"productCategory"`

	// ProductName The unique identifier of the account as defined by the data holder (akin to model number for the account)
	ProductName string `json:"productName"`
}

// BankingAccountOpenStatus Open or closed status for the account. If not present then OPEN is assumed
type BankingAccountOpenStatus string

// BankingAccountDetailV2 defines model for BankingAccountDetailV2.
type BankingAccountDetailV2 struct {
	// AccountId A unique ID of the account adhering to the standards for ID permanence
	AccountId string `json:"accountId"`

	// AccountNumber The unmasked account number for the account. Should not be supplied if the account number is a PAN requiring PCI compliance. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces
	AccountNumber *string `json:"accountNumber,omitempty"`

	// Addresses The addresses for the account to be used for correspondence
	Addresses *[]CommonPhysicalAddress `json:"addresses,omitempty"`

	// Bsb The unmasked BSB for the account. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces
	Bsb *string `json:"bsb,omitempty"`

	// BundleName Optional field to indicate if this account is part of a bundle that is providing additional benefit for to the customer
	BundleName *string `json:"bundleName,omitempty"`

	// CreationDate Date that the account was created (if known)
	CreationDate *string                   `json:"creationDate,omitempty"`
	CreditCard   *BankingCreditCardAccount `json:"creditCard,omitempty"`

	// DepositRate current rate to calculate interest earned being applied to deposit balances as it stands at the time of the API call
	DepositRate *string `json:"depositRate,omitempty"`

	// DepositRates Fully described deposit rates for this account based on the equivalent structure in Product Reference
	DepositRates *[]BankingProductDepositRate `json:"depositRates,omitempty"`

	// DisplayName The display name of the account as defined by the bank. This should not incorporate account numbers or PANs. If it does the values should be masked according to the rules of the MaskedAccountString common type.
	DisplayName string `json:"displayName"`

	// Features Array of features of the account based on the equivalent structure in Product Reference with the following additional field
	Features *[]struct {
		// AdditionalInfo Display text providing more information on the feature. Mandatory if the [feature type](#tocSproductfeaturetypedoc) is set to OTHER
		AdditionalInfo *string `json:"additionalInfo,omitempty"`

		// AdditionalInfoUri Link to a web page with more information on this feature
		AdditionalInfoUri *string `json:"additionalInfoUri,omitempty"`

		// AdditionalValue Generic field containing additional information relevant to the [featureType](#tocSproductfeaturetypedoc) specified. Whether mandatory or not is dependent on the value of the [featureType.](#tocSproductfeaturetypedoc)
		AdditionalValue *string `json:"additionalValue,omitempty"`

		// FeatureType The type of feature described
		FeatureType BankingAccountDetailV2FeaturesFeatureType `json:"featureType"`

		// IsActivated True if the feature is already activated and false if the feature is available for activation. Defaults to true if absent. (note this is an additional field appended to the feature object defined in the Product Reference payload)
		IsActivated *bool `json:"isActivated,omitempty"`
	} `json:"features,omitempty"`

	// Fees Fees and charges applicable to the account based on the equivalent structure in Product Reference
	Fees *[]BankingProductFee `json:"fees,omitempty"`

	// IsOwned Flag indicating that the customer associated with the authorisation is an owner of the account. Does not indicate sole ownership, however. If not present then 'true' is assumed
	IsOwned *bool `json:"isOwned,omitempty"`

	// LendingRate The current rate to calculate interest payable being applied to lending balances as it stands at the time of the API call
	LendingRate *string `json:"lendingRate,omitempty"`

	// LendingRates Fully described deposit rates for this account based on the equivalent structure in Product Reference
	LendingRates *[]BankingProductLendingRateV2 `json:"lendingRates,omitempty"`
	Loan         *BankingLoanAccountV2          `json:"loan,omitempty"`

	// MaskedNumber A masked version of the account. Whether BSB/Account Number, Credit Card PAN or another number
	MaskedNumber string `json:"maskedNumber"`

	// Nickname A customer supplied nick name for the account
	Nickname *string `json:"nickname,omitempty"`

	// OpenStatus Open or closed status for the account. If not present then OPEN is assumed
	OpenStatus *BankingAccountDetailV2OpenStatus `json:"openStatus,omitempty"`

	// ProductCategory The category to which a product or account belongs. See [here](#product-categories) for more details
	ProductCategory BankingProductCategory `json:"productCategory"`

	// ProductName The unique identifier of the account as defined by the data holder (akin to model number for the account)
	ProductName string `json:"productName"`

	// SpecificAccountUType The type of structure to present account specific fields.
	SpecificAccountUType *BankingAccountDetailV2SpecificAccountUType `json:"specificAccountUType,omitempty"`
	TermDeposit          *[]BankingTermDepositAccount                `json:"termDeposit,omitempty"`
}

// BankingAccountDetailV2FeaturesFeatureType The type of feature described
type BankingAccountDetailV2FeaturesFeatureType string

// BankingAccountDetailV2OpenStatus Open or closed status for the account. If not present then OPEN is assumed
type BankingAccountDetailV2OpenStatus string

// BankingAccountDetailV2SpecificAccountUType The type of structure to present account specific fields.
type BankingAccountDetailV2SpecificAccountUType string

// BankingAuthorisedEntity defines model for BankingAuthorisedEntity.
type BankingAuthorisedEntity struct {
	// Abn Australian Business Number for the authorised entity
	Abn *string `json:"abn,omitempty"`

	// Acn Australian Company Number for the authorised entity
	Acn *string `json:"acn,omitempty"`

	// Arbn Australian Registered Body Number for the authorised entity
	Arbn *string `json:"arbn,omitempty"`

	// Description Description of the authorised entity derived from previously executed direct debits
	Description *string `json:"description,omitempty"`

	// FinancialInstitution Name of the financial institution through which the direct debit will be executed. Is required unless the payment is made via a credit card scheme
	FinancialInstitution *string `json:"financialInstitution,omitempty"`
}

// BankingBalance defines model for BankingBalance.
type BankingBalance struct {
	// AccountId A unique ID of the account adhering to the standards for ID permanence
	AccountId string `json:"accountId"`

	// AmortisedLimit Object representing the available limit amortised according to payment schedule. Assumed to be zero if absent
	AmortisedLimit *string `json:"amortisedLimit,omitempty"`

	// AvailableBalance Balance representing the amount of funds available for transfer. Assumed to be zero or positive
	AvailableBalance string `json:"availableBalance"`

	// CreditLimit Object representing the maximum amount of credit that is available for this account. Assumed to be zero if absent
	CreditLimit *string `json:"creditLimit,omitempty"`

	// Currency The currency for the balance amounts. If absent assumed to be AUD
	Currency *string `json:"currency,omitempty"`

	// CurrentBalance The balance of the account at this time. Should align to the balance available via other channels such as Internet Banking. Assumed to be negative if the customer has money owing
	CurrentBalance string `json:"currentBalance"`

	// Purses Optional array of balances for the account in other currencies. Included to support accounts that support multi-currency purses such as Travel Cards
	Purses *[]BankingBalancePurse `json:"purses,omitempty"`
}

// BankingBalancePurse defines model for BankingBalancePurse.
type BankingBalancePurse struct {
	// Amount The balance available for this additional currency purse
	Amount string `json:"amount"`

	// Currency The currency for the purse
	Currency *string `json:"currency,omitempty"`
}

// BankingBillerPayee defines model for BankingBillerPayee.
type BankingBillerPayee struct {
	// BillerCode BPAY Biller Code of the Biller
	BillerCode string `json:"billerCode"`

	// BillerName Name of the Biller
	BillerName string `json:"billerName"`

	// Crn BPAY CRN of the Biller (if available).<br/>Where the CRN contains sensitive information, it should be masked in line with how the Data Holder currently displays account identifiers in their existing online banking channels. If the contents of the CRN match the format of a Credit Card PAN they should be masked according to the rules applicable for MaskedPANString. If the contents are are otherwise sensitive, then it should be masked using the rules applicable for the MaskedAccountString common type.
	Crn *string `json:"crn,omitempty"`
}

// BankingCreditCardAccount defines model for BankingCreditCardAccount.
type BankingCreditCardAccount struct {
	// MinPaymentAmount The minimum payment amount due for the next card payment
	MinPaymentAmount string `json:"minPaymentAmount"`

	// PaymentCurrency If absent assumes AUD
	PaymentCurrency *string `json:"paymentCurrency,omitempty"`

	// PaymentDueAmount The amount due for the next card payment
	PaymentDueAmount string `json:"paymentDueAmount"`

	// PaymentDueDate Date that the next payment for the card is due
	PaymentDueDate string `json:"paymentDueDate"`
}

// BankingDigitalWalletPayee defines model for BankingDigitalWalletPayee.
type BankingDigitalWalletPayee struct {
	// Identifier The identifier of the digital wallet (dependent on type)
	Identifier string `json:"identifier"`

	// Name The name assigned to the digital wallet by the owner of the wallet, else the display name provided by the digital wallet provider
	Name string `json:"name"`

	// Provider The provider of the digital wallet
	Provider BankingDigitalWalletPayeeProvider `json:"provider"`

	// Type The type of the digital wallet identifier
	Type BankingDigitalWalletPayeeType `json:"type"`
}

// BankingDigitalWalletPayeeProvider The provider of the digital wallet
type BankingDigitalWalletPayeeProvider string

// BankingDigitalWalletPayeeType The type of the digital wallet identifier
type BankingDigitalWalletPayeeType string

// BankingDirectDebit defines model for BankingDirectDebit.
type BankingDirectDebit struct {
	// AccountId A unique ID of the account adhering to the standards for ID permanence.
	AccountId        string                  `json:"accountId"`
	AuthorisedEntity BankingAuthorisedEntity `json:"authorisedEntity"`

	// LastDebitAmount The amount of the last debit executed under this authorisation
	LastDebitAmount *string `json:"lastDebitAmount,omitempty"`

	// LastDebitDateTime The date and time of the last debit executed under this authorisation
	LastDebitDateTime *string `json:"lastDebitDateTime,omitempty"`
}

// BankingDomesticPayee defines model for BankingDomesticPayee.
type BankingDomesticPayee struct {
	Account *BankingDomesticPayeeAccount `json:"account,omitempty"`
	Card    *BankingDomesticPayeeCard    `json:"card,omitempty"`
	PayId   *BankingDomesticPayeePayId   `json:"payId,omitempty"`

	// PayeeAccountUType Type of account object included. Valid values are: **account** A standard Australian account defined by BSB/Account Number. **card** A credit or charge card to pay to (note that PANs are masked). **payId** A PayID recognised by NPP
	PayeeAccountUType BankingDomesticPayeePayeeAccountUType `json:"payeeAccountUType"`
}

// BankingDomesticPayeePayeeAccountUType Type of account object included. Valid values are: **account** A standard Australian account defined by BSB/Account Number. **card** A credit or charge card to pay to (note that PANs are masked). **payId** A PayID recognised by NPP
type BankingDomesticPayeePayeeAccountUType string

// BankingDomesticPayeeAccount defines model for BankingDomesticPayeeAccount.
type BankingDomesticPayeeAccount struct {
	// AccountName Name of the account to pay to
	AccountName *string `json:"accountName,omitempty"`

	// AccountNumber Number of the account to pay to
	AccountNumber string `json:"accountNumber"`

	// Bsb BSB of the account to pay to
	Bsb string `json:"bsb"`
}

// BankingDomesticPayeeCard defines model for BankingDomesticPayeeCard.
type BankingDomesticPayeeCard struct {
	// CardNumber Name of the account to pay to
	CardNumber string `json:"cardNumber"`
}

// BankingDomesticPayeePayId defines model for BankingDomesticPayeePayId.
type BankingDomesticPayeePayId struct {
	// Identifier The identifier of the PayID (dependent on type)
	Identifier string `json:"identifier"`

	// Name The name assigned to the PayID by the owner of the PayID
	Name *string `json:"name,omitempty"`

	// Type The type of the PayID
	Type BankingDomesticPayeePayIdType `json:"type"`
}

// BankingDomesticPayeePayIdType The type of the PayID
type BankingDomesticPayeePayIdType string

// BankingInternationalPayee defines model for BankingInternationalPayee.
type BankingInternationalPayee struct {
	BankDetails struct {
		// AccountNumber Account Targeted for payment
		AccountNumber string `json:"accountNumber"`
		BankAddress   *struct {
			// Address Address of the recipient Bank
			Address string `json:"address"`

			// Name Name of the recipient Bank
			Name string `json:"name"`
		} `json:"bankAddress,omitempty"`

		// BeneficiaryBankBIC Swift bank code.  Aligns with standard [ISO 9362](https://www.iso.org/standard/60390.html)
		BeneficiaryBankBIC *string `json:"beneficiaryBankBIC,omitempty"`

		// ChipNumber Number for the Clearing House Interbank Payments System
		ChipNumber *string `json:"chipNumber,omitempty"`

		// Country Country of the recipient institution. A valid [ISO 3166 Alpha-3](https://www.iso.org/iso-3166-country-codes.html) country code
		Country string `json:"country"`

		// FedWireNumber Number for Fedwire payment (Federal Reserve Wire Network)
		FedWireNumber *string `json:"fedWireNumber,omitempty"`

		// LegalEntityIdentifier The legal entity identifier (LEI) for the beneficiary.  Aligns with [ISO 17442](https://www.iso.org/standard/59771.html)
		LegalEntityIdentifier *string `json:"legalEntityIdentifier,omitempty"`

		// RoutingNumber International bank routing number
		RoutingNumber *string `json:"routingNumber,omitempty"`

		// SortCode Sort code used for account identification in some jurisdictions
		SortCode *string `json:"sortCode,omitempty"`
	} `json:"bankDetails"`
	BeneficiaryDetails struct {
		// Country Country where the beneficiary resides. A valid [ISO 3166 Alpha-3](https://www.iso.org/iso-3166-country-codes.html) country code
		Country string `json:"country"`

		// Message Response message for the payment
		Message *string `json:"message,omitempty"`

		// Name Name of the beneficiary
		Name *string `json:"name,omitempty"`
	} `json:"beneficiaryDetails"`
}

// BankingLoanAccountV2 defines model for BankingLoanAccountV2.
type BankingLoanAccountV2 struct {
	// LoanEndDate Date that the loan is due to be repaid in full
	LoanEndDate *string `json:"loanEndDate,omitempty"`

	// MaxRedraw Maximum amount of funds that can be redrawn. If not present redraw is not available even if the feature exists for the account
	MaxRedraw *string `json:"maxRedraw,omitempty"`

	// MaxRedrawCurrency If absent assumes AUD
	MaxRedrawCurrency *string `json:"maxRedrawCurrency,omitempty"`

	// MinInstalmentAmount Minimum amount of next instalment
	MinInstalmentAmount *string `json:"minInstalmentAmount,omitempty"`

	// MinInstalmentCurrency If absent assumes AUD
	MinInstalmentCurrency *string `json:"minInstalmentCurrency,omitempty"`

	// MinRedraw Minimum redraw amount
	MinRedraw *string `json:"minRedraw,omitempty"`

	// MinRedrawCurrency If absent assumes AUD
	MinRedrawCurrency *string `json:"minRedrawCurrency,omitempty"`

	// NextInstalmentDate Next date that an instalment is required
	NextInstalmentDate *string `json:"nextInstalmentDate,omitempty"`

	// OffsetAccountEnabled Set to true if one or more offset accounts are configured for this loan account
	OffsetAccountEnabled *bool `json:"offsetAccountEnabled,omitempty"`

	// OffsetAccountIds The accountIDs of the configured offset accounts attached to this loan. Only offset accounts that can be accessed under the current authorisation should be included. It is expected behaviour that offsetAccountEnabled is set to true but the offsetAccountIds field is absent or empty. This represents a situation where an offset account exists but details can not be accessed under the current authorisation
	OffsetAccountIds *[]string `json:"offsetAccountIds,omitempty"`

	// OriginalLoanAmount Optional original loan value
	OriginalLoanAmount *string `json:"originalLoanAmount,omitempty"`

	// OriginalLoanCurrency If absent assumes AUD
	OriginalLoanCurrency *string `json:"originalLoanCurrency,omitempty"`

	// OriginalStartDate Optional original start date for the loan
	OriginalStartDate *string `json:"originalStartDate,omitempty"`

	// RepaymentFrequency The expected or required repayment frequency. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	RepaymentFrequency *string `json:"repaymentFrequency,omitempty"`

	// RepaymentType Options in place for repayments. If absent defaults to PRINCIPAL_AND_INTEREST
	RepaymentType *BankingLoanAccountV2RepaymentType `json:"repaymentType,omitempty"`
}

// BankingLoanAccountV2RepaymentType Options in place for repayments. If absent defaults to PRINCIPAL_AND_INTEREST
type BankingLoanAccountV2RepaymentType string

// BankingPayeeDetailV2 defines model for BankingPayeeDetailV2.
type BankingPayeeDetailV2 struct {
	Biller *BankingBillerPayee `json:"biller,omitempty"`

	// CreationDate The date the payee was created by the customer
	CreationDate *string `json:"creationDate,omitempty"`

	// Description A description of the payee provided by the customer
	Description   *string                    `json:"description,omitempty"`
	DigitalWallet *BankingDigitalWalletPayee `json:"digitalWallet,omitempty"`
	Domestic      *BankingDomesticPayee      `json:"domestic,omitempty"`
	International *BankingInternationalPayee `json:"international,omitempty"`

	// Nickname The short display name of the payee as provided by the customer. Where a customer has not provided a nickname, a display name derived by the bank for the payee consistent with existing digital banking channels
	Nickname string `json:"nickname"`

	// PayeeId ID of the payee adhering to the rules of ID permanence
	PayeeId string `json:"payeeId"`

	// PayeeUType Type of object included that describes the payee in detail
	PayeeUType BankingPayeeDetailV2PayeeUType `json:"payeeUType"`

	// Type The type of payee.<br/>DOMESTIC means a registered payee for domestic payments including NPP. <br/>INTERNATIONAL means a registered payee for international payments. <br/>BILLER means a registered payee for BPAY. <br/>DIGITAL_WALLET means a registered payee for a bank's digital wallet
	Type BankingPayeeDetailV2Type `json:"type"`
}

// BankingPayeeDetailV2PayeeUType Type of object included that describes the payee in detail
type BankingPayeeDetailV2PayeeUType string

// BankingPayeeDetailV2Type The type of payee.<br/>DOMESTIC means a registered payee for domestic payments including NPP. <br/>INTERNATIONAL means a registered payee for international payments. <br/>BILLER means a registered payee for BPAY. <br/>DIGITAL_WALLET means a registered payee for a bank's digital wallet
type BankingPayeeDetailV2Type string

// BankingPayeeV2 defines model for BankingPayeeV2.
type BankingPayeeV2 struct {
	// CreationDate The date the payee was created by the customer
	CreationDate *string `json:"creationDate,omitempty"`

	// Description A description of the payee provided by the customer
	Description *string `json:"description,omitempty"`

	// Nickname The short display name of the payee as provided by the customer. Where a customer has not provided a nickname, a display name derived by the bank for the payee consistent with existing digital banking channels
	Nickname string `json:"nickname"`

	// PayeeId ID of the payee adhering to the rules of ID permanence
	PayeeId string `json:"payeeId"`

	// Type The type of payee.<br/>DOMESTIC means a registered payee for domestic payments including NPP. <br/>INTERNATIONAL means a registered payee for international payments. <br/>BILLER means a registered payee for BPAY. <br/>DIGITAL_WALLET means a registered payee for a bank's digital wallet
	Type BankingPayeeV2Type `json:"type"`
}

// BankingPayeeV2Type The type of payee.<br/>DOMESTIC means a registered payee for domestic payments including NPP. <br/>INTERNATIONAL means a registered payee for international payments. <br/>BILLER means a registered payee for BPAY. <br/>DIGITAL_WALLET means a registered payee for a bank's digital wallet
type BankingPayeeV2Type string

// BankingProductAdditionalInformationV2 Object that contains links to additional information on specific topics
type BankingProductAdditionalInformationV2 struct {
	// AdditionalBundleUris An array of additional bundles for the product, if applicable. To be treated as secondary documents to the `bundleUri`. Only to be used if there is a primary `bundleUri`.
	AdditionalBundleUris *[]BankingProductAdditionalInformationV2AdditionalInformationUris `json:"additionalBundleUris,omitempty"`

	// AdditionalEligibilityUris An array of additional eligibility rules and criteria for the product, if applicable. To be treated as secondary documents to the `eligibilityUri`. Only to be used if there is a primary `eligibilityUri`.
	AdditionalEligibilityUris *[]BankingProductAdditionalInformationV2AdditionalInformationUris `json:"additionalEligibilityUris,omitempty"`

	// AdditionalFeesAndPricingUris An array of additional fees, pricing, discounts, exemptions and bonuses for the product, if applicable. To be treated as secondary documents to the `feesAndPricingUri`. Only to be used if there is a primary `feesAndPricingUri`.
	AdditionalFeesAndPricingUris *[]BankingProductAdditionalInformationV2AdditionalInformationUris `json:"additionalFeesAndPricingUris,omitempty"`

	// AdditionalOverviewUris An array of additional general overviews for the product or features of the product, if applicable. To be treated as secondary documents to the `overviewUri`. Only to be used if there is a primary `overviewUri`.
	AdditionalOverviewUris *[]BankingProductAdditionalInformationV2AdditionalInformationUris `json:"additionalOverviewUris,omitempty"`

	// AdditionalTermsUris An array of additional terms and conditions for the product, if applicable. To be treated as secondary documents to the `termsUri`. Only to be used if there is a primary `termsUri`.
	AdditionalTermsUris *[]BankingProductAdditionalInformationV2AdditionalInformationUris `json:"additionalTermsUris,omitempty"`

	// BundleUri Description of a bundle that this product can be part of. Mandatory if `additionalBundleUris` includes one or more supporting documents.
	BundleUri *string `json:"bundleUri,omitempty"`

	// EligibilityUri Eligibility rules and criteria for the product. Mandatory if `additionalEligibilityUris` includes one or more supporting documents.
	EligibilityUri *string `json:"eligibilityUri,omitempty"`

	// FeesAndPricingUri Description of fees, pricing, discounts, exemptions and bonuses for the product. Mandatory if `additionalFeesAndPricingUris` includes one or more supporting documents.
	FeesAndPricingUri *string `json:"feesAndPricingUri,omitempty"`

	// OverviewUri General overview of the product. Mandatory if `additionalOverviewUris` includes one or more supporting documents.
	OverviewUri *string `json:"overviewUri,omitempty"`

	// TermsUri Terms and conditions for the product. Mandatory if `additionalTermsUris` includes one or more supporting documents.
	TermsUri *string `json:"termsUri,omitempty"`
}

// BankingProductAdditionalInformationV2AdditionalInformationUris defines model for BankingProductAdditionalInformationV2_additionalInformationUris.
type BankingProductAdditionalInformationV2AdditionalInformationUris struct {
	// AdditionalInfoUri The URI describing the additional information
	AdditionalInfoUri string `json:"additionalInfoUri"`

	// Description Display text providing more information about the document URI
	Description *string `json:"description,omitempty"`
}

// BankingProductBundle defines model for BankingProductBundle.
type BankingProductBundle struct {
	// AdditionalInfo Display text providing more information on the bundle
	AdditionalInfo *string `json:"additionalInfo,omitempty"`

	// AdditionalInfoUri Link to a web page with more information on the bundle criteria and benefits
	AdditionalInfoUri *string `json:"additionalInfoUri,omitempty"`

	// Description Description of the bundle
	Description string `json:"description"`

	// Name Name of the bundle
	Name string `json:"name"`

	// ProductIds Array of product IDs for products included in the bundle that are available via the product end points.  Note that this array is not intended to represent a comprehensive model of the products included in the bundle and some products available for the bundle may not be available via the product reference end points
	ProductIds *[]string `json:"productIds,omitempty"`
}

// BankingProductCategory The category to which a product or account belongs. See [here](#product-categories) for more details
type BankingProductCategory string

// BankingProductConstraint defines model for BankingProductConstraint.
type BankingProductConstraint struct {
	// AdditionalInfo Display text providing more information the constraint
	AdditionalInfo *string `json:"additionalInfo,omitempty"`

	// AdditionalInfoUri Link to a web page with more information on the constraint
	AdditionalInfoUri *string `json:"additionalInfoUri,omitempty"`

	// AdditionalValue Generic field containing additional information relevant to the [constraintType](#tocSproductconstrainttypedoc) specified.  Whether mandatory or not is dependent on the value of [constraintType](#tocSproductconstrainttypedoc)
	AdditionalValue *string `json:"additionalValue,omitempty"`

	// ConstraintType The type of constraint described.  See the next section for an overview of valid values and their meaning
	ConstraintType BankingProductConstraintConstraintType `json:"constraintType"`
}

// BankingProductConstraintConstraintType The type of constraint described.  See the next section for an overview of valid values and their meaning
type BankingProductConstraintConstraintType string

// BankingProductDepositRate defines model for BankingProductDepositRate.
type BankingProductDepositRate struct {
	// AdditionalInfo Display text providing more information on the rate
	AdditionalInfo *string `json:"additionalInfo,omitempty"`

	// AdditionalInfoUri Link to a web page with more information on this rate
	AdditionalInfoUri *string `json:"additionalInfoUri,omitempty"`

	// AdditionalValue Generic field containing additional information relevant to the [depositRateType](#tocSproductdepositratetypedoc) specified. Whether mandatory or not is dependent on the value of [depositRateType](#tocSproductdepositratetypedoc)
	AdditionalValue *string `json:"additionalValue,omitempty"`

	// ApplicationFrequency The period after which the calculated amount(s) (see calculationFrequency) are 'applied' (i.e. debited or credited) to the account. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	ApplicationFrequency *string `json:"applicationFrequency,omitempty"`

	// CalculationFrequency The period after which the rate is applied to the balance to calculate the amount due for the period. Calculation of the amount is often daily (as balances may change) but accumulated until the total amount is 'applied' to the account (see applicationFrequency). Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	CalculationFrequency *string `json:"calculationFrequency,omitempty"`

	// DepositRateType The type of rate (base, bonus, etc). See the next section for an overview of valid values and their meaning
	DepositRateType BankingProductDepositRateDepositRateType `json:"depositRateType"`

	// Rate The rate to be applied
	Rate string `json:"rate"`

	// Tiers Rate tiers applicable for this rate
	Tiers *[]BankingProductRateTierV3 `json:"tiers,omitempty"`
}

// BankingProductDepositRateDepositRateType The type of rate (base, bonus, etc). See the next section for an overview of valid values and their meaning
type BankingProductDepositRateDepositRateType string

// BankingProductDetailV4 defines model for BankingProductDetailV4.
type BankingProductDetailV4 struct {
	// AdditionalInformation Object that contains links to additional information on specific topics
	AdditionalInformation *BankingProductAdditionalInformationV2 `json:"additionalInformation,omitempty"`

	// ApplicationUri A link to an application web page where this product can be applied for.
	ApplicationUri *string `json:"applicationUri,omitempty"`

	// Brand A label of the brand for the product. Able to be used for filtering. For data holders with single brands this value is still required
	Brand string `json:"brand"`

	// BrandName An optional display name of the brand
	BrandName *string `json:"brandName,omitempty"`

	// Bundles An array of bundles that this product participates in.  Each bundle is described by free form information but also by a list of product IDs of the other products that are included in the bundle.  It is assumed that the current product is included in the bundle also
	Bundles *[]BankingProductBundle `json:"bundles,omitempty"`

	// CardArt An array of card art images
	CardArt *[]struct {
		// ImageUri URI reference to a PNG, JPG or GIF image with proportions defined by ISO 7810 ID-1 and width no greater than 512 pixels. The URI reference may be a link or url-encoded data URI according to **[[RFC2397]](#nref-RFC2397)**
		ImageUri string `json:"imageUri"`

		// Title Display label for the specific image
		Title *string `json:"title,omitempty"`
	} `json:"cardArt,omitempty"`

	// Constraints Constraints on the application for or operation of the product such as minimum balances or limit thresholds
	Constraints *[]BankingProductConstraint `json:"constraints,omitempty"`

	// DepositRates Interest rates available for deposits
	DepositRates *[]BankingProductDepositRate `json:"depositRates,omitempty"`

	// Description A description of the product
	Description string `json:"description"`

	// EffectiveFrom The date and time from which this product is effective (ie. is available for origination).  Used to enable the articulation of products to the regime before they are available for customers to originate
	EffectiveFrom *string `json:"effectiveFrom,omitempty"`

	// EffectiveTo The date and time at which this product will be retired and will no longer be offered.  Used to enable the managed deprecation of products
	EffectiveTo *string `json:"effectiveTo,omitempty"`

	// Eligibility Eligibility criteria for the product
	Eligibility *[]BankingProductEligibility `json:"eligibility,omitempty"`

	// Features Array of features available for the product
	Features *[]BankingProductFeatureV2 `json:"features,omitempty"`

	// Fees Fees applicable for the product
	Fees *[]BankingProductFee `json:"fees,omitempty"`

	// IsTailored Indicates whether the product is specifically tailored to a circumstance.  In this case fees and prices are significantly negotiated depending on context. While all products are open to a degree of tailoring this flag indicates that tailoring is expected and thus that the provision of specific fees and rates is not applicable
	IsTailored bool `json:"isTailored"`

	// LastUpdated The last date and time that the information for this product was changed (or the creation date for the product if it has never been altered)
	LastUpdated string `json:"lastUpdated"`

	// LendingRates Interest rates charged against lending balances
	LendingRates *[]BankingProductLendingRateV2 `json:"lendingRates,omitempty"`

	// Name The display name of the product
	Name string `json:"name"`

	// ProductCategory The category to which a product or account belongs. See [here](#product-categories) for more details
	ProductCategory BankingProductCategory `json:"productCategory"`

	// ProductId A data holder specific unique identifier for this product. This identifier must be unique to a product but does not otherwise need to adhere to ID permanence guidelines.
	ProductId string `json:"productId"`
}

// BankingProductDiscount defines model for BankingProductDiscount.
type BankingProductDiscount struct {
	// AccruedRate A discount rate calculated based on a proportion of the calculated interest accrued on the account. Note that the currency of the fee discount is expected to be the same as the currency of the fee itself. One of amount, balanceRate, transactionRate, accruedRate and feeRate is mandatory. Unless noted in additionalInfo, assumes the application and calculation frequency are the same as the corresponding fee
	AccruedRate *string `json:"accruedRate,omitempty"`

	// AdditionalInfo Display text providing more information on the discount
	AdditionalInfo *string `json:"additionalInfo,omitempty"`

	// AdditionalInfoUri Link to a web page with more information on this discount
	AdditionalInfoUri *string `json:"additionalInfoUri,omitempty"`

	// AdditionalValue Generic field containing additional information relevant to the [discountType](#tocSproductdiscounttypedoc) specified. Whether mandatory or not is dependent on the value of [discountType](#tocSproductdiscounttypedoc)
	AdditionalValue *string `json:"additionalValue,omitempty"`

	// Amount Dollar value of the discount. One of amount, balanceRate, transactionRate, accruedRate and feeRate is mandatory.
	Amount *string `json:"amount,omitempty"`

	// BalanceRate A discount rate calculated based on a proportion of the balance. Note that the currency of the fee discount is expected to be the same as the currency of the fee itself. One of amount, balanceRate, transactionRate, accruedRate and feeRate is mandatory. Unless noted in additionalInfo, assumes the application and calculation frequency are the same as the corresponding fee
	BalanceRate *string `json:"balanceRate,omitempty"`

	// Description Description of the discount
	Description string `json:"description"`

	// DiscountType The type of discount. See the next section for an overview of valid values and their meaning
	DiscountType BankingProductDiscountDiscountType `json:"discountType"`

	// Eligibility Eligibility constraints that apply to this discount. Mandatory if ``discountType`` is ``ELIGIBILITY_ONLY``.
	Eligibility *[]BankingProductDiscountEligibility `json:"eligibility,omitempty"`

	// FeeRate A discount rate calculated based on a proportion of the fee to which this discount is attached. Note that the currency of the fee discount is expected to be the same as the currency of the fee itself. One of amount, balanceRate, transactionRate, accruedRate and feeRate is mandatory. Unless noted in additionalInfo, assumes the application and calculation frequency are the same as the corresponding fee
	FeeRate *string `json:"feeRate,omitempty"`

	// TransactionRate A discount rate calculated based on a proportion of a transaction. Note that the currency of the fee discount is expected to be the same as the currency of the fee itself. One of amount, balanceRate, transactionRate, accruedRate and feeRate is mandatory
	TransactionRate *string `json:"transactionRate,omitempty"`
}

// BankingProductDiscountDiscountType The type of discount. See the next section for an overview of valid values and their meaning
type BankingProductDiscountDiscountType string

// BankingProductDiscountEligibility defines model for BankingProductDiscountEligibility.
type BankingProductDiscountEligibility struct {
	// AdditionalInfo Display text providing more information on this eligibility constraint. Whether mandatory or not is dependent on the value of [discountEligibilityType](#tocSproductdiscounteligibilitydoc)
	AdditionalInfo *string `json:"additionalInfo,omitempty"`

	// AdditionalInfoUri Link to a web page with more information on this eligibility constraint
	AdditionalInfoUri *string `json:"additionalInfoUri,omitempty"`

	// AdditionalValue Generic field containing additional information relevant to the [discountEligibilityType](#tocSproductdiscounteligibilitydoc) specified. Whether mandatory or not is dependent on the value of [discountEligibilityType](#tocSproductdiscounteligibilitydoc)
	AdditionalValue *string `json:"additionalValue,omitempty"`

	// DiscountEligibilityType The type of the specific eligibility constraint for a discount
	DiscountEligibilityType BankingProductDiscountEligibilityDiscountEligibilityType `json:"discountEligibilityType"`
}

// BankingProductDiscountEligibilityDiscountEligibilityType The type of the specific eligibility constraint for a discount
type BankingProductDiscountEligibilityDiscountEligibilityType string

// BankingProductEligibility defines model for BankingProductEligibility.
type BankingProductEligibility struct {
	// AdditionalInfo Display text providing more information on the [eligibility](#tocSproducteligibilitytypedoc) criteria. Mandatory if the field is set to OTHER
	AdditionalInfo *string `json:"additionalInfo,omitempty"`

	// AdditionalInfoUri Link to a web page with more information on this eligibility criteria
	AdditionalInfoUri *string `json:"additionalInfoUri,omitempty"`

	// AdditionalValue Generic field containing additional information relevant to the [eligibilityType](#tocSproducteligibilitytypedoc) specified. Whether mandatory or not is dependent on the value of [eligibilityType](#tocSproducteligibilitytypedoc)
	AdditionalValue *string `json:"additionalValue,omitempty"`

	// EligibilityType The type of eligibility criteria described.  See the next section for an overview of valid values and their meaning
	EligibilityType BankingProductEligibilityEligibilityType `json:"eligibilityType"`
}

// BankingProductEligibilityEligibilityType The type of eligibility criteria described.  See the next section for an overview of valid values and their meaning
type BankingProductEligibilityEligibilityType string

// BankingProductFeatureV2 defines model for BankingProductFeatureV2.
type BankingProductFeatureV2 struct {
	// AdditionalInfo Display text providing more information on the feature. Mandatory if the [feature type](#tocSproductfeaturetypedoc) is set to OTHER
	AdditionalInfo *string `json:"additionalInfo,omitempty"`

	// AdditionalInfoUri Link to a web page with more information on this feature
	AdditionalInfoUri *string `json:"additionalInfoUri,omitempty"`

	// AdditionalValue Generic field containing additional information relevant to the [featureType](#tocSproductfeaturetypedoc) specified. Whether mandatory or not is dependent on the value of the [featureType.](#tocSproductfeaturetypedoc)
	AdditionalValue *string `json:"additionalValue,omitempty"`

	// FeatureType The type of feature described
	FeatureType BankingProductFeatureV2FeatureType `json:"featureType"`
}

// BankingProductFeatureV2FeatureType The type of feature described
type BankingProductFeatureV2FeatureType string

// BankingProductFee defines model for BankingProductFee.
type BankingProductFee struct {
	// AccrualFrequency The indicative frequency with which the fee is calculated on the account. Only applies if balanceRate or accruedRate is also present. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	AccrualFrequency *string `json:"accrualFrequency,omitempty"`

	// AccruedRate A fee rate calculated based on a proportion of the calculated interest accrued on the account. One of amount, balanceRate, transactionRate and accruedRate is mandatory unless the *feeType* "VARIABLE" is supplied
	AccruedRate *string `json:"accruedRate,omitempty"`

	// AdditionalInfo Display text providing more information on the fee
	AdditionalInfo *string `json:"additionalInfo,omitempty"`

	// AdditionalInfoUri Link to a web page with more information on this fee
	AdditionalInfoUri *string `json:"additionalInfoUri,omitempty"`

	// AdditionalValue Generic field containing additional information relevant to the [feeType](#tocSproductfeetypedoc) specified. Whether mandatory or not is dependent on the value of [feeType](#tocSproductfeetypedoc)
	AdditionalValue *string `json:"additionalValue,omitempty"`

	// Amount The amount charged for the fee. One of amount, balanceRate, transactionRate and accruedRate is mandatory unless the *feeType* "VARIABLE" is supplied
	Amount *string `json:"amount,omitempty"`

	// BalanceRate A fee rate calculated based on a proportion of the balance. One of amount, balanceRate, transactionRate and accruedRate is mandatory unless the *feeType* "VARIABLE" is supplied.
	BalanceRate *string `json:"balanceRate,omitempty"`

	// Currency The currency the fee will be charged in. Assumes AUD if absent
	Currency *string `json:"currency,omitempty"`

	// Discounts An optional list of discounts to this fee that may be available
	Discounts *[]BankingProductDiscount `json:"discounts,omitempty"`

	// FeeType The type of fee
	FeeType BankingProductFeeFeeType `json:"feeType"`

	// Name Name of the fee
	Name string `json:"name"`

	// TransactionRate A fee rate calculated based on a proportion of a transaction. One of amount, balanceRate, transactionRate and accruedRate is mandatory unless the *feeType* "VARIABLE" is supplied
	TransactionRate *string `json:"transactionRate,omitempty"`
}

// BankingProductFeeFeeType The type of fee
type BankingProductFeeFeeType string

// BankingProductLendingRateV2 defines model for BankingProductLendingRateV2.
type BankingProductLendingRateV2 struct {
	// AdditionalInfo Display text providing more information on the rate.
	AdditionalInfo *string `json:"additionalInfo,omitempty"`

	// AdditionalInfoUri Link to a web page with more information on this rate
	AdditionalInfoUri *string `json:"additionalInfoUri,omitempty"`

	// AdditionalValue Generic field containing additional information relevant to the [lendingRateType](#tocSproductlendingratetypedoc) specified. Whether mandatory or not is dependent on the value of [lendingRateType](#tocSproductlendingratetypedoc)
	AdditionalValue *string `json:"additionalValue,omitempty"`

	// ApplicationFrequency The period after which the calculated amount(s) (see calculationFrequency) are 'applied' (i.e. debited or credited) to the account. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	ApplicationFrequency *string `json:"applicationFrequency,omitempty"`

	// CalculationFrequency The period after which the rate is applied to the balance to calculate the amount due for the period. Calculation of the amount is often daily (as balances may change) but accumulated until the total amount is 'applied' to the account (see applicationFrequency). Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	CalculationFrequency *string `json:"calculationFrequency,omitempty"`

	// ComparisonRate A comparison rate equivalent for this rate
	ComparisonRate *string `json:"comparisonRate,omitempty"`

	// InterestPaymentDue When loan payments are due to be paid within each period. The investment benefit of earlier payments affect the rate that can be offered
	InterestPaymentDue *BankingProductLendingRateV2InterestPaymentDue `json:"interestPaymentDue,omitempty"`

	// LendingRateType The type of rate (fixed, variable, etc). See the next section for an overview of valid values and their meaning
	LendingRateType BankingProductLendingRateV2LendingRateType `json:"lendingRateType"`

	// LoanPurpose The reason for taking out the loan. If absent, the lending rate is applicable to all loan purposes
	LoanPurpose *BankingProductLendingRateV2LoanPurpose `json:"loanPurpose,omitempty"`

	// Rate The rate to be applied
	Rate string `json:"rate"`

	// RepaymentType Options in place for repayments. If absent, the lending rate is applicable to all repayment types
	RepaymentType *BankingProductLendingRateV2RepaymentType `json:"repaymentType,omitempty"`

	// Tiers Rate tiers applicable for this rate
	Tiers *[]BankingProductRateTierV3 `json:"tiers,omitempty"`
}

// BankingProductLendingRateV2InterestPaymentDue When loan payments are due to be paid within each period. The investment benefit of earlier payments affect the rate that can be offered
type BankingProductLendingRateV2InterestPaymentDue string

// BankingProductLendingRateV2LendingRateType The type of rate (fixed, variable, etc). See the next section for an overview of valid values and their meaning
type BankingProductLendingRateV2LendingRateType string

// BankingProductLendingRateV2LoanPurpose The reason for taking out the loan. If absent, the lending rate is applicable to all loan purposes
type BankingProductLendingRateV2LoanPurpose string

// BankingProductLendingRateV2RepaymentType Options in place for repayments. If absent, the lending rate is applicable to all repayment types
type BankingProductLendingRateV2RepaymentType string

// BankingProductRateCondition Defines a condition for the applicability of a tiered rate
type BankingProductRateCondition struct {
	// AdditionalInfo Display text providing more information on the condition
	AdditionalInfo *string `json:"additionalInfo,omitempty"`

	// AdditionalInfoUri Link to a web page with more information on this condition
	AdditionalInfoUri *string `json:"additionalInfoUri,omitempty"`
}

// BankingProductRateTierV3 Defines the criteria and conditions for which a rate applies
type BankingProductRateTierV3 struct {
	// AdditionalInfo Display text providing more information on the rate tier.
	AdditionalInfo *string `json:"additionalInfo,omitempty"`

	// AdditionalInfoUri Link to a web page with more information on this rate tier
	AdditionalInfoUri *string `json:"additionalInfoUri,omitempty"`

	// ApplicabilityConditions Defines a condition for the applicability of a tiered rate
	ApplicabilityConditions *BankingProductRateCondition `json:"applicabilityConditions,omitempty"`

	// MaximumValue The number of tierUnitOfMeasure units that form the upper bound of the tier or band. For a tier with a discrete value (as opposed to a range of values e.g. 1 month) this must be the same as tierValueMinimum. Where this is the same as the tierValueMinimum value of the next-higher tier the referenced tier should be exclusive of this value. For example a term deposit of 2 months falls into the upper tier of the following tiers: (1  2 months, 2  3 months). If absent the tier's range has no upper bound.
	MaximumValue *float32 `json:"maximumValue,omitempty"`

	// MinimumValue The number of tierUnitOfMeasure units that form the lower bound of the tier. The tier should be inclusive of this value
	MinimumValue float32 `json:"minimumValue"`

	// Name A display name for the tier
	Name string `json:"name"`

	// RateApplicationMethod The method used to calculate the amount to be applied using one or more tiers. A single rate may be applied to the entire balance or each applicable tier rate is applied to the portion of the balance that falls into that tier (referred to as 'bands' or 'steps')
	RateApplicationMethod *BankingProductRateTierV3RateApplicationMethod `json:"rateApplicationMethod,omitempty"`

	// UnitOfMeasure The unit of measure that applies to the tierValueMinimum and tierValueMaximum values e.g. a **DOLLAR** amount. **PERCENT** (in the case of loan-to-value ratio or LVR). Tier term period representing a discrete number of **MONTH**'s or **DAY**'s (in the case of term deposit tiers)
	UnitOfMeasure BankingProductRateTierV3UnitOfMeasure `json:"unitOfMeasure"`
}

// BankingProductRateTierV3RateApplicationMethod The method used to calculate the amount to be applied using one or more tiers. A single rate may be applied to the entire balance or each applicable tier rate is applied to the portion of the balance that falls into that tier (referred to as 'bands' or 'steps')
type BankingProductRateTierV3RateApplicationMethod string

// BankingProductRateTierV3UnitOfMeasure The unit of measure that applies to the tierValueMinimum and tierValueMaximum values e.g. a **DOLLAR** amount. **PERCENT** (in the case of loan-to-value ratio or LVR). Tier term period representing a discrete number of **MONTH**'s or **DAY**'s (in the case of term deposit tiers)
type BankingProductRateTierV3UnitOfMeasure string

// BankingProductV4 defines model for BankingProductV4.
type BankingProductV4 struct {
	// AdditionalInformation Object that contains links to additional information on specific topics
	AdditionalInformation *BankingProductAdditionalInformationV2 `json:"additionalInformation,omitempty"`

	// ApplicationUri A link to an application web page where this product can be applied for.
	ApplicationUri *string `json:"applicationUri,omitempty"`

	// Brand A label of the brand for the product. Able to be used for filtering. For data holders with single brands this value is still required
	Brand string `json:"brand"`

	// BrandName An optional display name of the brand
	BrandName *string `json:"brandName,omitempty"`

	// CardArt An array of card art images
	CardArt *[]struct {
		// ImageUri URI reference to a PNG, JPG or GIF image with proportions defined by ISO 7810 ID-1 and width no greater than 512 pixels. The URI reference may be a link or url-encoded data URI according to **[[RFC2397]](#nref-RFC2397)**
		ImageUri string `json:"imageUri"`

		// Title Display label for the specific image
		Title *string `json:"title,omitempty"`
	} `json:"cardArt,omitempty"`

	// Description A description of the product
	Description string `json:"description"`

	// EffectiveFrom The date and time from which this product is effective (ie. is available for origination).  Used to enable the articulation of products to the regime before they are available for customers to originate
	EffectiveFrom *string `json:"effectiveFrom,omitempty"`

	// EffectiveTo The date and time at which this product will be retired and will no longer be offered.  Used to enable the managed deprecation of products
	EffectiveTo *string `json:"effectiveTo,omitempty"`

	// IsTailored Indicates whether the product is specifically tailored to a circumstance.  In this case fees and prices are significantly negotiated depending on context. While all products are open to a degree of tailoring this flag indicates that tailoring is expected and thus that the provision of specific fees and rates is not applicable
	IsTailored bool `json:"isTailored"`

	// LastUpdated The last date and time that the information for this product was changed (or the creation date for the product if it has never been altered)
	LastUpdated string `json:"lastUpdated"`

	// Name The display name of the product
	Name string `json:"name"`

	// ProductCategory The category to which a product or account belongs. See [here](#product-categories) for more details
	ProductCategory BankingProductCategory `json:"productCategory"`

	// ProductId A data holder specific unique identifier for this product. This identifier must be unique to a product but does not otherwise need to adhere to ID permanence guidelines.
	ProductId string `json:"productId"`
}

// BankingScheduledPayment defines model for BankingScheduledPayment.
type BankingScheduledPayment struct {
	// From Object containing details of the source of the payment. Currently only specifies an account ID but provided as an object to facilitate future extensibility and consistency with the to object
	From BankingScheduledPaymentFrom `json:"from"`

	// Nickname The short display name of the scheduled payment as provided by the customer if provided. Where a customer has not provided a nickname, a display name derived by the bank for the scheduled payment should be provided that is consistent with existing digital banking channels
	Nickname *string `json:"nickname,omitempty"`

	// PayeeReference The reference for the transaction, if applicable, that will be provided by the originating institution for all payments in the payment set. Empty string if no data provided
	PayeeReference *string `json:"payeeReference,omitempty"`

	// PayerReference The reference for the transaction that will be used by the originating institution for the purposes of constructing a statement narrative on the payers account. Empty string if no data provided
	PayerReference string                       `json:"payerReference"`
	PaymentSet     []BankingScheduledPaymentSet `json:"paymentSet"`

	// Recurrence Object containing the detail of the schedule for the payment
	Recurrence BankingScheduledPaymentRecurrence `json:"recurrence"`

	// ScheduledPaymentId A unique ID of the scheduled payment adhering to the standards for ID permanence
	ScheduledPaymentId string `json:"scheduledPaymentId"`

	// Status Indicates whether the schedule is currently active. The value SKIP is equivalent to ACTIVE except that the customer has requested the next normal occurrence to be skipped.
	Status BankingScheduledPaymentStatus `json:"status"`
}

// BankingScheduledPaymentStatus Indicates whether the schedule is currently active. The value SKIP is equivalent to ACTIVE except that the customer has requested the next normal occurrence to be skipped.
type BankingScheduledPaymentStatus string

// BankingScheduledPaymentFrom Object containing details of the source of the payment. Currently only specifies an account ID but provided as an object to facilitate future extensibility and consistency with the to object
type BankingScheduledPaymentFrom struct {
	// AccountId ID of the account that is the source of funds for the payment
	AccountId string `json:"accountId"`
}

// BankingScheduledPaymentInterval defines model for BankingScheduledPaymentInterval.
type BankingScheduledPaymentInterval struct {
	// DayInInterval Uses an interval to define the ordinal day within the interval defined by the interval field on which the payment occurs. If the resulting duration is 0 days in length or larger than the number of days in the interval then the payment will occur on the last day of the interval. A duration of 1 day indicates the first day of the interval. If absent the assumed value is P1D. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax) with components less than a day in length ignored. The first day of a week is considered to be Monday.
	DayInInterval *string `json:"dayInInterval,omitempty"`

	// Interval An interval for the payment. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations)  (excludes recurrence syntax) with components less than a day in length ignored. This duration defines the period between payments starting with nextPaymentDate
	Interval string `json:"interval"`
}

// BankingScheduledPaymentRecurrence Object containing the detail of the schedule for the payment
type BankingScheduledPaymentRecurrence struct {
	// EventBased Indicates that the schedule of payments is defined according to an external event that cannot be predetermined. Mandatory if recurrenceUType is set to eventBased
	EventBased *BankingScheduledPaymentRecurrenceEventBased `json:"eventBased,omitempty"`

	// IntervalSchedule Indicates that the schedule of payments is defined by a series of intervals. Mandatory if recurrenceUType is set to intervalSchedule
	IntervalSchedule *BankingScheduledPaymentRecurrenceIntervalSchedule `json:"intervalSchedule,omitempty"`

	// LastWeekDay Indicates that the schedule of payments is defined according to the last occurrence of a specific weekday in an interval. Mandatory if recurrenceUType is set to lastWeekDay
	LastWeekDay *BankingScheduledPaymentRecurrenceLastWeekday `json:"lastWeekDay,omitempty"`

	// NextPaymentDate The date of the next payment under the recurrence schedule
	NextPaymentDate *string `json:"nextPaymentDate,omitempty"`

	// OnceOff Indicates that the payment is a once off payment on a specific future date. Mandatory if recurrenceUType is set to onceOff
	OnceOff *BankingScheduledPaymentRecurrenceOnceOff `json:"onceOff,omitempty"`

	// RecurrenceUType The type of recurrence used to define the schedule
	RecurrenceUType BankingScheduledPaymentRecurrenceRecurrenceUType `json:"recurrenceUType"`
}

// BankingScheduledPaymentRecurrenceRecurrenceUType The type of recurrence used to define the schedule
type BankingScheduledPaymentRecurrenceRecurrenceUType string

// BankingScheduledPaymentRecurrenceEventBased Indicates that the schedule of payments is defined according to an external event that cannot be predetermined. Mandatory if recurrenceUType is set to eventBased
type BankingScheduledPaymentRecurrenceEventBased struct {
	// Description Description of the event and conditions that will result in the payment. Expected to be formatted for display to a customer
	Description string `json:"description"`
}

// BankingScheduledPaymentRecurrenceIntervalSchedule Indicates that the schedule of payments is defined by a series of intervals. Mandatory if recurrenceUType is set to intervalSchedule
type BankingScheduledPaymentRecurrenceIntervalSchedule struct {
	// FinalPaymentDate The limit date after which no more payments should be made using this schedule. If both finalPaymentDate and paymentsRemaining are present then payments will stop according to the most constraining value. If neither field is present the payments will continue indefinitely
	FinalPaymentDate *string `json:"finalPaymentDate,omitempty"`

	// Intervals An array of interval objects defining the payment schedule.  Each entry in the array is additive, in that it adds payments to the overall payment schedule.  If multiple intervals result in a payment on the same day then only one payment will be made. Must have at least one entry
	Intervals []BankingScheduledPaymentInterval `json:"intervals"`

	// NonBusinessDayTreatment Enumerated field giving the treatment where a scheduled payment date is not a business day. If absent assumed to be ON.<br/>**AFTER** - If a scheduled payment date is a non-business day the payment will be made on the first business day after the scheduled payment date.<br/>**BEFORE** - If a scheduled payment date is a non-business day the payment will be made on the first business day before the scheduled payment date.<br/>**ON** - If a scheduled payment date is a non-business day the payment will be made on that day regardless.<br/>**ONLY** - Payments only occur on business days. If a scheduled payment date is a non-business day the payment will be ignored
	NonBusinessDayTreatment *BankingScheduledPaymentRecurrenceIntervalScheduleNonBusinessDayTreatment `json:"nonBusinessDayTreatment,omitempty"`

	// PaymentsRemaining Indicates the number of payments remaining in the schedule. If both finalPaymentDate and paymentsRemaining are present then payments will stop according to the most constraining value, If neither field is present the payments will continue indefinitely
	PaymentsRemaining *int `json:"paymentsRemaining,omitempty"`
}

// BankingScheduledPaymentRecurrenceIntervalScheduleNonBusinessDayTreatment Enumerated field giving the treatment where a scheduled payment date is not a business day. If absent assumed to be ON.<br/>**AFTER** - If a scheduled payment date is a non-business day the payment will be made on the first business day after the scheduled payment date.<br/>**BEFORE** - If a scheduled payment date is a non-business day the payment will be made on the first business day before the scheduled payment date.<br/>**ON** - If a scheduled payment date is a non-business day the payment will be made on that day regardless.<br/>**ONLY** - Payments only occur on business days. If a scheduled payment date is a non-business day the payment will be ignored
type BankingScheduledPaymentRecurrenceIntervalScheduleNonBusinessDayTreatment string

// BankingScheduledPaymentRecurrenceLastWeekday Indicates that the schedule of payments is defined according to the last occurrence of a specific weekday in an interval. Mandatory if recurrenceUType is set to lastWeekDay
type BankingScheduledPaymentRecurrenceLastWeekday struct {
	// FinalPaymentDate The limit date after which no more payments should be made using this schedule. If both finalPaymentDate and paymentsRemaining are present then payments will stop according to the most constraining value. If neither field is present the payments will continue indefinitely
	FinalPaymentDate *string `json:"finalPaymentDate,omitempty"`

	// Interval The interval for the payment. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax) with components less than a day in length ignored. This duration defines the period between payments starting with nextPaymentDate
	Interval string `json:"interval"`

	// LastWeekDay The weekDay specified. The payment will occur on the last occurrence of this weekday in the interval.
	LastWeekDay BankingScheduledPaymentRecurrenceLastWeekdayLastWeekDay `json:"lastWeekDay"`

	// NonBusinessDayTreatment Enumerated field giving the treatment where a scheduled payment date is not a business day. If absent assumed to be ON.<br/>**AFTER** - If a scheduled payment date is a non-business day the payment will be made on the first business day after the scheduled payment date.<br/>**BEFORE** - If a scheduled payment date is a non-business day the payment will be made on the first business day before the scheduled payment date.<br/>**ON** - If a scheduled payment date is a non-business day the payment will be made on that day regardless.<br/>**ONLY** - Payments only occur on business days. If a scheduled payment date is a non-business day the payment will be ignored
	NonBusinessDayTreatment *BankingScheduledPaymentRecurrenceLastWeekdayNonBusinessDayTreatment `json:"nonBusinessDayTreatment,omitempty"`

	// PaymentsRemaining Indicates the number of payments remaining in the schedule. If both finalPaymentDate and paymentsRemaining are present then payments will stop according to the most constraining value. If neither field is present the payments will continue indefinitely
	PaymentsRemaining *int `json:"paymentsRemaining,omitempty"`
}

// BankingScheduledPaymentRecurrenceLastWeekdayLastWeekDay The weekDay specified. The payment will occur on the last occurrence of this weekday in the interval.
type BankingScheduledPaymentRecurrenceLastWeekdayLastWeekDay string

// BankingScheduledPaymentRecurrenceLastWeekdayNonBusinessDayTreatment Enumerated field giving the treatment where a scheduled payment date is not a business day. If absent assumed to be ON.<br/>**AFTER** - If a scheduled payment date is a non-business day the payment will be made on the first business day after the scheduled payment date.<br/>**BEFORE** - If a scheduled payment date is a non-business day the payment will be made on the first business day before the scheduled payment date.<br/>**ON** - If a scheduled payment date is a non-business day the payment will be made on that day regardless.<br/>**ONLY** - Payments only occur on business days. If a scheduled payment date is a non-business day the payment will be ignored
type BankingScheduledPaymentRecurrenceLastWeekdayNonBusinessDayTreatment string

// BankingScheduledPaymentRecurrenceOnceOff Indicates that the payment is a once off payment on a specific future date. Mandatory if recurrenceUType is set to onceOff
type BankingScheduledPaymentRecurrenceOnceOff struct {
	// PaymentDate The scheduled date for the once off payment
	PaymentDate string `json:"paymentDate"`
}

// BankingScheduledPaymentSet The set of payment amounts and destination accounts for this payment accommodating multi-part payments. A single entry indicates a simple payment with one destination account. Must have at least one entry
type BankingScheduledPaymentSet struct {
	// Amount The amount of the next payment if known. Mandatory unless the isAmountCalculated field is set to true. Must be zero or positive if present
	Amount *string `json:"amount,omitempty"`

	// Currency The currency for the payment. AUD assumed if not present
	Currency *string `json:"currency,omitempty"`

	// IsAmountCalculated Flag indicating whether the amount of the payment is calculated based on the context of the event. For instance a payment to reduce the balance of a credit card to zero. If absent then false is assumed
	IsAmountCalculated *bool `json:"isAmountCalculated,omitempty"`

	// To Object containing details of the destination of the payment. Used to specify a variety of payment destination types
	To BankingScheduledPaymentTo `json:"to"`
}

// BankingScheduledPaymentTo Object containing details of the destination of the payment. Used to specify a variety of payment destination types
type BankingScheduledPaymentTo struct {
	// AccountId Present if toUType is set to accountId. Indicates that the payment is to another account that is accessible under the current consent
	AccountId     *string                    `json:"accountId,omitempty"`
	Biller        *BankingBillerPayee        `json:"biller,omitempty"`
	Domestic      *BankingDomesticPayee      `json:"domestic,omitempty"`
	International *BankingInternationalPayee `json:"international,omitempty"`

	// Nickname The short display name of the payee as provided by the customer unless toUType is set to payeeId. Where a customer has not provided a nickname, a display name derived by the bank for payee should be provided that is consistent with existing digital banking channels
	Nickname *string `json:"nickname,omitempty"`

	// PayeeId Present if toUType is set to payeeId. Indicates that the payment is to registered payee that can be accessed using the payee end point. If the Bank Payees scope has not been consented to then a payeeId should not be provided and the full payee details should be provided instead
	PayeeId *string `json:"payeeId,omitempty"`

	// PayeeReference The reference for the transaction, if applicable, that will be provided by the originating institution for the specific payment. If not empty, it overrides the value provided at the BankingScheduledPayment level.
	PayeeReference *string `json:"payeeReference,omitempty"`

	// ToUType The type of object provided that specifies the destination of the funds for the payment.
	ToUType BankingScheduledPaymentToToUType `json:"toUType"`
}

// BankingScheduledPaymentToToUType The type of object provided that specifies the destination of the funds for the payment.
type BankingScheduledPaymentToToUType string

// BankingTermDepositAccount defines model for BankingTermDepositAccount.
type BankingTermDepositAccount struct {
	// LodgementDate The lodgement date of the original deposit
	LodgementDate string `json:"lodgementDate"`

	// MaturityAmount Amount to be paid upon maturity. If absent it implies the amount to paid is variable and cannot currently be calculated
	MaturityAmount *string `json:"maturityAmount,omitempty"`

	// MaturityCurrency If absent assumes AUD
	MaturityCurrency *string `json:"maturityCurrency,omitempty"`

	// MaturityDate Maturity date for the term deposit
	MaturityDate string `json:"maturityDate"`

	// MaturityInstructions Current instructions on action to be taken at maturity. This includes default actions that may be specified in the terms and conditions for the product e.g. roll-over to the same term and frequency of interest payments
	MaturityInstructions BankingTermDepositAccountMaturityInstructions `json:"maturityInstructions"`
}

// BankingTermDepositAccountMaturityInstructions Current instructions on action to be taken at maturity. This includes default actions that may be specified in the terms and conditions for the product e.g. roll-over to the same term and frequency of interest payments
type BankingTermDepositAccountMaturityInstructions string

// BankingTransaction defines model for BankingTransaction.
type BankingTransaction struct {
	// AccountId ID of the account for which transactions are provided
	AccountId string `json:"accountId"`

	// Amount The value of the transaction. Negative values mean money was outgoing from the account
	Amount string `json:"amount"`

	// ApcaNumber 6 Digit APCA number for the initiating institution. The field is fixed-width and padded with leading zeros if applicable.
	ApcaNumber *string `json:"apcaNumber,omitempty"`

	// BillerCode BPAY Biller Code for the transaction (if available)
	BillerCode *string `json:"billerCode,omitempty"`

	// BillerName Name of the BPAY biller for the transaction (if available)
	BillerName *string `json:"billerName,omitempty"`

	// Crn BPAY CRN for the transaction (if available).<br/>Where the CRN contains sensitive information, it should be masked in line with how the Data Holder currently displays account identifiers in their existing online banking channels. If the contents of the CRN match the format of a Credit Card PAN they should be masked according to the rules applicable for MaskedPANString. If the contents are are otherwise sensitive, then it should be masked using the rules applicable for the MaskedAccountString common type.
	Crn *string `json:"crn,omitempty"`

	// Currency The currency for the transaction amount. AUD assumed if not present
	Currency *string `json:"currency,omitempty"`

	// Description The transaction description as applied by the financial institution
	Description string `json:"description"`

	// ExecutionDateTime The time the transaction was executed by the originating customer, if available
	ExecutionDateTime *string `json:"executionDateTime,omitempty"`

	// IsDetailAvailable True if extended information is available using the transaction detail end point. False if extended data is not available
	IsDetailAvailable bool `json:"isDetailAvailable"`

	// MerchantCategoryCode The merchant category code (or MCC) for an outgoing payment to a merchant
	MerchantCategoryCode *string `json:"merchantCategoryCode,omitempty"`

	// MerchantName Name of the merchant for an outgoing payment to a merchant
	MerchantName *string `json:"merchantName,omitempty"`

	// PostingDateTime The time the transaction was posted. This field is Mandatory if the transaction has status POSTED.  This is the time that appears on a standard statement
	PostingDateTime *string `json:"postingDateTime,omitempty"`

	// Reference The reference for the transaction provided by the originating institution. Empty string if no data provided
	Reference string `json:"reference"`

	// Status Status of the transaction whether pending or posted. Note that there is currently no provision in the standards to guarantee the ability to correlate a pending transaction with an associated posted transaction
	Status BankingTransactionStatus `json:"status"`

	// TransactionId A unique ID of the transaction adhering to the standards for ID permanence.  This is mandatory (through hashing if necessary) unless there are specific and justifiable technical reasons why a transaction cannot be uniquely identified for a particular account type. It is mandatory if `isDetailAvailable` is set to true.
	TransactionId *string `json:"transactionId,omitempty"`

	// Type The type of the transaction
	Type BankingTransactionType `json:"type"`

	// ValueDateTime Date and time at which assets become available to the account owner in case of a credit entry, or cease to be available to the account owner in case of a debit transaction entry
	ValueDateTime *string `json:"valueDateTime,omitempty"`
}

// BankingTransactionStatus Status of the transaction whether pending or posted. Note that there is currently no provision in the standards to guarantee the ability to correlate a pending transaction with an associated posted transaction
type BankingTransactionStatus string

// BankingTransactionType The type of the transaction
type BankingTransactionType string

// BankingTransactionDetail defines model for BankingTransactionDetail.
type BankingTransactionDetail struct {
	// AccountId ID of the account for which transactions are provided
	AccountId string `json:"accountId"`

	// Amount The value of the transaction. Negative values mean money was outgoing from the account
	Amount string `json:"amount"`

	// ApcaNumber 6 Digit APCA number for the initiating institution. The field is fixed-width and padded with leading zeros if applicable.
	ApcaNumber *string `json:"apcaNumber,omitempty"`

	// BillerCode BPAY Biller Code for the transaction (if available)
	BillerCode *string `json:"billerCode,omitempty"`

	// BillerName Name of the BPAY biller for the transaction (if available)
	BillerName *string `json:"billerName,omitempty"`

	// Crn BPAY CRN for the transaction (if available).<br/>Where the CRN contains sensitive information, it should be masked in line with how the Data Holder currently displays account identifiers in their existing online banking channels. If the contents of the CRN match the format of a Credit Card PAN they should be masked according to the rules applicable for MaskedPANString. If the contents are are otherwise sensitive, then it should be masked using the rules applicable for the MaskedAccountString common type.
	Crn *string `json:"crn,omitempty"`

	// Currency The currency for the transaction amount. AUD assumed if not present
	Currency *string `json:"currency,omitempty"`

	// Description The transaction description as applied by the financial institution
	Description string `json:"description"`

	// ExecutionDateTime The time the transaction was executed by the originating customer, if available
	ExecutionDateTime *string `json:"executionDateTime,omitempty"`
	ExtendedData      struct {
		// ExtensionUType Optional extended data provided specific to transaction originated via NPP
		ExtensionUType *BankingTransactionDetailExtendedDataExtensionUType `json:"extensionUType,omitempty"`

		// Payee Label of the target PayID.  Mandatory for an outbound payment. The name assigned to the BSB/Account Number or PayID (by the owner of the PayID)
		Payee *string `json:"payee,omitempty"`

		// Payer Label of the originating payer. Mandatory for inbound payment
		Payer *string `json:"payer,omitempty"`

		// Service Identifier of the applicable overlay service. Valid values are: X2P1.01
		Service       BankingTransactionDetailExtendedDataService `json:"service"`
		X2p101Payload *struct {
			// EndToEndId An end to end ID for the payment created at initiation
			EndToEndId *string `json:"endToEndId,omitempty"`

			// ExtendedDescription An extended string description. Only present if specified by the extensionUType field
			ExtendedDescription string `json:"extendedDescription"`

			// PurposeCode Purpose of the payment.  Format is defined by NPP standards for the x2p1.01 overlay service
			PurposeCode *string `json:"purposeCode,omitempty"`
		} `json:"x2p101Payload,omitempty"`
	} `json:"extendedData"`

	// IsDetailAvailable True if extended information is available using the transaction detail end point. False if extended data is not available
	IsDetailAvailable bool `json:"isDetailAvailable"`

	// MerchantCategoryCode The merchant category code (or MCC) for an outgoing payment to a merchant
	MerchantCategoryCode *string `json:"merchantCategoryCode,omitempty"`

	// MerchantName Name of the merchant for an outgoing payment to a merchant
	MerchantName *string `json:"merchantName,omitempty"`

	// PostingDateTime The time the transaction was posted. This field is Mandatory if the transaction has status POSTED.  This is the time that appears on a standard statement
	PostingDateTime *string `json:"postingDateTime,omitempty"`

	// Reference The reference for the transaction provided by the originating institution. Empty string if no data provided
	Reference string `json:"reference"`

	// Status Status of the transaction whether pending or posted. Note that there is currently no provision in the standards to guarantee the ability to correlate a pending transaction with an associated posted transaction
	Status BankingTransactionDetailStatus `json:"status"`

	// TransactionId A unique ID of the transaction adhering to the standards for ID permanence.  This is mandatory (through hashing if necessary) unless there are specific and justifiable technical reasons why a transaction cannot be uniquely identified for a particular account type. It is mandatory if `isDetailAvailable` is set to true.
	TransactionId *string `json:"transactionId,omitempty"`

	// Type The type of the transaction
	Type BankingTransactionDetailType `json:"type"`

	// ValueDateTime Date and time at which assets become available to the account owner in case of a credit entry, or cease to be available to the account owner in case of a debit transaction entry
	ValueDateTime *string `json:"valueDateTime,omitempty"`
}

// BankingTransactionDetailExtendedDataExtensionUType Optional extended data provided specific to transaction originated via NPP
type BankingTransactionDetailExtendedDataExtensionUType string

// BankingTransactionDetailExtendedDataService Identifier of the applicable overlay service. Valid values are: X2P1.01
type BankingTransactionDetailExtendedDataService string

// BankingTransactionDetailStatus Status of the transaction whether pending or posted. Note that there is currently no provision in the standards to guarantee the ability to correlate a pending transaction with an associated posted transaction
type BankingTransactionDetailStatus string

// BankingTransactionDetailType The type of the transaction
type BankingTransactionDetailType string

// CommonPAFAddress Australian address formatted according to the file format defined by the [PAF file format](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf)
type CommonPAFAddress struct {
	// BuildingName1 Building/Property name 1
	BuildingName1 *string `json:"buildingName1,omitempty"`

	// BuildingName2 Building/Property name 2
	BuildingName2 *string `json:"buildingName2,omitempty"`

	// Dpid Unique identifier for an address as defined by Australia Post.  Also known as Delivery Point Identifier
	Dpid *string `json:"dpid,omitempty"`

	// FlatUnitNumber Unit number (including suffix, if applicable)
	FlatUnitNumber *string `json:"flatUnitNumber,omitempty"`

	// FlatUnitType Type of flat or unit for the address
	FlatUnitType *string `json:"flatUnitType,omitempty"`

	// FloorLevelNumber Floor or level number (including alpha characters)
	FloorLevelNumber *string `json:"floorLevelNumber,omitempty"`

	// FloorLevelType Type of floor or level for the address
	FloorLevelType *string `json:"floorLevelType,omitempty"`

	// LocalityName Full name of locality
	LocalityName string `json:"localityName"`

	// LotNumber Allotment number for the address
	LotNumber *string `json:"lotNumber,omitempty"`

	// PostalDeliveryNumber Postal delivery number if the address is a postal delivery type
	PostalDeliveryNumber *int `json:"postalDeliveryNumber,omitempty"`

	// PostalDeliveryNumberPrefix Postal delivery number prefix related to the postal delivery number
	PostalDeliveryNumberPrefix *string `json:"postalDeliveryNumberPrefix,omitempty"`

	// PostalDeliveryNumberSuffix Postal delivery number suffix related to the postal delivery number
	PostalDeliveryNumberSuffix *string `json:"postalDeliveryNumberSuffix,omitempty"`

	// PostalDeliveryType Postal delivery type. (eg. PO BOX). Valid enumeration defined by Australia Post PAF code file
	PostalDeliveryType *string `json:"postalDeliveryType,omitempty"`

	// Postcode Postcode for the locality
	Postcode string `json:"postcode"`

	// State State in which the address belongs. Valid enumeration defined by Australia Post PAF code file [State Type Abbreviation](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf). NSW, QLD, VIC, NT, WA, SA, TAS, ACT, AAT
	State string `json:"state"`

	// StreetName The name of the street
	StreetName *string `json:"streetName,omitempty"`

	// StreetSuffix The street type suffix. Valid enumeration defined by Australia Post PAF code file
	StreetSuffix *string `json:"streetSuffix,omitempty"`

	// StreetType The street type. Valid enumeration defined by Australia Post PAF code file
	StreetType *string `json:"streetType,omitempty"`

	// ThoroughfareNumber1 Thoroughfare number for a property (first number in a property ranged address)
	ThoroughfareNumber1 *int `json:"thoroughfareNumber1,omitempty"`

	// ThoroughfareNumber1Suffix Suffix for the thoroughfare number. Only relevant is thoroughfareNumber1 is populated
	ThoroughfareNumber1Suffix *string `json:"thoroughfareNumber1Suffix,omitempty"`

	// ThoroughfareNumber2 Second thoroughfare number (only used if the property has a ranged address eg 23-25)
	ThoroughfareNumber2 *int `json:"thoroughfareNumber2,omitempty"`

	// ThoroughfareNumber2Suffix Suffix for the second thoroughfare number. Only relevant is thoroughfareNumber2 is populated
	ThoroughfareNumber2Suffix *string `json:"thoroughfareNumber2Suffix,omitempty"`
}

// CommonPhysicalAddress defines model for CommonPhysicalAddress.
type CommonPhysicalAddress struct {
	// AddressUType The type of address object present
	AddressUType CommonPhysicalAddressAddressUType `json:"addressUType"`

	// Paf Australian address formatted according to the file format defined by the [PAF file format](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf)
	Paf    *CommonPAFAddress    `json:"paf,omitempty"`
	Simple *CommonSimpleAddress `json:"simple,omitempty"`
}

// CommonPhysicalAddressAddressUType The type of address object present
type CommonPhysicalAddressAddressUType string

// CommonSimpleAddress defines model for CommonSimpleAddress.
type CommonSimpleAddress struct {
	// AddressLine1 First line of the standard address object
	AddressLine1 string `json:"addressLine1"`

	// AddressLine2 Second line of the standard address object
	AddressLine2 *string `json:"addressLine2,omitempty"`

	// AddressLine3 Third line of the standard address object
	AddressLine3 *string `json:"addressLine3,omitempty"`

	// City Name of the city or locality
	City string `json:"city"`

	// Country A valid [ISO 3166 Alpha-3](https://www.iso.org/iso-3166-country-codes.html) country code. Australia (AUS) is assumed if country is not present.
	Country *string `json:"country,omitempty"`

	// MailingName Name of the individual or business formatted for inclusion in an address used for physical mail
	MailingName *string `json:"mailingName,omitempty"`

	// Postcode Mandatory for Australian addresses
	Postcode *string `json:"postcode,omitempty"`

	// State Free text if the country is not Australia. If country is Australia then must be one of the values defined by the [State Type Abbreviation](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf) in the PAF file format. NSW, QLD, VIC, NT, WA, SA, TAS, ACT, AAT
	State string `json:"state"`
}

// Links defines model for Links.
type Links struct {
	// Self Fully qualified link that generated the current response document
	Self string `json:"self"`
}

// LinksPaginated defines model for LinksPaginated.
type LinksPaginated struct {
	// First URI to the first page of this set. Mandatory if this response is not the first page
	First *string `json:"first,omitempty"`

	// Last URI to the last page of this set. Mandatory if this response is not the last page
	Last *string `json:"last,omitempty"`

	// Next URI to the next page of this set. Mandatory if this response is not the last page
	Next *string `json:"next,omitempty"`

	// Prev URI to the previous page of this set. Mandatory if this response is not the first page
	Prev *string `json:"prev,omitempty"`

	// Self Fully qualified link that generated the current response document
	Self string `json:"self"`
}

// Meta defines model for Meta.
type Meta = map[string]interface{}

// MetaError Additional data for customised error codes
type MetaError struct {
	// Urn The CDR error code URN which the application-specific error code extends. Mandatory if the error `code` is an application-specific error rather than a standardised error code.
	Urn *string `json:"urn,omitempty"`
}

// MetaPaginated defines model for MetaPaginated.
type MetaPaginated struct {
	// TotalPages The total number of pages in the full set. See [pagination](#pagination).
	TotalPages int `json:"totalPages"`

	// TotalRecords The total number of records in the full set. See [pagination](#pagination).
	TotalRecords int `json:"totalRecords"`
}

// RequestAccountIds defines model for RequestAccountIds.
type RequestAccountIds struct {
	Data struct {
		AccountIds []string `json:"accountIds"`
	} `json:"data"`
	Meta *Meta `json:"meta,omitempty"`
}

// ResponseBankingAccountByIdV2 defines model for ResponseBankingAccountByIdV2.
type ResponseBankingAccountByIdV2 struct {
	Data  BankingAccountDetailV2 `json:"data"`
	Links Links                  `json:"links"`
	Meta  *Meta                  `json:"meta,omitempty"`
}

// ResponseBankingAccountList defines model for ResponseBankingAccountList.
type ResponseBankingAccountList struct {
	Data struct {
		// Accounts The list of accounts returned. If the filter results in an empty set then this array may have no records
		Accounts []BankingAccount `json:"accounts"`
	} `json:"data"`
	Links LinksPaginated `json:"links"`
	Meta  MetaPaginated  `json:"meta"`
}

// ResponseBankingAccountsBalanceById defines model for ResponseBankingAccountsBalanceById.
type ResponseBankingAccountsBalanceById struct {
	Data  BankingBalance `json:"data"`
	Links Links          `json:"links"`
	Meta  *Meta          `json:"meta,omitempty"`
}

// ResponseBankingAccountsBalanceList defines model for ResponseBankingAccountsBalanceList.
type ResponseBankingAccountsBalanceList struct {
	Data struct {
		// Balances The list of balances returned
		Balances []BankingBalance `json:"balances"`
	} `json:"data"`
	Links LinksPaginated `json:"links"`
	Meta  MetaPaginated  `json:"meta"`
}

// ResponseBankingDirectDebitAuthorisationList defines model for ResponseBankingDirectDebitAuthorisationList.
type ResponseBankingDirectDebitAuthorisationList struct {
	Data struct {
		// DirectDebitAuthorisations The list of authorisations returned
		DirectDebitAuthorisations []BankingDirectDebit `json:"directDebitAuthorisations"`
	} `json:"data"`
	Links LinksPaginated `json:"links"`
	Meta  MetaPaginated  `json:"meta"`
}

// ResponseBankingPayeeByIdV2 defines model for ResponseBankingPayeeByIdV2.
type ResponseBankingPayeeByIdV2 struct {
	Data  BankingPayeeDetailV2 `json:"data"`
	Links Links                `json:"links"`
	Meta  *Meta                `json:"meta,omitempty"`
}

// ResponseBankingPayeeListV2 defines model for ResponseBankingPayeeListV2.
type ResponseBankingPayeeListV2 struct {
	Data struct {
		// Payees The list of payees returned
		Payees []BankingPayeeV2 `json:"payees"`
	} `json:"data"`
	Links LinksPaginated `json:"links"`
	Meta  MetaPaginated  `json:"meta"`
}

// ResponseBankingProductByIdV4 defines model for ResponseBankingProductByIdV4.
type ResponseBankingProductByIdV4 struct {
	Data  BankingProductDetailV4 `json:"data"`
	Links Links                  `json:"links"`
	Meta  *Meta                  `json:"meta,omitempty"`
}

// ResponseBankingProductListV2 defines model for ResponseBankingProductListV2.
type ResponseBankingProductListV2 struct {
	Data struct {
		// Products The list of products returned.  If the filter results in an empty set then this array may have no records
		Products []BankingProductV4 `json:"products"`
	} `json:"data"`
	Links LinksPaginated `json:"links"`
	Meta  MetaPaginated  `json:"meta"`
}

// ResponseBankingScheduledPaymentsList defines model for ResponseBankingScheduledPaymentsList.
type ResponseBankingScheduledPaymentsList struct {
	Data struct {
		// ScheduledPayments The list of scheduled payments to return
		ScheduledPayments []BankingScheduledPayment `json:"scheduledPayments"`
	} `json:"data"`
	Links LinksPaginated `json:"links"`
	Meta  MetaPaginated  `json:"meta"`
}

// ResponseBankingTransactionById defines model for ResponseBankingTransactionById.
type ResponseBankingTransactionById struct {
	Data  BankingTransactionDetail `json:"data"`
	Links Links                    `json:"links"`
	Meta  *Meta                    `json:"meta,omitempty"`
}

// ResponseBankingTransactionList defines model for ResponseBankingTransactionList.
type ResponseBankingTransactionList struct {
	Data struct {
		Transactions []BankingTransaction `json:"transactions"`
	} `json:"data"`
	Links LinksPaginated `json:"links"`
	Meta  MetaPaginated  `json:"meta"`
}

// ResponseErrorListV2 defines model for ResponseErrorListV2.
type ResponseErrorListV2 struct {
	Errors []struct {
		// Code The code of the error encountered. Where the error is specific to the respondent, an application-specific error code, expressed as a string value. If the error is application-specific, the URN code that the specific error extends must be provided in the meta object. Otherwise, the value is the error code URN.
		Code string `json:"code"`

		// Detail A human-readable explanation specific to this occurrence of the problem.
		Detail string `json:"detail"`

		// Meta Additional data for customised error codes
		Meta *MetaError `json:"meta,omitempty"`

		// Title A short, human-readable summary of the problem that MUST NOT change from occurrence to occurrence of the problem represented by the error code.
		Title string `json:"title"`
	} `json:"errors"`
}

// ListAccountsParams defines parameters for ListAccounts.
type ListAccountsParams struct {
	// ProductCategory Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
	ProductCategory *ListAccountsParamsProductCategory `form:"product-category,omitempty" json:"product-category,omitempty"`

	// OpenStatus Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed
	OpenStatus *ListAccountsParamsOpenStatus `form:"open-status,omitempty" json:"open-status,omitempty"`

	// IsOwned Filters accounts based on whether they are owned by the authorised customer.  True for owned accounts, false for unowned accounts and absent for all accounts
	IsOwned *bool `form:"is-owned,omitempty" json:"is-owned,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request. Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product. Required for all resource calls (customer present and unattended) if the customer has logged in. Not to be included for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the Data Recipient Software Product. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the Data Recipient Software Product. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListAccountsParamsProductCategory defines parameters for ListAccounts.
type ListAccountsParamsProductCategory string

// ListAccountsParamsOpenStatus defines parameters for ListAccounts.
type ListAccountsParamsOpenStatus string

// ListBalancesBulkParams defines parameters for ListBalancesBulk.
type ListBalancesBulkParams struct {
	// ProductCategory Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
	ProductCategory *ListBalancesBulkParamsProductCategory `form:"product-category,omitempty" json:"product-category,omitempty"`

	// OpenStatus Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed
	OpenStatus *ListBalancesBulkParamsOpenStatus `form:"open-status,omitempty" json:"open-status,omitempty"`

	// IsOwned Filters accounts based on whether they are owned by the authorised customer.  True for owned accounts, false for unowned accounts and absent for all accounts
	IsOwned *bool `form:"is-owned,omitempty" json:"is-owned,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request. Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product. Required for all resource calls (customer present and unattended) if the customer has logged in. Not to be included for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the Data Recipient Software Product. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the Data Recipient Software Product. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListBalancesBulkParamsProductCategory defines parameters for ListBalancesBulk.
type ListBalancesBulkParamsProductCategory string

// ListBalancesBulkParamsOpenStatus defines parameters for ListBalancesBulk.
type ListBalancesBulkParamsOpenStatus string

// ListBalancesSpecificAccountsParams defines parameters for ListBalancesSpecificAccounts.
type ListBalancesSpecificAccountsParams struct {
	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request. Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product. Required for all resource calls (customer present and unattended) if the customer has logged in. Not to be included for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the Data Recipient Software Product. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the Data Recipient Software Product. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListDirectDebitsBulkParams defines parameters for ListDirectDebitsBulk.
type ListDirectDebitsBulkParams struct {
	// ProductCategory Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
	ProductCategory *ListDirectDebitsBulkParamsProductCategory `form:"product-category,omitempty" json:"product-category,omitempty"`

	// OpenStatus Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed
	OpenStatus *ListDirectDebitsBulkParamsOpenStatus `form:"open-status,omitempty" json:"open-status,omitempty"`

	// IsOwned Filters accounts based on whether they are owned by the authorised customer.  True for owned accounts, false for unowned accounts and absent for all accounts
	IsOwned *bool `form:"is-owned,omitempty" json:"is-owned,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request. Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product. Required for all resource calls (customer present and unattended) if the customer has logged in. Not to be included for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the Data Recipient Software Product. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the Data Recipient Software Product. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListDirectDebitsBulkParamsProductCategory defines parameters for ListDirectDebitsBulk.
type ListDirectDebitsBulkParamsProductCategory string

// ListDirectDebitsBulkParamsOpenStatus defines parameters for ListDirectDebitsBulk.
type ListDirectDebitsBulkParamsOpenStatus string

// ListDirectDebitsSpecificAccountsParams defines parameters for ListDirectDebitsSpecificAccounts.
type ListDirectDebitsSpecificAccountsParams struct {
	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request. Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product. Required for all resource calls (customer present and unattended) if the customer has logged in. Not to be included for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the Data Recipient Software Product. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the Data Recipient Software Product. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// GetAccountDetailParams defines parameters for GetAccountDetail.
type GetAccountDetailParams struct {
	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product. Required for all resource calls (customer present and unattended) if the customer has logged in. Not to be included for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the Data Recipient Software Product. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the Data Recipient Software Product. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// GetBalanceParams defines parameters for GetBalance.
type GetBalanceParams struct {
	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product. Required for all resource calls (customer present and unattended) if the customer has logged in. Not to be included for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the Data Recipient Software Product. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the Data Recipient Software Product. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListDirectDebitsParams defines parameters for ListDirectDebits.
type ListDirectDebitsParams struct {
	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request. Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product. Required for all resource calls (customer present and unattended) if the customer has logged in. Not to be included for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the Data Recipient Software Product. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the Data Recipient Software Product. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListScheduledPaymentsParams defines parameters for ListScheduledPayments.
type ListScheduledPaymentsParams struct {
	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request. Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product. Required for all resource calls (customer present and unattended) if the customer has logged in. Not to be included for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the Data Recipient Software Product. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the Data Recipient Software Product. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// GetTransactionsParams defines parameters for GetTransactions.
type GetTransactionsParams struct {
	// OldestTime Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to newest-time minus 90 days.  Format is aligned to DateTimeString common type
	OldestTime *string `form:"oldest-time,omitempty" json:"oldest-time,omitempty"`

	// NewestTime Constrain the transaction history request to transactions with effective time at or before this date/time.  If absent defaults to today.  Format is aligned to DateTimeString common type
	NewestTime *string `form:"newest-time,omitempty" json:"newest-time,omitempty"`

	// MinAmount Filter transactions to only transactions with amounts higher or equal to than this amount
	MinAmount *string `form:"min-amount,omitempty" json:"min-amount,omitempty"`

	// MaxAmount Filter transactions to only transactions with amounts less than or equal to than this amount
	MaxAmount *string `form:"max-amount,omitempty" json:"max-amount,omitempty"`

	// Text Filter transactions to only transactions where this string value is found as a substring of either the reference or description fields. Format is arbitrary ASCII string. This parameter is optionally implemented by data holders. If it is not implemented then a response should be provided as normal without text filtering applied and an additional boolean field named isQueryParamUnsupported should be included in the meta object and set to true (whether the text parameter is supplied or not)
	Text *string `form:"text,omitempty" json:"text,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request. Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product. Required for all resource calls (customer present and unattended) if the customer has logged in. Not to be included for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the Data Recipient Software Product. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the Data Recipient Software Product. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// GetTransactionDetailParams defines parameters for GetTransactionDetail.
type GetTransactionDetailParams struct {
	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product. Required for all resource calls (customer present and unattended) if the customer has logged in. Not to be included for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the Data Recipient Software Product. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the Data Recipient Software Product. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListPayeesParams defines parameters for ListPayees.
type ListPayeesParams struct {
	// Type Filter on the payee type field.  In addition to normal type field values, ALL can be specified to retrieve all payees.  If absent the assumed value is ALL
	Type *ListPayeesParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request. Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product. Required for all resource calls (customer present and unattended) if the customer has logged in. Not to be included for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the Data Recipient Software Product. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the Data Recipient Software Product. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListPayeesParamsType defines parameters for ListPayees.
type ListPayeesParamsType string

// GetPayeeDetailParams defines parameters for GetPayeeDetail.
type GetPayeeDetailParams struct {
	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product. Required for all resource calls (customer present and unattended) if the customer has logged in. Not to be included for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the Data Recipient Software Product. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the Data Recipient Software Product. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListScheduledPaymentsBulkParams defines parameters for ListScheduledPaymentsBulk.
type ListScheduledPaymentsBulkParams struct {
	// ProductCategory Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
	ProductCategory *ListScheduledPaymentsBulkParamsProductCategory `form:"product-category,omitempty" json:"product-category,omitempty"`

	// OpenStatus Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed
	OpenStatus *ListScheduledPaymentsBulkParamsOpenStatus `form:"open-status,omitempty" json:"open-status,omitempty"`

	// IsOwned Filters accounts based on whether they are owned by the authorised customer.  True for owned accounts, false for unowned accounts and absent for all accounts
	IsOwned *bool `form:"is-owned,omitempty" json:"is-owned,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request. Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product. Required for all resource calls (customer present and unattended) if the customer has logged in. Not to be included for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the Data Recipient Software Product. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the Data Recipient Software Product. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListScheduledPaymentsBulkParamsProductCategory defines parameters for ListScheduledPaymentsBulk.
type ListScheduledPaymentsBulkParamsProductCategory string

// ListScheduledPaymentsBulkParamsOpenStatus defines parameters for ListScheduledPaymentsBulk.
type ListScheduledPaymentsBulkParamsOpenStatus string

// ListScheduledPaymentsSpecificAccountsParams defines parameters for ListScheduledPaymentsSpecificAccounts.
type ListScheduledPaymentsSpecificAccountsParams struct {
	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request. Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product. Required for all resource calls (customer present and unattended) if the customer has logged in. Not to be included for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the Data Recipient Software Product. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the Data Recipient Software Product. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListProductsParams defines parameters for ListProducts.
type ListProductsParams struct {
	// Effective Allows for the filtering of products based on whether the current time is within the period of time defined as effective by the effectiveFrom and effectiveTo fields. Valid values are CURRENT, FUTURE and ALL. If absent defaults to 'CURRENT'
	Effective *ListProductsParamsEffective `form:"effective,omitempty" json:"effective,omitempty"`

	// UpdatedSince Only include products that have been updated after the specified date and time. If absent defaults to include all products
	UpdatedSince *string `form:"updated-since,omitempty" json:"updated-since,omitempty"`

	// Brand Filter results based on a specific brand
	Brand *string `form:"brand,omitempty" json:"brand,omitempty"`

	// ProductCategory Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
	ProductCategory *ListProductsParamsProductCategory `form:"product-category,omitempty" json:"product-category,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request. Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`
}

// ListProductsParamsEffective defines parameters for ListProducts.
type ListProductsParamsEffective string

// ListProductsParamsProductCategory defines parameters for ListProducts.
type ListProductsParamsProductCategory string

// GetProductDetailParams defines parameters for GetProductDetail.
type GetProductDetailParams struct {
	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`
}

// ListBalancesSpecificAccountsJSONRequestBody defines body for ListBalancesSpecificAccounts for application/json ContentType.
type ListBalancesSpecificAccountsJSONRequestBody = RequestAccountIds

// ListDirectDebitsSpecificAccountsJSONRequestBody defines body for ListDirectDebitsSpecificAccounts for application/json ContentType.
type ListDirectDebitsSpecificAccountsJSONRequestBody = RequestAccountIds

// ListScheduledPaymentsSpecificAccountsJSONRequestBody defines body for ListScheduledPaymentsSpecificAccounts for application/json ContentType.
type ListScheduledPaymentsSpecificAccountsJSONRequestBody = RequestAccountIds

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListAccounts request
	ListAccounts(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBalancesBulk request
	ListBalancesBulk(ctx context.Context, params *ListBalancesBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBalancesSpecificAccounts request with any body
	ListBalancesSpecificAccountsWithBody(ctx context.Context, params *ListBalancesSpecificAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListBalancesSpecificAccounts(ctx context.Context, params *ListBalancesSpecificAccountsParams, body ListBalancesSpecificAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDirectDebitsBulk request
	ListDirectDebitsBulk(ctx context.Context, params *ListDirectDebitsBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDirectDebitsSpecificAccounts request with any body
	ListDirectDebitsSpecificAccountsWithBody(ctx context.Context, params *ListDirectDebitsSpecificAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListDirectDebitsSpecificAccounts(ctx context.Context, params *ListDirectDebitsSpecificAccountsParams, body ListDirectDebitsSpecificAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccountDetail request
	GetAccountDetail(ctx context.Context, accountId string, params *GetAccountDetailParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBalance request
	GetBalance(ctx context.Context, accountId string, params *GetBalanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDirectDebits request
	ListDirectDebits(ctx context.Context, accountId string, params *ListDirectDebitsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListScheduledPayments request
	ListScheduledPayments(ctx context.Context, accountId string, params *ListScheduledPaymentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransactions request
	GetTransactions(ctx context.Context, accountId string, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransactionDetail request
	GetTransactionDetail(ctx context.Context, accountId string, transactionId string, params *GetTransactionDetailParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPayees request
	ListPayees(ctx context.Context, params *ListPayeesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPayeeDetail request
	GetPayeeDetail(ctx context.Context, payeeId string, params *GetPayeeDetailParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListScheduledPaymentsBulk request
	ListScheduledPaymentsBulk(ctx context.Context, params *ListScheduledPaymentsBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListScheduledPaymentsSpecificAccounts request with any body
	ListScheduledPaymentsSpecificAccountsWithBody(ctx context.Context, params *ListScheduledPaymentsSpecificAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListScheduledPaymentsSpecificAccounts(ctx context.Context, params *ListScheduledPaymentsSpecificAccountsParams, body ListScheduledPaymentsSpecificAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProducts request
	ListProducts(ctx context.Context, params *ListProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductDetail request
	GetProductDetail(ctx context.Context, productId string, params *GetProductDetailParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListAccounts(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBalancesBulk(ctx context.Context, params *ListBalancesBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBalancesBulkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBalancesSpecificAccountsWithBody(ctx context.Context, params *ListBalancesSpecificAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBalancesSpecificAccountsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBalancesSpecificAccounts(ctx context.Context, params *ListBalancesSpecificAccountsParams, body ListBalancesSpecificAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBalancesSpecificAccountsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDirectDebitsBulk(ctx context.Context, params *ListDirectDebitsBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDirectDebitsBulkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDirectDebitsSpecificAccountsWithBody(ctx context.Context, params *ListDirectDebitsSpecificAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDirectDebitsSpecificAccountsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDirectDebitsSpecificAccounts(ctx context.Context, params *ListDirectDebitsSpecificAccountsParams, body ListDirectDebitsSpecificAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDirectDebitsSpecificAccountsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccountDetail(ctx context.Context, accountId string, params *GetAccountDetailParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountDetailRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBalance(ctx context.Context, accountId string, params *GetBalanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBalanceRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDirectDebits(ctx context.Context, accountId string, params *ListDirectDebitsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDirectDebitsRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListScheduledPayments(ctx context.Context, accountId string, params *ListScheduledPaymentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListScheduledPaymentsRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransactions(ctx context.Context, accountId string, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionsRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransactionDetail(ctx context.Context, accountId string, transactionId string, params *GetTransactionDetailParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionDetailRequest(c.Server, accountId, transactionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPayees(ctx context.Context, params *ListPayeesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPayeesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPayeeDetail(ctx context.Context, payeeId string, params *GetPayeeDetailParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPayeeDetailRequest(c.Server, payeeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListScheduledPaymentsBulk(ctx context.Context, params *ListScheduledPaymentsBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListScheduledPaymentsBulkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListScheduledPaymentsSpecificAccountsWithBody(ctx context.Context, params *ListScheduledPaymentsSpecificAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListScheduledPaymentsSpecificAccountsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListScheduledPaymentsSpecificAccounts(ctx context.Context, params *ListScheduledPaymentsSpecificAccountsParams, body ListScheduledPaymentsSpecificAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListScheduledPaymentsSpecificAccountsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProducts(ctx context.Context, params *ListProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProductsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductDetail(ctx context.Context, productId string, params *GetProductDetailParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductDetailRequest(c.Server, productId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAccountsRequest generates requests for ListAccounts
func NewListAccountsRequest(server string, params *ListAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/banking/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ProductCategory != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product-category", runtime.ParamLocationQuery, *params.ProductCategory); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OpenStatus != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "open-status", runtime.ParamLocationQuery, *params.OpenStatus); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsOwned != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is-owned", runtime.ParamLocationQuery, *params.IsOwned); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListBalancesBulkRequest generates requests for ListBalancesBulk
func NewListBalancesBulkRequest(server string, params *ListBalancesBulkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/banking/accounts/balances")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ProductCategory != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product-category", runtime.ParamLocationQuery, *params.ProductCategory); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OpenStatus != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "open-status", runtime.ParamLocationQuery, *params.OpenStatus); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsOwned != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is-owned", runtime.ParamLocationQuery, *params.IsOwned); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListBalancesSpecificAccountsRequest calls the generic ListBalancesSpecificAccounts builder with application/json body
func NewListBalancesSpecificAccountsRequest(server string, params *ListBalancesSpecificAccountsParams, body ListBalancesSpecificAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListBalancesSpecificAccountsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewListBalancesSpecificAccountsRequestWithBody generates requests for ListBalancesSpecificAccounts with any type of body
func NewListBalancesSpecificAccountsRequestWithBody(server string, params *ListBalancesSpecificAccountsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/banking/accounts/balances")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListDirectDebitsBulkRequest generates requests for ListDirectDebitsBulk
func NewListDirectDebitsBulkRequest(server string, params *ListDirectDebitsBulkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/banking/accounts/direct-debits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ProductCategory != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product-category", runtime.ParamLocationQuery, *params.ProductCategory); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OpenStatus != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "open-status", runtime.ParamLocationQuery, *params.OpenStatus); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsOwned != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is-owned", runtime.ParamLocationQuery, *params.IsOwned); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListDirectDebitsSpecificAccountsRequest calls the generic ListDirectDebitsSpecificAccounts builder with application/json body
func NewListDirectDebitsSpecificAccountsRequest(server string, params *ListDirectDebitsSpecificAccountsParams, body ListDirectDebitsSpecificAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListDirectDebitsSpecificAccountsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewListDirectDebitsSpecificAccountsRequestWithBody generates requests for ListDirectDebitsSpecificAccounts with any type of body
func NewListDirectDebitsSpecificAccountsRequestWithBody(server string, params *ListDirectDebitsSpecificAccountsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/banking/accounts/direct-debits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewGetAccountDetailRequest generates requests for GetAccountDetail
func NewGetAccountDetailRequest(server string, accountId string, params *GetAccountDetailParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/banking/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewGetBalanceRequest generates requests for GetBalance
func NewGetBalanceRequest(server string, accountId string, params *GetBalanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/banking/accounts/%s/balance", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListDirectDebitsRequest generates requests for ListDirectDebits
func NewListDirectDebitsRequest(server string, accountId string, params *ListDirectDebitsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/banking/accounts/%s/direct-debits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListScheduledPaymentsRequest generates requests for ListScheduledPayments
func NewListScheduledPaymentsRequest(server string, accountId string, params *ListScheduledPaymentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/banking/accounts/%s/payments/scheduled", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewGetTransactionsRequest generates requests for GetTransactions
func NewGetTransactionsRequest(server string, accountId string, params *GetTransactionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/banking/accounts/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.OldestTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-time", runtime.ParamLocationQuery, *params.OldestTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NewestTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-time", runtime.ParamLocationQuery, *params.NewestTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MinAmount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min-amount", runtime.ParamLocationQuery, *params.MinAmount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.MaxAmount != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max-amount", runtime.ParamLocationQuery, *params.MaxAmount); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Text != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "text", runtime.ParamLocationQuery, *params.Text); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewGetTransactionDetailRequest generates requests for GetTransactionDetail
func NewGetTransactionDetailRequest(server string, accountId string, transactionId string, params *GetTransactionDetailParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transactionId", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/banking/accounts/%s/transactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListPayeesRequest generates requests for ListPayees
func NewListPayeesRequest(server string, params *ListPayeesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/banking/payees")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewGetPayeeDetailRequest generates requests for GetPayeeDetail
func NewGetPayeeDetailRequest(server string, payeeId string, params *GetPayeeDetailParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "payeeId", runtime.ParamLocationPath, payeeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/banking/payees/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListScheduledPaymentsBulkRequest generates requests for ListScheduledPaymentsBulk
func NewListScheduledPaymentsBulkRequest(server string, params *ListScheduledPaymentsBulkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/banking/payments/scheduled")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ProductCategory != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product-category", runtime.ParamLocationQuery, *params.ProductCategory); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OpenStatus != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "open-status", runtime.ParamLocationQuery, *params.OpenStatus); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IsOwned != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is-owned", runtime.ParamLocationQuery, *params.IsOwned); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListScheduledPaymentsSpecificAccountsRequest calls the generic ListScheduledPaymentsSpecificAccounts builder with application/json body
func NewListScheduledPaymentsSpecificAccountsRequest(server string, params *ListScheduledPaymentsSpecificAccountsParams, body ListScheduledPaymentsSpecificAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListScheduledPaymentsSpecificAccountsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewListScheduledPaymentsSpecificAccountsRequestWithBody generates requests for ListScheduledPaymentsSpecificAccounts with any type of body
func NewListScheduledPaymentsSpecificAccountsRequestWithBody(server string, params *ListScheduledPaymentsSpecificAccountsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/banking/payments/scheduled")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListProductsRequest generates requests for ListProducts
func NewListProductsRequest(server string, params *ListProductsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/banking/products")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Effective != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective", runtime.ParamLocationQuery, *params.Effective); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UpdatedSince != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated-since", runtime.ParamLocationQuery, *params.UpdatedSince); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Brand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "brand", runtime.ParamLocationQuery, *params.Brand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ProductCategory != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "product-category", runtime.ParamLocationQuery, *params.ProductCategory); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	return req, nil
}

// NewGetProductDetailRequest generates requests for GetProductDetail
func NewGetProductDetailRequest(server string, productId string, params *GetProductDetailParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "productId", runtime.ParamLocationPath, productId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/banking/products/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAccounts request
	ListAccountsWithResponse(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*ListAccountsResponse, error)

	// ListBalancesBulk request
	ListBalancesBulkWithResponse(ctx context.Context, params *ListBalancesBulkParams, reqEditors ...RequestEditorFn) (*ListBalancesBulkResponse, error)

	// ListBalancesSpecificAccounts request with any body
	ListBalancesSpecificAccountsWithBodyWithResponse(ctx context.Context, params *ListBalancesSpecificAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListBalancesSpecificAccountsResponse, error)

	ListBalancesSpecificAccountsWithResponse(ctx context.Context, params *ListBalancesSpecificAccountsParams, body ListBalancesSpecificAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListBalancesSpecificAccountsResponse, error)

	// ListDirectDebitsBulk request
	ListDirectDebitsBulkWithResponse(ctx context.Context, params *ListDirectDebitsBulkParams, reqEditors ...RequestEditorFn) (*ListDirectDebitsBulkResponse, error)

	// ListDirectDebitsSpecificAccounts request with any body
	ListDirectDebitsSpecificAccountsWithBodyWithResponse(ctx context.Context, params *ListDirectDebitsSpecificAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListDirectDebitsSpecificAccountsResponse, error)

	ListDirectDebitsSpecificAccountsWithResponse(ctx context.Context, params *ListDirectDebitsSpecificAccountsParams, body ListDirectDebitsSpecificAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListDirectDebitsSpecificAccountsResponse, error)

	// GetAccountDetail request
	GetAccountDetailWithResponse(ctx context.Context, accountId string, params *GetAccountDetailParams, reqEditors ...RequestEditorFn) (*GetAccountDetailResponse, error)

	// GetBalance request
	GetBalanceWithResponse(ctx context.Context, accountId string, params *GetBalanceParams, reqEditors ...RequestEditorFn) (*GetBalanceResponse, error)

	// ListDirectDebits request
	ListDirectDebitsWithResponse(ctx context.Context, accountId string, params *ListDirectDebitsParams, reqEditors ...RequestEditorFn) (*ListDirectDebitsResponse, error)

	// ListScheduledPayments request
	ListScheduledPaymentsWithResponse(ctx context.Context, accountId string, params *ListScheduledPaymentsParams, reqEditors ...RequestEditorFn) (*ListScheduledPaymentsResponse, error)

	// GetTransactions request
	GetTransactionsWithResponse(ctx context.Context, accountId string, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*GetTransactionsResponse, error)

	// GetTransactionDetail request
	GetTransactionDetailWithResponse(ctx context.Context, accountId string, transactionId string, params *GetTransactionDetailParams, reqEditors ...RequestEditorFn) (*GetTransactionDetailResponse, error)

	// ListPayees request
	ListPayeesWithResponse(ctx context.Context, params *ListPayeesParams, reqEditors ...RequestEditorFn) (*ListPayeesResponse, error)

	// GetPayeeDetail request
	GetPayeeDetailWithResponse(ctx context.Context, payeeId string, params *GetPayeeDetailParams, reqEditors ...RequestEditorFn) (*GetPayeeDetailResponse, error)

	// ListScheduledPaymentsBulk request
	ListScheduledPaymentsBulkWithResponse(ctx context.Context, params *ListScheduledPaymentsBulkParams, reqEditors ...RequestEditorFn) (*ListScheduledPaymentsBulkResponse, error)

	// ListScheduledPaymentsSpecificAccounts request with any body
	ListScheduledPaymentsSpecificAccountsWithBodyWithResponse(ctx context.Context, params *ListScheduledPaymentsSpecificAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListScheduledPaymentsSpecificAccountsResponse, error)

	ListScheduledPaymentsSpecificAccountsWithResponse(ctx context.Context, params *ListScheduledPaymentsSpecificAccountsParams, body ListScheduledPaymentsSpecificAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListScheduledPaymentsSpecificAccountsResponse, error)

	// ListProducts request
	ListProductsWithResponse(ctx context.Context, params *ListProductsParams, reqEditors ...RequestEditorFn) (*ListProductsResponse, error)

	// GetProductDetail request
	GetProductDetailWithResponse(ctx context.Context, productId string, params *GetProductDetailParams, reqEditors ...RequestEditorFn) (*GetProductDetailResponse, error)
}

type ListAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseBankingAccountList
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBalancesBulkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseBankingAccountsBalanceList
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListBalancesBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBalancesBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBalancesSpecificAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseBankingAccountsBalanceList
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListBalancesSpecificAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBalancesSpecificAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDirectDebitsBulkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseBankingDirectDebitAuthorisationList
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListDirectDebitsBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDirectDebitsBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDirectDebitsSpecificAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseBankingDirectDebitAuthorisationList
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListDirectDebitsSpecificAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDirectDebitsSpecificAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountDetailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseBankingAccountByIdV2
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetAccountDetailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountDetailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBalanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseBankingAccountsBalanceById
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetBalanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBalanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDirectDebitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseBankingDirectDebitAuthorisationList
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListDirectDebitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDirectDebitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListScheduledPaymentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseBankingScheduledPaymentsList
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListScheduledPaymentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListScheduledPaymentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseBankingTransactionList
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionDetailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseBankingTransactionById
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetTransactionDetailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionDetailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPayeesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseBankingPayeeListV2
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListPayeesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPayeesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPayeeDetailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseBankingPayeeByIdV2
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetPayeeDetailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPayeeDetailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListScheduledPaymentsBulkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseBankingScheduledPaymentsList
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListScheduledPaymentsBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListScheduledPaymentsBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListScheduledPaymentsSpecificAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseBankingScheduledPaymentsList
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListScheduledPaymentsSpecificAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListScheduledPaymentsSpecificAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProductsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseBankingProductListV2
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListProductsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProductsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductDetailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseBankingProductByIdV4
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetProductDetailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductDetailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAccountsWithResponse request returning *ListAccountsResponse
func (c *ClientWithResponses) ListAccountsWithResponse(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*ListAccountsResponse, error) {
	rsp, err := c.ListAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAccountsResponse(rsp)
}

// ListBalancesBulkWithResponse request returning *ListBalancesBulkResponse
func (c *ClientWithResponses) ListBalancesBulkWithResponse(ctx context.Context, params *ListBalancesBulkParams, reqEditors ...RequestEditorFn) (*ListBalancesBulkResponse, error) {
	rsp, err := c.ListBalancesBulk(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBalancesBulkResponse(rsp)
}

// ListBalancesSpecificAccountsWithBodyWithResponse request with arbitrary body returning *ListBalancesSpecificAccountsResponse
func (c *ClientWithResponses) ListBalancesSpecificAccountsWithBodyWithResponse(ctx context.Context, params *ListBalancesSpecificAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListBalancesSpecificAccountsResponse, error) {
	rsp, err := c.ListBalancesSpecificAccountsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBalancesSpecificAccountsResponse(rsp)
}

func (c *ClientWithResponses) ListBalancesSpecificAccountsWithResponse(ctx context.Context, params *ListBalancesSpecificAccountsParams, body ListBalancesSpecificAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListBalancesSpecificAccountsResponse, error) {
	rsp, err := c.ListBalancesSpecificAccounts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBalancesSpecificAccountsResponse(rsp)
}

// ListDirectDebitsBulkWithResponse request returning *ListDirectDebitsBulkResponse
func (c *ClientWithResponses) ListDirectDebitsBulkWithResponse(ctx context.Context, params *ListDirectDebitsBulkParams, reqEditors ...RequestEditorFn) (*ListDirectDebitsBulkResponse, error) {
	rsp, err := c.ListDirectDebitsBulk(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDirectDebitsBulkResponse(rsp)
}

// ListDirectDebitsSpecificAccountsWithBodyWithResponse request with arbitrary body returning *ListDirectDebitsSpecificAccountsResponse
func (c *ClientWithResponses) ListDirectDebitsSpecificAccountsWithBodyWithResponse(ctx context.Context, params *ListDirectDebitsSpecificAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListDirectDebitsSpecificAccountsResponse, error) {
	rsp, err := c.ListDirectDebitsSpecificAccountsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDirectDebitsSpecificAccountsResponse(rsp)
}

func (c *ClientWithResponses) ListDirectDebitsSpecificAccountsWithResponse(ctx context.Context, params *ListDirectDebitsSpecificAccountsParams, body ListDirectDebitsSpecificAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListDirectDebitsSpecificAccountsResponse, error) {
	rsp, err := c.ListDirectDebitsSpecificAccounts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDirectDebitsSpecificAccountsResponse(rsp)
}

// GetAccountDetailWithResponse request returning *GetAccountDetailResponse
func (c *ClientWithResponses) GetAccountDetailWithResponse(ctx context.Context, accountId string, params *GetAccountDetailParams, reqEditors ...RequestEditorFn) (*GetAccountDetailResponse, error) {
	rsp, err := c.GetAccountDetail(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountDetailResponse(rsp)
}

// GetBalanceWithResponse request returning *GetBalanceResponse
func (c *ClientWithResponses) GetBalanceWithResponse(ctx context.Context, accountId string, params *GetBalanceParams, reqEditors ...RequestEditorFn) (*GetBalanceResponse, error) {
	rsp, err := c.GetBalance(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBalanceResponse(rsp)
}

// ListDirectDebitsWithResponse request returning *ListDirectDebitsResponse
func (c *ClientWithResponses) ListDirectDebitsWithResponse(ctx context.Context, accountId string, params *ListDirectDebitsParams, reqEditors ...RequestEditorFn) (*ListDirectDebitsResponse, error) {
	rsp, err := c.ListDirectDebits(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDirectDebitsResponse(rsp)
}

// ListScheduledPaymentsWithResponse request returning *ListScheduledPaymentsResponse
func (c *ClientWithResponses) ListScheduledPaymentsWithResponse(ctx context.Context, accountId string, params *ListScheduledPaymentsParams, reqEditors ...RequestEditorFn) (*ListScheduledPaymentsResponse, error) {
	rsp, err := c.ListScheduledPayments(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListScheduledPaymentsResponse(rsp)
}

// GetTransactionsWithResponse request returning *GetTransactionsResponse
func (c *ClientWithResponses) GetTransactionsWithResponse(ctx context.Context, accountId string, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*GetTransactionsResponse, error) {
	rsp, err := c.GetTransactions(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionsResponse(rsp)
}

// GetTransactionDetailWithResponse request returning *GetTransactionDetailResponse
func (c *ClientWithResponses) GetTransactionDetailWithResponse(ctx context.Context, accountId string, transactionId string, params *GetTransactionDetailParams, reqEditors ...RequestEditorFn) (*GetTransactionDetailResponse, error) {
	rsp, err := c.GetTransactionDetail(ctx, accountId, transactionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionDetailResponse(rsp)
}

// ListPayeesWithResponse request returning *ListPayeesResponse
func (c *ClientWithResponses) ListPayeesWithResponse(ctx context.Context, params *ListPayeesParams, reqEditors ...RequestEditorFn) (*ListPayeesResponse, error) {
	rsp, err := c.ListPayees(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPayeesResponse(rsp)
}

// GetPayeeDetailWithResponse request returning *GetPayeeDetailResponse
func (c *ClientWithResponses) GetPayeeDetailWithResponse(ctx context.Context, payeeId string, params *GetPayeeDetailParams, reqEditors ...RequestEditorFn) (*GetPayeeDetailResponse, error) {
	rsp, err := c.GetPayeeDetail(ctx, payeeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPayeeDetailResponse(rsp)
}

// ListScheduledPaymentsBulkWithResponse request returning *ListScheduledPaymentsBulkResponse
func (c *ClientWithResponses) ListScheduledPaymentsBulkWithResponse(ctx context.Context, params *ListScheduledPaymentsBulkParams, reqEditors ...RequestEditorFn) (*ListScheduledPaymentsBulkResponse, error) {
	rsp, err := c.ListScheduledPaymentsBulk(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListScheduledPaymentsBulkResponse(rsp)
}

// ListScheduledPaymentsSpecificAccountsWithBodyWithResponse request with arbitrary body returning *ListScheduledPaymentsSpecificAccountsResponse
func (c *ClientWithResponses) ListScheduledPaymentsSpecificAccountsWithBodyWithResponse(ctx context.Context, params *ListScheduledPaymentsSpecificAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListScheduledPaymentsSpecificAccountsResponse, error) {
	rsp, err := c.ListScheduledPaymentsSpecificAccountsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListScheduledPaymentsSpecificAccountsResponse(rsp)
}

func (c *ClientWithResponses) ListScheduledPaymentsSpecificAccountsWithResponse(ctx context.Context, params *ListScheduledPaymentsSpecificAccountsParams, body ListScheduledPaymentsSpecificAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListScheduledPaymentsSpecificAccountsResponse, error) {
	rsp, err := c.ListScheduledPaymentsSpecificAccounts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListScheduledPaymentsSpecificAccountsResponse(rsp)
}

// ListProductsWithResponse request returning *ListProductsResponse
func (c *ClientWithResponses) ListProductsWithResponse(ctx context.Context, params *ListProductsParams, reqEditors ...RequestEditorFn) (*ListProductsResponse, error) {
	rsp, err := c.ListProducts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProductsResponse(rsp)
}

// GetProductDetailWithResponse request returning *GetProductDetailResponse
func (c *ClientWithResponses) GetProductDetailWithResponse(ctx context.Context, productId string, params *GetProductDetailParams, reqEditors ...RequestEditorFn) (*GetProductDetailResponse, error) {
	rsp, err := c.GetProductDetail(ctx, productId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductDetailResponse(rsp)
}

// ParseListAccountsResponse parses an HTTP response from a ListAccountsWithResponse call
func ParseListAccountsResponse(rsp *http.Response) (*ListAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseBankingAccountList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListBalancesBulkResponse parses an HTTP response from a ListBalancesBulkWithResponse call
func ParseListBalancesBulkResponse(rsp *http.Response) (*ListBalancesBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBalancesBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseBankingAccountsBalanceList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListBalancesSpecificAccountsResponse parses an HTTP response from a ListBalancesSpecificAccountsWithResponse call
func ParseListBalancesSpecificAccountsResponse(rsp *http.Response) (*ListBalancesSpecificAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBalancesSpecificAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseBankingAccountsBalanceList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListDirectDebitsBulkResponse parses an HTTP response from a ListDirectDebitsBulkWithResponse call
func ParseListDirectDebitsBulkResponse(rsp *http.Response) (*ListDirectDebitsBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDirectDebitsBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseBankingDirectDebitAuthorisationList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListDirectDebitsSpecificAccountsResponse parses an HTTP response from a ListDirectDebitsSpecificAccountsWithResponse call
func ParseListDirectDebitsSpecificAccountsResponse(rsp *http.Response) (*ListDirectDebitsSpecificAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDirectDebitsSpecificAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseBankingDirectDebitAuthorisationList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetAccountDetailResponse parses an HTTP response from a GetAccountDetailWithResponse call
func ParseGetAccountDetailResponse(rsp *http.Response) (*GetAccountDetailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountDetailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseBankingAccountByIdV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetBalanceResponse parses an HTTP response from a GetBalanceWithResponse call
func ParseGetBalanceResponse(rsp *http.Response) (*GetBalanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBalanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseBankingAccountsBalanceById
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseListDirectDebitsResponse parses an HTTP response from a ListDirectDebitsWithResponse call
func ParseListDirectDebitsResponse(rsp *http.Response) (*ListDirectDebitsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDirectDebitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseBankingDirectDebitAuthorisationList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListScheduledPaymentsResponse parses an HTTP response from a ListScheduledPaymentsWithResponse call
func ParseListScheduledPaymentsResponse(rsp *http.Response) (*ListScheduledPaymentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListScheduledPaymentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseBankingScheduledPaymentsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetTransactionsResponse parses an HTTP response from a GetTransactionsWithResponse call
func ParseGetTransactionsResponse(rsp *http.Response) (*GetTransactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseBankingTransactionList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetTransactionDetailResponse parses an HTTP response from a GetTransactionDetailWithResponse call
func ParseGetTransactionDetailResponse(rsp *http.Response) (*GetTransactionDetailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionDetailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseBankingTransactionById
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseListPayeesResponse parses an HTTP response from a ListPayeesWithResponse call
func ParseListPayeesResponse(rsp *http.Response) (*ListPayeesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPayeesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseBankingPayeeListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetPayeeDetailResponse parses an HTTP response from a GetPayeeDetailWithResponse call
func ParseGetPayeeDetailResponse(rsp *http.Response) (*GetPayeeDetailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPayeeDetailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseBankingPayeeByIdV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListScheduledPaymentsBulkResponse parses an HTTP response from a ListScheduledPaymentsBulkWithResponse call
func ParseListScheduledPaymentsBulkResponse(rsp *http.Response) (*ListScheduledPaymentsBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListScheduledPaymentsBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseBankingScheduledPaymentsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListScheduledPaymentsSpecificAccountsResponse parses an HTTP response from a ListScheduledPaymentsSpecificAccountsWithResponse call
func ParseListScheduledPaymentsSpecificAccountsResponse(rsp *http.Response) (*ListScheduledPaymentsSpecificAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListScheduledPaymentsSpecificAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseBankingScheduledPaymentsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListProductsResponse parses an HTTP response from a ListProductsWithResponse call
func ParseListProductsResponse(rsp *http.Response) (*ListProductsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProductsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseBankingProductListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetProductDetailResponse parses an HTTP response from a GetProductDetailWithResponse call
func ParseGetProductDetailResponse(rsp *http.Response) (*GetProductDetailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductDetailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseBankingProductByIdV4
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}
