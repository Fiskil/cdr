// Package common provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package common

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// Defines values for CommonEmailAddressPurpose.
const (
	CommonEmailAddressPurposeHOME        CommonEmailAddressPurpose = "HOME"
	CommonEmailAddressPurposeOTHER       CommonEmailAddressPurpose = "OTHER"
	CommonEmailAddressPurposeUNSPECIFIED CommonEmailAddressPurpose = "UNSPECIFIED"
	CommonEmailAddressPurposeWORK        CommonEmailAddressPurpose = "WORK"
)

// Defines values for CommonOrganisationIndustryCodeVersion.
const (
	CommonOrganisationIndustryCodeVersionANZSIC129202006V10 CommonOrganisationIndustryCodeVersion = "ANZSIC_1292.0_2006_V1.0"
	CommonOrganisationIndustryCodeVersionANZSIC129202006V20 CommonOrganisationIndustryCodeVersion = "ANZSIC_1292.0_2006_V2.0"
)

// Defines values for CommonOrganisationOrganisationType.
const (
	CommonOrganisationOrganisationTypeCOMPANY          CommonOrganisationOrganisationType = "COMPANY"
	CommonOrganisationOrganisationTypeGOVERNMENTENTITY CommonOrganisationOrganisationType = "GOVERNMENT_ENTITY"
	CommonOrganisationOrganisationTypeOTHER            CommonOrganisationOrganisationType = "OTHER"
	CommonOrganisationOrganisationTypePARTNERSHIP      CommonOrganisationOrganisationType = "PARTNERSHIP"
	CommonOrganisationOrganisationTypeSOLETRADER       CommonOrganisationOrganisationType = "SOLE_TRADER"
	CommonOrganisationOrganisationTypeTRUST            CommonOrganisationOrganisationType = "TRUST"
)

// Defines values for CommonOrganisationDetailV2IndustryCodeVersion.
const (
	CommonOrganisationDetailV2IndustryCodeVersionANZSIC129202006V10 CommonOrganisationDetailV2IndustryCodeVersion = "ANZSIC_1292.0_2006_V1.0"
	CommonOrganisationDetailV2IndustryCodeVersionANZSIC129202006V20 CommonOrganisationDetailV2IndustryCodeVersion = "ANZSIC_1292.0_2006_V2.0"
)

// Defines values for CommonOrganisationDetailV2OrganisationType.
const (
	CommonOrganisationDetailV2OrganisationTypeCOMPANY          CommonOrganisationDetailV2OrganisationType = "COMPANY"
	CommonOrganisationDetailV2OrganisationTypeGOVERNMENTENTITY CommonOrganisationDetailV2OrganisationType = "GOVERNMENT_ENTITY"
	CommonOrganisationDetailV2OrganisationTypeOTHER            CommonOrganisationDetailV2OrganisationType = "OTHER"
	CommonOrganisationDetailV2OrganisationTypePARTNERSHIP      CommonOrganisationDetailV2OrganisationType = "PARTNERSHIP"
	CommonOrganisationDetailV2OrganisationTypeSOLETRADER       CommonOrganisationDetailV2OrganisationType = "SOLE_TRADER"
	CommonOrganisationDetailV2OrganisationTypeTRUST            CommonOrganisationDetailV2OrganisationType = "TRUST"
)

// Defines values for CommonPersonOccupationCodeVersion.
const (
	CommonPersonOccupationCodeVersionANZSCO122002006V10 CommonPersonOccupationCodeVersion = "ANZSCO_1220.0_2006_V1.0"
	CommonPersonOccupationCodeVersionANZSCO122002006V11 CommonPersonOccupationCodeVersion = "ANZSCO_1220.0_2006_V1.1"
	CommonPersonOccupationCodeVersionANZSCO122002013V12 CommonPersonOccupationCodeVersion = "ANZSCO_1220.0_2013_V1.2"
	CommonPersonOccupationCodeVersionANZSCO122002013V13 CommonPersonOccupationCodeVersion = "ANZSCO_1220.0_2013_V1.3"
)

// Defines values for CommonPersonDetailV2OccupationCodeVersion.
const (
	CommonPersonDetailV2OccupationCodeVersionANZSCO122002006V10 CommonPersonDetailV2OccupationCodeVersion = "ANZSCO_1220.0_2006_V1.0"
	CommonPersonDetailV2OccupationCodeVersionANZSCO122002006V11 CommonPersonDetailV2OccupationCodeVersion = "ANZSCO_1220.0_2006_V1.1"
	CommonPersonDetailV2OccupationCodeVersionANZSCO122002013V12 CommonPersonDetailV2OccupationCodeVersion = "ANZSCO_1220.0_2013_V1.2"
	CommonPersonDetailV2OccupationCodeVersionANZSCO122002013V13 CommonPersonDetailV2OccupationCodeVersion = "ANZSCO_1220.0_2013_V1.3"
)

// Defines values for CommonPhoneNumberPurpose.
const (
	CommonPhoneNumberPurposeHOME          CommonPhoneNumberPurpose = "HOME"
	CommonPhoneNumberPurposeINTERNATIONAL CommonPhoneNumberPurpose = "INTERNATIONAL"
	CommonPhoneNumberPurposeMOBILE        CommonPhoneNumberPurpose = "MOBILE"
	CommonPhoneNumberPurposeOTHER         CommonPhoneNumberPurpose = "OTHER"
	CommonPhoneNumberPurposeUNSPECIFIED   CommonPhoneNumberPurpose = "UNSPECIFIED"
	CommonPhoneNumberPurposeWORK          CommonPhoneNumberPurpose = "WORK"
)

// Defines values for CommonPhysicalAddressAddressUType.
const (
	CommonPhysicalAddressAddressUTypePaf    CommonPhysicalAddressAddressUType = "paf"
	CommonPhysicalAddressAddressUTypeSimple CommonPhysicalAddressAddressUType = "simple"
)

// Defines values for CommonPhysicalAddressWithPurposeAddressUType.
const (
	CommonPhysicalAddressWithPurposeAddressUTypePaf    CommonPhysicalAddressWithPurposeAddressUType = "paf"
	CommonPhysicalAddressWithPurposeAddressUTypeSimple CommonPhysicalAddressWithPurposeAddressUType = "simple"
)

// Defines values for CommonPhysicalAddressWithPurposePurpose.
const (
	CommonPhysicalAddressWithPurposePurposeMAIL       CommonPhysicalAddressWithPurposePurpose = "MAIL"
	CommonPhysicalAddressWithPurposePurposeOTHER      CommonPhysicalAddressWithPurposePurpose = "OTHER"
	CommonPhysicalAddressWithPurposePurposePHYSICAL   CommonPhysicalAddressWithPurposePurpose = "PHYSICAL"
	CommonPhysicalAddressWithPurposePurposeREGISTERED CommonPhysicalAddressWithPurposePurpose = "REGISTERED"
	CommonPhysicalAddressWithPurposePurposeWORK       CommonPhysicalAddressWithPurposePurpose = "WORK"
)

// Defines values for CommonPhysicalAddressWithPurposeAllOfPurpose.
const (
	CommonPhysicalAddressWithPurposeAllOfPurposeMAIL       CommonPhysicalAddressWithPurposeAllOfPurpose = "MAIL"
	CommonPhysicalAddressWithPurposeAllOfPurposeOTHER      CommonPhysicalAddressWithPurposeAllOfPurpose = "OTHER"
	CommonPhysicalAddressWithPurposeAllOfPurposePHYSICAL   CommonPhysicalAddressWithPurposeAllOfPurpose = "PHYSICAL"
	CommonPhysicalAddressWithPurposeAllOfPurposeREGISTERED CommonPhysicalAddressWithPurposeAllOfPurpose = "REGISTERED"
	CommonPhysicalAddressWithPurposeAllOfPurposeWORK       CommonPhysicalAddressWithPurposeAllOfPurpose = "WORK"
)

// Defines values for ResponseCommonCustomerDetailV2DataCustomerUType.
const (
	ResponseCommonCustomerDetailV2DataCustomerUTypeOrganisation ResponseCommonCustomerDetailV2DataCustomerUType = "organisation"
	ResponseCommonCustomerDetailV2DataCustomerUTypePerson       ResponseCommonCustomerDetailV2DataCustomerUType = "person"
)

// Defines values for ResponseCommonCustomerDataCustomerUType.
const (
	ResponseCommonCustomerDataCustomerUTypeOrganisation ResponseCommonCustomerDataCustomerUType = "organisation"
	ResponseCommonCustomerDataCustomerUTypePerson       ResponseCommonCustomerDataCustomerUType = "person"
)

// Defines values for ResponseCommonDiscoveryStatusDataStatus.
const (
	OK              ResponseCommonDiscoveryStatusDataStatus = "OK"
	PARTIALFAILURE  ResponseCommonDiscoveryStatusDataStatus = "PARTIAL_FAILURE"
	SCHEDULEDOUTAGE ResponseCommonDiscoveryStatusDataStatus = "SCHEDULED_OUTAGE"
	UNAVAILABLE     ResponseCommonDiscoveryStatusDataStatus = "UNAVAILABLE"
)

// CommonEmailAddress defines model for CommonEmailAddress.
type CommonEmailAddress struct {
	// Address A correctly formatted email address, as defined by the addr-spec format in **[[RFC5322]](#nref-RFC5322)**
	Address string `json:"address"`

	// IsPreferred May be true for one and only one email record in the collection. Denotes the default email address
	IsPreferred *bool `json:"isPreferred,omitempty"`

	// Purpose The purpose for the email, as specified by the customer (Enumeration)
	Purpose CommonEmailAddressPurpose `json:"purpose"`
}

// CommonEmailAddressPurpose The purpose for the email, as specified by the customer (Enumeration)
type CommonEmailAddressPurpose string

// CommonOrganisation defines model for CommonOrganisation.
type CommonOrganisation struct {
	// Abn Australian Business Number for the organisation
	Abn *string `json:"abn,omitempty"`

	// Acn Australian Company Number for the organisation. Required only if an ACN is applicable for the organisation type
	Acn *string `json:"acn,omitempty"`

	// AgentFirstName The first name of the individual providing access on behalf of the organisation. For people with single names this field need not be present.  The single name should be in the lastName field
	AgentFirstName *string `json:"agentFirstName,omitempty"`

	// AgentLastName The last name of the individual providing access on behalf of the organisation. For people with single names the single name should be in this field
	AgentLastName string `json:"agentLastName"`

	// AgentRole The role of the individual identified as the agent who is providing authorisation.  Expected to be used for display. Default to Unspecified if the role is not known
	AgentRole string `json:"agentRole"`

	// BusinessName Name of the organisation
	BusinessName string `json:"businessName"`

	// EstablishmentDate The date the organisation described was established
	EstablishmentDate *string `json:"establishmentDate,omitempty"`

	// IndustryCode A valid [ANZSIC](http://www.abs.gov.au/ANZSIC) code for the organisation. If the industry code held by the data holder is not one of the supported [ANZSIC](http://www.abs.gov.au/ANZSIC) versions, then it must not be supplied.
	IndustryCode *string `json:"industryCode,omitempty"`

	// IndustryCodeVersion The applicable [ANZSIC](http://www.abs.gov.au/ANZSIC) release version of the industry code provided. Should only be supplied if ``industryCode`` is also supplied. If ``industryCode`` is supplied but ``industryCodeVersion`` is absent, default is ``ANZSIC_1292.0_2006_V2.0``
	IndustryCodeVersion *CommonOrganisationIndustryCodeVersion `json:"industryCodeVersion,omitempty"`

	// IsACNCRegistered True if registered with the ACNC.  False if not. Absent or null if not confirmed.
	IsACNCRegistered *bool `json:"isACNCRegistered,omitempty"`

	// LastUpdateTime The date and time that this record was last updated by the customer. If no update has occurred then this date should reflect the initial creation date for the data
	LastUpdateTime *string `json:"lastUpdateTime,omitempty"`

	// LegalName Legal name, if different to the business name
	LegalName *string `json:"legalName,omitempty"`

	// OrganisationType Legal organisation type
	OrganisationType CommonOrganisationOrganisationType `json:"organisationType"`

	// RegisteredCountry Enumeration with values from [ISO 3166 Alpha-3](https://www.iso.org/iso-3166-country-codes.html) country codes.  Assumed to be AUS if absent
	RegisteredCountry *string `json:"registeredCountry,omitempty"`

	// ShortName Short name used for communication, if different to the business name
	ShortName *string `json:"shortName,omitempty"`
}

// CommonOrganisationIndustryCodeVersion The applicable [ANZSIC](http://www.abs.gov.au/ANZSIC) release version of the industry code provided. Should only be supplied if “industryCode“ is also supplied. If “industryCode“ is supplied but “industryCodeVersion“ is absent, default is “ANZSIC_1292.0_2006_V2.0“
type CommonOrganisationIndustryCodeVersion string

// CommonOrganisationOrganisationType Legal organisation type
type CommonOrganisationOrganisationType string

// CommonOrganisationDetailV2 defines model for CommonOrganisationDetailV2.
type CommonOrganisationDetailV2 struct {
	// Abn Australian Business Number for the organisation
	Abn *string `json:"abn,omitempty"`

	// Acn Australian Company Number for the organisation. Required only if an ACN is applicable for the organisation type
	Acn *string `json:"acn,omitempty"`

	// AgentFirstName The first name of the individual providing access on behalf of the organisation. For people with single names this field need not be present.  The single name should be in the lastName field
	AgentFirstName *string `json:"agentFirstName,omitempty"`

	// AgentLastName The last name of the individual providing access on behalf of the organisation. For people with single names the single name should be in this field
	AgentLastName string `json:"agentLastName"`

	// AgentRole The role of the individual identified as the agent who is providing authorisation.  Expected to be used for display. Default to Unspecified if the role is not known
	AgentRole string `json:"agentRole"`

	// BusinessName Name of the organisation
	BusinessName string `json:"businessName"`

	// EstablishmentDate The date the organisation described was established
	EstablishmentDate *string `json:"establishmentDate,omitempty"`

	// IndustryCode A valid [ANZSIC](http://www.abs.gov.au/ANZSIC) code for the organisation. If the industry code held by the data holder is not one of the supported [ANZSIC](http://www.abs.gov.au/ANZSIC) versions, then it must not be supplied.
	IndustryCode *string `json:"industryCode,omitempty"`

	// IndustryCodeVersion The applicable [ANZSIC](http://www.abs.gov.au/ANZSIC) release version of the industry code provided. Should only be supplied if ``industryCode`` is also supplied. If ``industryCode`` is supplied but ``industryCodeVersion`` is absent, default is ``ANZSIC_1292.0_2006_V2.0``
	IndustryCodeVersion *CommonOrganisationDetailV2IndustryCodeVersion `json:"industryCodeVersion,omitempty"`

	// IsACNCRegistered True if registered with the ACNC.  False if not. Absent or null if not confirmed.
	IsACNCRegistered *bool `json:"isACNCRegistered,omitempty"`

	// LastUpdateTime The date and time that this record was last updated by the customer. If no update has occurred then this date should reflect the initial creation date for the data
	LastUpdateTime *string `json:"lastUpdateTime,omitempty"`

	// LegalName Legal name, if different to the business name
	LegalName *string `json:"legalName,omitempty"`

	// OrganisationType Legal organisation type
	OrganisationType CommonOrganisationDetailV2OrganisationType `json:"organisationType"`

	// PhysicalAddresses Array is mandatory but may be empty if no valid addresses are held. One and only one address may have the purpose of REGISTERED. Zero or one, and no more than one, record may have the purpose of MAIL. If zero then the REGISTERED address is to be used for mail
	PhysicalAddresses []CommonPhysicalAddressWithPurpose `json:"physicalAddresses"`

	// RegisteredCountry Enumeration with values from [ISO 3166 Alpha-3](https://www.iso.org/iso-3166-country-codes.html) country codes.  Assumed to be AUS if absent
	RegisteredCountry *string `json:"registeredCountry,omitempty"`

	// ShortName Short name used for communication, if different to the business name
	ShortName *string `json:"shortName,omitempty"`
}

// CommonOrganisationDetailV2IndustryCodeVersion The applicable [ANZSIC](http://www.abs.gov.au/ANZSIC) release version of the industry code provided. Should only be supplied if “industryCode“ is also supplied. If “industryCode“ is supplied but “industryCodeVersion“ is absent, default is “ANZSIC_1292.0_2006_V2.0“
type CommonOrganisationDetailV2IndustryCodeVersion string

// CommonOrganisationDetailV2OrganisationType Legal organisation type
type CommonOrganisationDetailV2OrganisationType string

// CommonOrganisationDetailV2AllOf defines model for CommonOrganisationDetailV2_allOf.
type CommonOrganisationDetailV2AllOf struct {
	// PhysicalAddresses Array is mandatory but may be empty if no valid addresses are held. One and only one address may have the purpose of REGISTERED. Zero or one, and no more than one, record may have the purpose of MAIL. If zero then the REGISTERED address is to be used for mail
	PhysicalAddresses []CommonPhysicalAddressWithPurpose `json:"physicalAddresses"`
}

// CommonPAFAddress Australian address formatted according to the file format defined by the [PAF file format](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf)
type CommonPAFAddress struct {
	// BuildingName1 Building/Property name 1
	BuildingName1 *string `json:"buildingName1,omitempty"`

	// BuildingName2 Building/Property name 2
	BuildingName2 *string `json:"buildingName2,omitempty"`

	// Dpid Unique identifier for an address as defined by Australia Post.  Also known as Delivery Point Identifier
	Dpid *string `json:"dpid,omitempty"`

	// FlatUnitNumber Unit number (including suffix, if applicable)
	FlatUnitNumber *string `json:"flatUnitNumber,omitempty"`

	// FlatUnitType Type of flat or unit for the address
	FlatUnitType *string `json:"flatUnitType,omitempty"`

	// FloorLevelNumber Floor or level number (including alpha characters)
	FloorLevelNumber *string `json:"floorLevelNumber,omitempty"`

	// FloorLevelType Type of floor or level for the address
	FloorLevelType *string `json:"floorLevelType,omitempty"`

	// LocalityName Full name of locality
	LocalityName string `json:"localityName"`

	// LotNumber Allotment number for the address
	LotNumber *string `json:"lotNumber,omitempty"`

	// PostalDeliveryNumber Postal delivery number if the address is a postal delivery type
	PostalDeliveryNumber *int `json:"postalDeliveryNumber,omitempty"`

	// PostalDeliveryNumberPrefix Postal delivery number prefix related to the postal delivery number
	PostalDeliveryNumberPrefix *string `json:"postalDeliveryNumberPrefix,omitempty"`

	// PostalDeliveryNumberSuffix Postal delivery number suffix related to the postal delivery number
	PostalDeliveryNumberSuffix *string `json:"postalDeliveryNumberSuffix,omitempty"`

	// PostalDeliveryType Postal delivery type. (eg. PO BOX). Valid enumeration defined by Australia Post PAF code file
	PostalDeliveryType *string `json:"postalDeliveryType,omitempty"`

	// Postcode Postcode for the locality
	Postcode string `json:"postcode"`

	// State State in which the address belongs. Valid enumeration defined by Australia Post PAF code file [State Type Abbreviation](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf). NSW, QLD, VIC, NT, WA, SA, TAS, ACT, AAT
	State string `json:"state"`

	// StreetName The name of the street
	StreetName *string `json:"streetName,omitempty"`

	// StreetSuffix The street type suffix. Valid enumeration defined by Australia Post PAF code file
	StreetSuffix *string `json:"streetSuffix,omitempty"`

	// StreetType The street type. Valid enumeration defined by Australia Post PAF code file
	StreetType *string `json:"streetType,omitempty"`

	// ThoroughfareNumber1 Thoroughfare number for a property (first number in a property ranged address)
	ThoroughfareNumber1 *int `json:"thoroughfareNumber1,omitempty"`

	// ThoroughfareNumber1Suffix Suffix for the thoroughfare number. Only relevant is thoroughfareNumber1 is populated
	ThoroughfareNumber1Suffix *string `json:"thoroughfareNumber1Suffix,omitempty"`

	// ThoroughfareNumber2 Second thoroughfare number (only used if the property has a ranged address eg 23-25)
	ThoroughfareNumber2 *int `json:"thoroughfareNumber2,omitempty"`

	// ThoroughfareNumber2Suffix Suffix for the second thoroughfare number. Only relevant is thoroughfareNumber2 is populated
	ThoroughfareNumber2Suffix *string `json:"thoroughfareNumber2Suffix,omitempty"`
}

// CommonPerson defines model for CommonPerson.
type CommonPerson struct {
	// FirstName For people with single names this field need not be present. The single name should be in the lastName field. Where a data holder cannot determine first and middle names from a collection of given names, a single string representing all given names MAY be provided.
	FirstName *string `json:"firstName,omitempty"`

	// LastName For people with single names the single name should be in this field
	LastName string `json:"lastName"`

	// LastUpdateTime The date and time that this record was last updated by the customer.  If no update has occurred then this date should reflect the initial creation date for the data
	LastUpdateTime *string `json:"lastUpdateTime,omitempty"`

	// MiddleNames Field is mandatory but array may be empty
	MiddleNames []string `json:"middleNames"`

	// OccupationCode Value is a valid **[[ANZSCO]](#iref-ANZSCO)** Standard Occupation classification code. If the occupation code held by the data holder is not one of the supported **[[ANZSCO]](#iref-ANZSCO)** versions, then it must not be supplied.
	OccupationCode *string `json:"occupationCode,omitempty"`

	// OccupationCodeVersion The applicable **[[ANZSCO]](#iref-ANZSCO)** release version of the occupation code provided. Mandatory if an ``occupationCode`` is supplied. If ``occupationCode`` is supplied but ``occupationCodeVersion`` is absent, default is ``ANZSCO_1220.0_2013_V1.2``
	OccupationCodeVersion *CommonPersonOccupationCodeVersion `json:"occupationCodeVersion,omitempty"`

	// Prefix Also known as title or salutation.  The prefix to the name (e.g. Mr, Mrs, Ms, Miss, Sir, etc)
	Prefix *string `json:"prefix,omitempty"`

	// Suffix Used for a trailing suffix to the name (e.g. Jr)
	Suffix *string `json:"suffix,omitempty"`
}

// CommonPersonOccupationCodeVersion The applicable **[[ANZSCO]](#iref-ANZSCO)** release version of the occupation code provided. Mandatory if an “occupationCode“ is supplied. If “occupationCode“ is supplied but “occupationCodeVersion“ is absent, default is “ANZSCO_1220.0_2013_V1.2“
type CommonPersonOccupationCodeVersion string

// CommonPersonDetailV2 defines model for CommonPersonDetailV2.
type CommonPersonDetailV2 struct {
	// EmailAddresses May be empty
	EmailAddresses []CommonEmailAddress `json:"emailAddresses"`

	// FirstName For people with single names this field need not be present. The single name should be in the lastName field. Where a data holder cannot determine first and middle names from a collection of given names, a single string representing all given names MAY be provided.
	FirstName *string `json:"firstName,omitempty"`

	// LastName For people with single names the single name should be in this field
	LastName string `json:"lastName"`

	// LastUpdateTime The date and time that this record was last updated by the customer.  If no update has occurred then this date should reflect the initial creation date for the data
	LastUpdateTime *string `json:"lastUpdateTime,omitempty"`

	// MiddleNames Field is mandatory but array may be empty
	MiddleNames []string `json:"middleNames"`

	// OccupationCode Value is a valid **[[ANZSCO]](#iref-ANZSCO)** Standard Occupation classification code. If the occupation code held by the data holder is not one of the supported **[[ANZSCO]](#iref-ANZSCO)** versions, then it must not be supplied.
	OccupationCode *string `json:"occupationCode,omitempty"`

	// OccupationCodeVersion The applicable **[[ANZSCO]](#iref-ANZSCO)** release version of the occupation code provided. Mandatory if an ``occupationCode`` is supplied. If ``occupationCode`` is supplied but ``occupationCodeVersion`` is absent, default is ``ANZSCO_1220.0_2013_V1.2``
	OccupationCodeVersion *CommonPersonDetailV2OccupationCodeVersion `json:"occupationCodeVersion,omitempty"`

	// PhoneNumbers Array is mandatory but may be empty if no phone numbers are held
	PhoneNumbers []CommonPhoneNumber `json:"phoneNumbers"`

	// PhysicalAddresses Array is mandatory but may be empty if no valid addresses are held. One and only one address may have the purpose of REGISTERED. Zero or one, and no more than one, record may have the purpose of MAIL. If zero then the REGISTERED address is to be used for mail
	PhysicalAddresses []CommonPhysicalAddressWithPurpose `json:"physicalAddresses"`

	// Prefix Also known as title or salutation.  The prefix to the name (e.g. Mr, Mrs, Ms, Miss, Sir, etc)
	Prefix *string `json:"prefix,omitempty"`

	// Suffix Used for a trailing suffix to the name (e.g. Jr)
	Suffix *string `json:"suffix,omitempty"`
}

// CommonPersonDetailV2OccupationCodeVersion The applicable **[[ANZSCO]](#iref-ANZSCO)** release version of the occupation code provided. Mandatory if an “occupationCode“ is supplied. If “occupationCode“ is supplied but “occupationCodeVersion“ is absent, default is “ANZSCO_1220.0_2013_V1.2“
type CommonPersonDetailV2OccupationCodeVersion string

// CommonPersonDetailV2AllOf defines model for CommonPersonDetailV2_allOf.
type CommonPersonDetailV2AllOf struct {
	// EmailAddresses May be empty
	EmailAddresses []CommonEmailAddress `json:"emailAddresses"`

	// PhoneNumbers Array is mandatory but may be empty if no phone numbers are held
	PhoneNumbers []CommonPhoneNumber `json:"phoneNumbers"`

	// PhysicalAddresses Array is mandatory but may be empty if no valid addresses are held. One and only one address may have the purpose of REGISTERED. Zero or one, and no more than one, record may have the purpose of MAIL. If zero then the REGISTERED address is to be used for mail
	PhysicalAddresses []CommonPhysicalAddressWithPurpose `json:"physicalAddresses"`
}

// CommonPhoneNumber defines model for CommonPhoneNumber.
type CommonPhoneNumber struct {
	// AreaCode Required for non Mobile Phones, if field is present and refers to Australian code - the leading 0 should be omitted.
	AreaCode *string `json:"areaCode,omitempty"`

	// CountryCode If absent, assumed to be Australia (+61). The + should be included
	CountryCode *string `json:"countryCode,omitempty"`

	// Extension An extension number (if applicable)
	Extension *string `json:"extension,omitempty"`

	// FullNumber Fully formatted phone number with country code, area code, number and extension incorporated. Formatted according to section 5.1.4. of **[[RFC3966]](#iref-RFC3966)**
	FullNumber string `json:"fullNumber"`

	// IsPreferred May be true for one and only one entry to indicate the preferred phone number. Assumed to be 'false' if not present
	IsPreferred *bool `json:"isPreferred,omitempty"`

	// Number The actual phone number, with leading zeros as appropriate
	Number string `json:"number"`

	// Purpose The purpose of the number as specified by the customer
	Purpose CommonPhoneNumberPurpose `json:"purpose"`
}

// CommonPhoneNumberPurpose The purpose of the number as specified by the customer
type CommonPhoneNumberPurpose string

// CommonPhysicalAddress defines model for CommonPhysicalAddress.
type CommonPhysicalAddress struct {
	// AddressUType The type of address object present
	AddressUType CommonPhysicalAddressAddressUType `json:"addressUType"`

	// Paf Australian address formatted according to the file format defined by the [PAF file format](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf)
	Paf    *CommonPAFAddress    `json:"paf,omitempty"`
	Simple *CommonSimpleAddress `json:"simple,omitempty"`
}

// CommonPhysicalAddressAddressUType The type of address object present
type CommonPhysicalAddressAddressUType string

// CommonPhysicalAddressWithPurpose defines model for CommonPhysicalAddressWithPurpose.
type CommonPhysicalAddressWithPurpose struct {
	// AddressUType The type of address object present
	AddressUType CommonPhysicalAddressWithPurposeAddressUType `json:"addressUType"`

	// Paf Australian address formatted according to the file format defined by the [PAF file format](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf)
	Paf *CommonPAFAddress `json:"paf,omitempty"`

	// Purpose Enumeration of values indicating the purpose of the physical address
	Purpose CommonPhysicalAddressWithPurposePurpose `json:"purpose"`
	Simple  *CommonSimpleAddress                    `json:"simple,omitempty"`
}

// CommonPhysicalAddressWithPurposeAddressUType The type of address object present
type CommonPhysicalAddressWithPurposeAddressUType string

// CommonPhysicalAddressWithPurposePurpose Enumeration of values indicating the purpose of the physical address
type CommonPhysicalAddressWithPurposePurpose string

// CommonPhysicalAddressWithPurposeAllOf defines model for CommonPhysicalAddressWithPurpose_allOf.
type CommonPhysicalAddressWithPurposeAllOf struct {
	// Purpose Enumeration of values indicating the purpose of the physical address
	Purpose CommonPhysicalAddressWithPurposeAllOfPurpose `json:"purpose"`
}

// CommonPhysicalAddressWithPurposeAllOfPurpose Enumeration of values indicating the purpose of the physical address
type CommonPhysicalAddressWithPurposeAllOfPurpose string

// CommonSimpleAddress defines model for CommonSimpleAddress.
type CommonSimpleAddress struct {
	// AddressLine1 First line of the standard address object
	AddressLine1 string `json:"addressLine1"`

	// AddressLine2 Second line of the standard address object
	AddressLine2 *string `json:"addressLine2,omitempty"`

	// AddressLine3 Third line of the standard address object
	AddressLine3 *string `json:"addressLine3,omitempty"`

	// City Name of the city or locality
	City string `json:"city"`

	// Country A valid [ISO 3166 Alpha-3](https://www.iso.org/iso-3166-country-codes.html) country code. Australia (AUS) is assumed if country is not present.
	Country *string `json:"country,omitempty"`

	// MailingName Name of the individual or business formatted for inclusion in an address used for physical mail
	MailingName *string `json:"mailingName,omitempty"`

	// Postcode Mandatory for Australian addresses
	Postcode *string `json:"postcode,omitempty"`

	// State Free text if the country is not Australia. If country is Australia then must be one of the values defined by the [State Type Abbreviation](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf) in the PAF file format. NSW, QLD, VIC, NT, WA, SA, TAS, ACT, AAT
	State string `json:"state"`
}

// DiscoveryOutage defines model for DiscoveryOutage.
type DiscoveryOutage struct {
	// Duration Planned duration of the outage. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	Duration string `json:"duration"`

	// Explanation Provides an explanation of the current outage that can be displayed to an end customer
	Explanation string `json:"explanation"`

	// IsPartial Flag that indicates, if present and set to true, that the outage is only partial meaning that only a subset of normally available end points will be affected by the outage
	IsPartial *bool `json:"isPartial,omitempty"`

	// OutageTime Date and time that the outage is scheduled to begin
	OutageTime string `json:"outageTime"`
}

// Links defines model for Links.
type Links struct {
	// Self Fully qualified link that generated the current response document
	Self string `json:"self"`
}

// Meta defines model for Meta.
type Meta = map[string]interface{}

// MetaError Additional data for customised error codes
type MetaError struct {
	// Urn The CDR error code URN which the application-specific error code extends. Mandatory if the error `code` is an application-specific error rather than a standardised error code.
	Urn *string `json:"urn,omitempty"`
}

// ResponseCommonCustomer defines model for ResponseCommonCustomer.
type ResponseCommonCustomer struct {
	Data  ResponseCommonCustomerData `json:"data"`
	Links Links                      `json:"links"`
	Meta  *Meta                      `json:"meta,omitempty"`
}

// ResponseCommonCustomerDetailV2 defines model for ResponseCommonCustomerDetailV2.
type ResponseCommonCustomerDetailV2 struct {
	Data  ResponseCommonCustomerDetailV2Data `json:"data"`
	Links Links                              `json:"links"`
	Meta  *Meta                              `json:"meta,omitempty"`
}

// ResponseCommonCustomerDetailV2Data defines model for ResponseCommonCustomerDetailV2_data.
type ResponseCommonCustomerDetailV2Data struct {
	// CustomerUType The type of customer object that is present
	CustomerUType ResponseCommonCustomerDetailV2DataCustomerUType `json:"customerUType"`
	Organisation  *CommonOrganisationDetailV2                     `json:"organisation,omitempty"`
	Person        *CommonPersonDetailV2                           `json:"person,omitempty"`
}

// ResponseCommonCustomerDetailV2DataCustomerUType The type of customer object that is present
type ResponseCommonCustomerDetailV2DataCustomerUType string

// ResponseCommonCustomerData defines model for ResponseCommonCustomer_data.
type ResponseCommonCustomerData struct {
	// CustomerUType The type of customer object that is present
	CustomerUType ResponseCommonCustomerDataCustomerUType `json:"customerUType"`
	Organisation  *CommonOrganisation                     `json:"organisation,omitempty"`
	Person        *CommonPerson                           `json:"person,omitempty"`
}

// ResponseCommonCustomerDataCustomerUType The type of customer object that is present
type ResponseCommonCustomerDataCustomerUType string

// ResponseCommonDiscoveryStatus defines model for ResponseCommonDiscoveryStatus.
type ResponseCommonDiscoveryStatus struct {
	Data  ResponseCommonDiscoveryStatusData `json:"data"`
	Links Links                             `json:"links"`
	Meta  *Meta                             `json:"meta,omitempty"`
}

// ResponseCommonDiscoveryStatusData defines model for ResponseCommonDiscoveryStatus_data.
type ResponseCommonDiscoveryStatusData struct {
	// DetectionTime The date and time that the current outage was detected. Should only be present if the status property is PARTIAL_FAILURE or UNAVAILABLE
	DetectionTime *string `json:"detectionTime,omitempty"`

	// ExpectedResolutionTime The date and time that full service is expected to resume (if known). Should not be present if the status property has a value of OK.
	ExpectedResolutionTime *string `json:"expectedResolutionTime,omitempty"`

	// Explanation Provides an explanation of the current outage that can be displayed to an end customer. Mandatory if the status property is any value other than OK
	Explanation *string `json:"explanation,omitempty"`

	// Status Enumeration with values. OK (implementation is fully functional). PARTIAL_FAILURE (one or more end points are unexpectedly unavailable). UNAVAILABLE (the full implementation is unexpectedly unavailable). SCHEDULED_OUTAGE (an advertised outage is in effect)
	Status ResponseCommonDiscoveryStatusDataStatus `json:"status"`

	// UpdateTime The date and time that this status was last updated by the Data Holder.
	UpdateTime string `json:"updateTime"`
}

// ResponseCommonDiscoveryStatusDataStatus Enumeration with values. OK (implementation is fully functional). PARTIAL_FAILURE (one or more end points are unexpectedly unavailable). UNAVAILABLE (the full implementation is unexpectedly unavailable). SCHEDULED_OUTAGE (an advertised outage is in effect)
type ResponseCommonDiscoveryStatusDataStatus string

// ResponseDiscoveryOutagesList defines model for ResponseDiscoveryOutagesList.
type ResponseDiscoveryOutagesList struct {
	Data  ResponseDiscoveryOutagesListData `json:"data"`
	Links Links                            `json:"links"`
	Meta  *Meta                            `json:"meta,omitempty"`
}

// ResponseDiscoveryOutagesListData defines model for ResponseDiscoveryOutagesList_data.
type ResponseDiscoveryOutagesListData struct {
	// Outages List of scheduled outages. Property is mandatory but may contain and empty list if no outages are scheduled
	Outages []DiscoveryOutage `json:"outages"`
}

// ResponseErrorListV2 defines model for ResponseErrorListV2.
type ResponseErrorListV2 struct {
	Errors []ResponseErrorListV2Errors `json:"errors"`
}

// ResponseErrorListV2Errors defines model for ResponseErrorListV2_errors.
type ResponseErrorListV2Errors struct {
	// Code The code of the error encountered. Where the error is specific to the respondent, an application-specific error code, expressed as a string value. If the error is application-specific, the URN code that the specific error extends must be provided in the meta object. Otherwise, the value is the error code URN.
	Code string `json:"code"`

	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail string `json:"detail"`

	// Meta Additional data for customised error codes
	Meta *MetaError `json:"meta,omitempty"`

	// Title A short, human-readable summary of the problem that MUST NOT change from occurrence to occurrence of the problem represented by the error code.
	Title string `json:"title"`
}

// GetCustomerParams defines parameters for GetCustomer.
type GetCustomerParams struct {
	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the Data Recipient Software Product. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the Data Recipient Software Product. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// GetCustomerDetailParams defines parameters for GetCustomerDetail.
type GetCustomerDetailParams struct {
	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the Data Recipient Software Product. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the Data Recipient Software Product. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// GetOutagesParams defines parameters for GetOutages.
type GetOutagesParams struct {
	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`
}

// GetStatusParams defines parameters for GetStatus.
type GetStatusParams struct {
	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetCustomer request
	GetCustomer(ctx context.Context, params *GetCustomerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomerDetail request
	GetCustomerDetail(ctx context.Context, params *GetCustomerDetailParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOutages request
	GetOutages(ctx context.Context, params *GetOutagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatus request
	GetStatus(ctx context.Context, params *GetStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetCustomer(ctx context.Context, params *GetCustomerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomerRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomerDetail(ctx context.Context, params *GetCustomerDetailParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomerDetailRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOutages(ctx context.Context, params *GetOutagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOutagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatus(ctx context.Context, params *GetStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetCustomerRequest generates requests for GetCustomer
func NewGetCustomerRequest(server string, params *GetCustomerParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/common/customer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewGetCustomerDetailRequest generates requests for GetCustomerDetail
func NewGetCustomerDetailRequest(server string, params *GetCustomerDetailParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/common/customer/detail")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewGetOutagesRequest generates requests for GetOutages
func NewGetOutagesRequest(server string, params *GetOutagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/discovery/outages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	return req, nil
}

// NewGetStatusRequest generates requests for GetStatus
func NewGetStatusRequest(server string, params *GetStatusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/discovery/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetCustomer request
	GetCustomerWithResponse(ctx context.Context, params *GetCustomerParams, reqEditors ...RequestEditorFn) (*GetCustomerResponse, error)

	// GetCustomerDetail request
	GetCustomerDetailWithResponse(ctx context.Context, params *GetCustomerDetailParams, reqEditors ...RequestEditorFn) (*GetCustomerDetailResponse, error)

	// GetOutages request
	GetOutagesWithResponse(ctx context.Context, params *GetOutagesParams, reqEditors ...RequestEditorFn) (*GetOutagesResponse, error)

	// GetStatus request
	GetStatusWithResponse(ctx context.Context, params *GetStatusParams, reqEditors ...RequestEditorFn) (*GetStatusResponse, error)
}

type GetCustomerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseCommonCustomer
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomerDetailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseCommonCustomerDetailV2
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetCustomerDetailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomerDetailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOutagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseDiscoveryOutagesList
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetOutagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOutagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseCommonDiscoveryStatus
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetCustomerWithResponse request returning *GetCustomerResponse
func (c *ClientWithResponses) GetCustomerWithResponse(ctx context.Context, params *GetCustomerParams, reqEditors ...RequestEditorFn) (*GetCustomerResponse, error) {
	rsp, err := c.GetCustomer(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomerResponse(rsp)
}

// GetCustomerDetailWithResponse request returning *GetCustomerDetailResponse
func (c *ClientWithResponses) GetCustomerDetailWithResponse(ctx context.Context, params *GetCustomerDetailParams, reqEditors ...RequestEditorFn) (*GetCustomerDetailResponse, error) {
	rsp, err := c.GetCustomerDetail(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomerDetailResponse(rsp)
}

// GetOutagesWithResponse request returning *GetOutagesResponse
func (c *ClientWithResponses) GetOutagesWithResponse(ctx context.Context, params *GetOutagesParams, reqEditors ...RequestEditorFn) (*GetOutagesResponse, error) {
	rsp, err := c.GetOutages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOutagesResponse(rsp)
}

// GetStatusWithResponse request returning *GetStatusResponse
func (c *ClientWithResponses) GetStatusWithResponse(ctx context.Context, params *GetStatusParams, reqEditors ...RequestEditorFn) (*GetStatusResponse, error) {
	rsp, err := c.GetStatus(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatusResponse(rsp)
}

// ParseGetCustomerResponse parses an HTTP response from a GetCustomerWithResponse call
func ParseGetCustomerResponse(rsp *http.Response) (*GetCustomerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseCommonCustomer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetCustomerDetailResponse parses an HTTP response from a GetCustomerDetailWithResponse call
func ParseGetCustomerDetailResponse(rsp *http.Response) (*GetCustomerDetailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomerDetailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseCommonCustomerDetailV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetOutagesResponse parses an HTTP response from a GetOutagesWithResponse call
func ParseGetOutagesResponse(rsp *http.Response) (*GetOutagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOutagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseDiscoveryOutagesList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetStatusResponse parses an HTTP response from a GetStatusWithResponse call
func ParseGetStatusResponse(rsp *http.Response) (*GetStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseCommonDiscoveryStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}
