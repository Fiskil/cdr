// Package registry provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package registry

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
)

// Defines values for DataHolderBrandSummaryIndustries.
const (
	DataHolderBrandSummaryIndustriesBanking DataHolderBrandSummaryIndustries = "banking"
	DataHolderBrandSummaryIndustriesEnergy  DataHolderBrandSummaryIndustries = "energy"
	DataHolderBrandSummaryIndustriesTelco   DataHolderBrandSummaryIndustries = "telco"
)

// Defines values for DataHolderStatusStatus.
const (
	DataHolderStatusStatusACTIVE  DataHolderStatusStatus = "ACTIVE"
	DataHolderStatusStatusREMOVED DataHolderStatusStatus = "REMOVED"
)

// Defines values for DataRecipientBrandMetaDataStatus.
const (
	DataRecipientBrandMetaDataStatusACTIVE   DataRecipientBrandMetaDataStatus = "ACTIVE"
	DataRecipientBrandMetaDataStatusINACTIVE DataRecipientBrandMetaDataStatus = "INACTIVE"
	DataRecipientBrandMetaDataStatusREMOVED  DataRecipientBrandMetaDataStatus = "REMOVED"
)

// Defines values for DataRecipientStatusStatus.
const (
	DataRecipientStatusStatusACTIVE      DataRecipientStatusStatus = "ACTIVE"
	DataRecipientStatusStatusREVOKED     DataRecipientStatusStatus = "REVOKED"
	DataRecipientStatusStatusSURRENDERED DataRecipientStatusStatus = "SURRENDERED"
	DataRecipientStatusStatusSUSPENDED   DataRecipientStatusStatus = "SUSPENDED"
)

// Defines values for LegalEntityDetailOrganisationType.
const (
	COMPANY          LegalEntityDetailOrganisationType = "COMPANY"
	GOVERNMENTENTITY LegalEntityDetailOrganisationType = "GOVERNMENT_ENTITY"
	OTHER            LegalEntityDetailOrganisationType = "OTHER"
	PARTNERSHIP      LegalEntityDetailOrganisationType = "PARTNERSHIP"
	SOLETRADER       LegalEntityDetailOrganisationType = "SOLE_TRADER"
	TRUST            LegalEntityDetailOrganisationType = "TRUST"
)

// Defines values for LegalEntityDetailStatus.
const (
	LegalEntityDetailStatusACTIVE  LegalEntityDetailStatus = "ACTIVE"
	LegalEntityDetailStatusREMOVED LegalEntityDetailStatus = "REMOVED"
)

// Defines values for RegisterDataHolderAuthRegisterUType.
const (
	SIGNEDJWT RegisterDataHolderAuthRegisterUType = "SIGNED-JWT"
)

// Defines values for RegisterDataHolderBrandIndustries.
const (
	RegisterDataHolderBrandIndustriesBanking RegisterDataHolderBrandIndustries = "banking"
	RegisterDataHolderBrandIndustriesEnergy  RegisterDataHolderBrandIndustries = "energy"
	RegisterDataHolderBrandIndustriesTelco   RegisterDataHolderBrandIndustries = "telco"
)

// Defines values for RegisterDataHolderBrandStatus.
const (
	RegisterDataHolderBrandStatusACTIVE   RegisterDataHolderBrandStatus = "ACTIVE"
	RegisterDataHolderBrandStatusINACTIVE RegisterDataHolderBrandStatus = "INACTIVE"
	RegisterDataHolderBrandStatusREMOVED  RegisterDataHolderBrandStatus = "REMOVED"
)

// Defines values for RegisterDataRecipientAccreditationLevel.
const (
	SPONSORED    RegisterDataRecipientAccreditationLevel = "SPONSORED"
	UNRESTRICTED RegisterDataRecipientAccreditationLevel = "UNRESTRICTED"
)

// Defines values for RegisterDataRecipientStatus.
const (
	RegisterDataRecipientStatusACTIVE      RegisterDataRecipientStatus = "ACTIVE"
	RegisterDataRecipientStatusREVOKED     RegisterDataRecipientStatus = "REVOKED"
	RegisterDataRecipientStatusSURRENDERED RegisterDataRecipientStatus = "SURRENDERED"
	RegisterDataRecipientStatusSUSPENDED   RegisterDataRecipientStatus = "SUSPENDED"
)

// Defines values for SoftwareProductMetaDataStatus.
const (
	SoftwareProductMetaDataStatusACTIVE   SoftwareProductMetaDataStatus = "ACTIVE"
	SoftwareProductMetaDataStatusINACTIVE SoftwareProductMetaDataStatus = "INACTIVE"
	SoftwareProductMetaDataStatusREMOVED  SoftwareProductMetaDataStatus = "REMOVED"
)

// Defines values for SoftwareProductStatusStatus.
const (
	SoftwareProductStatusStatusACTIVE   SoftwareProductStatusStatus = "ACTIVE"
	SoftwareProductStatusStatusINACTIVE SoftwareProductStatusStatus = "INACTIVE"
	SoftwareProductStatusStatusREMOVED  SoftwareProductStatusStatus = "REMOVED"
)

// DataHolderBrandSummary defines model for DataHolderBrandSummary.
type DataHolderBrandSummary struct {
	// Australian Business Number for the organisation
	Abn *string `json:"abn,omitempty"`

	// Australian Company Number for the organisation
	Acn *string `json:"acn,omitempty"`

	// Australian Registered Body Number.  ARBNs are issued to registrable Australian bodies and foreign companies
	Arbn *string `json:"arbn,omitempty"`

	// The name of Data Holder Brand
	BrandName string `json:"brandName"`

	// Unique id of the Data Holder Brand issued by the CDR Register
	DataHolderBrandId *string `json:"dataHolderBrandId,omitempty"`

	// The industries the Data Holder Brand belongs to. Please note that the CDR Register entity model is constrained to one industry per brand which is planned to be relaxed in the future.
	Industries []DataHolderBrandSummaryIndustries `json:"industries"`

	// Interim id of the Data Holder Brand issued by the CDR Register. This is to be used to uniquely identify the record when dataHolderBrandId is not populated and is not to be reused
	InterimId *string `json:"interimId,omitempty"`

	// The date/time that the Data Holder Brand data was last updated in the Register
	LastUpdated time.Time `json:"lastUpdated"`

	// Brand logo URI
	LogoUri string `json:"logoUri"`

	// Base URI for the Data Holder's Consumer Data Standard public endpoints
	PublicBaseUri string `json:"publicBaseUri"`
}

// DataHolderBrandSummaryIndustries defines model for DataHolderBrandSummary.Industries.
type DataHolderBrandSummaryIndustries string

// DataHolderStatus defines model for DataHolderStatus.
type DataHolderStatus struct {
	// Unique id of the Data Holder Legal Entity issued by the CDR Register.
	LegalEntityId string `json:"legalEntityId"`

	// Data Holder status in the CDR Register
	Status DataHolderStatusStatus `json:"status"`
}

// Data Holder status in the CDR Register
type DataHolderStatusStatus string

// DataHoldersStatusList defines model for DataHoldersStatusList.
type DataHoldersStatusList struct {
	// Response data for the query
	Data  []DataHolderStatus `json:"data"`
	Links Links              `json:"links"`
	Meta  Meta               `json:"meta"`
}

// Metadata related to Data Recipient Brand
type DataRecipientBrandMetaData struct {
	// Data Recipient Brand name
	BrandName string `json:"brandName"`

	// Unique id of the Data Recipient brand issued by the CDR Register
	DataRecipientBrandId string `json:"dataRecipientBrandId"`

	// Data Recipient Brand logo URI
	LogoUri          string                     `json:"logoUri"`
	SoftwareProducts *[]SoftwareProductMetaData `json:"softwareProducts,omitempty"`

	// Data Recipient Brand status in the CDR Register
	Status DataRecipientBrandMetaDataStatus `json:"status"`
}

// Data Recipient Brand status in the CDR Register
type DataRecipientBrandMetaDataStatus string

// DataRecipientStatus defines model for DataRecipientStatus.
type DataRecipientStatus struct {
	// Unique id of the Data Recipient Legal Entity issued by the CDR Register
	LegalEntityId string `json:"legalEntityId"`

	// Data Recipient status in the CDR Register
	Status DataRecipientStatusStatus `json:"status"`
}

// Data Recipient status in the CDR Register
type DataRecipientStatusStatus string

// DataRecipientsStatusList defines model for DataRecipientsStatusList.
type DataRecipientsStatusList struct {
	// Response data for the query
	Data  []DataRecipientStatus `json:"data"`
	Links Links                 `json:"links"`
	Meta  Meta                  `json:"meta"`
}

// Object representing a JSON Web Key
type JWK struct {
	// The "alg" (algorithm) parameter identifies the algorithm intended for use with the key
	Alg string `json:"alg"`

	// The "e" RSA public exponent parameter
	E string `json:"e"`

	// The "key_ops" (key operations) parameter identifies the operation(s) for which the key is intended to be used
	KeyOps []string `json:"key_ops"`

	// The "kid" (key ID) parameter is partially used to match a specific key. Note the "kid" parameter is not guaranteed unique and additional parameters should be used to progressively to identify a key within a set
	Kid string `json:"kid"`

	// The "kty" (key type) parameter identifies the cryptographic algorithm family used with the key
	Kty string `json:"kty"`

	// The "n" RSA public modulus parameter
	N string `json:"n"`
}

// The data that is common to all organisations, regardless of the type (e.g. company, trust, partnership, government)
type LegalEntityDetail struct {
	// Australian Business Number for the organisation
	Abn *string `json:"abn,omitempty"`

	// Australian Company Number for the organisation
	Acn *string `json:"acn,omitempty"`

	// ANZSIC division of the organisation. **[[ANZSIC-2006]](#iref-ANZSIC-2006)**
	AnzsicDivision *string `json:"anzsicDivision,omitempty"`

	// Australian Registered Body Number.  ARBNs are issued to registrable Australian bodies and foreign companies
	Arbn *string `json:"arbn,omitempty"`

	// Unique id of the organisation issued by the CDR Register
	LegalEntityId string `json:"legalEntityId"`

	// Unique legal name of the organisation
	LegalEntityName string `json:"legalEntityName"`

	// Legal Entity logo URI
	LogoUri string `json:"logoUri"`

	// Legal organisation type
	OrganisationType *LegalEntityDetailOrganisationType `json:"organisationType,omitempty"`

	// Country of registeration (if the company is registered outside Australia)
	RegisteredCountry *string `json:"registeredCountry,omitempty"`

	// Date of registration (if the company is registered outside Australia)
	RegistrationDate *openapi_types.Date `json:"registrationDate,omitempty"`

	// Unique registration number (if the company is registered outside Australia)
	RegistrationNumber *string                 `json:"registrationNumber,omitempty"`
	Status             LegalEntityDetailStatus `json:"status"`
}

// Legal organisation type
type LegalEntityDetailOrganisationType string

// LegalEntityDetailStatus defines model for LegalEntityDetail.Status.
type LegalEntityDetailStatus string

// Links defines model for Links.
type Links struct {
	// Fully qualified link to this API call
	Self string `json:"self"`
}

// LinksPaginated defines model for LinksPaginated.
type LinksPaginated struct {
	// URI to the first page of this set. Mandatory if this response is not the first page
	First *string `json:"first,omitempty"`

	// URI to the last page of this set. Mandatory if this response is not the last page
	Last *string `json:"last,omitempty"`

	// URI to the next page of this set. Mandatory if this response is not the last page
	Next *string `json:"next,omitempty"`

	// URI to the previous page of this set. Mandatory if this response is not the first page
	Prev *string `json:"prev,omitempty"`

	// Fully qualified link to this API call
	Self string `json:"self"`
}

// Meta defines model for Meta.
type Meta = map[string]interface{}

// Additional data for customised error codes
type MetaError struct {
	// The CDR error code URN which the application-specific error code extends. Mandatory if the error `code` is an application-specific error rather than a standardised error code.
	Urn *string `json:"urn,omitempty"`
}

// MetaPaginated defines model for MetaPaginated.
type MetaPaginated struct {
	// The total number of pages in the full set
	TotalPages int32 `json:"totalPages"`

	// The total number of records in the full set
	TotalRecords int32 `json:"totalRecords"`
}

// Defines the mechanism used and associated endpoints for Data Holder to Data Recipient authentication
type RegisterDataHolderAuth struct {
	// JWKS endpoint used for authentication by the Data Holder with the Data Recipient
	JwksEndpoint string `json:"jwksEndpoint"`

	// The type of authentication and authorisation mechanism in use
	RegisterUType RegisterDataHolderAuthRegisterUType `json:"registerUType"`
}

// The type of authentication and authorisation mechanism in use
type RegisterDataHolderAuthRegisterUType string

// RegisterDataHolderBrand defines model for RegisterDataHolderBrand.
type RegisterDataHolderBrand struct {
	AuthDetails []RegisterDataHolderAuth `json:"authDetails"`

	// The name of Data Holder Brand
	BrandName string `json:"brandName"`

	// Unique id of the Data Holder Brand issued by the CDR Register
	DataHolderBrandId string `json:"dataHolderBrandId"`

	// Endpoints related to Data Holder Brand services
	EndpointDetail RegisterDataHolderBrandServiceEndpoint `json:"endpointDetail"`

	// The industries the Data Holder Brand belongs to. Please note that the CDR Register entity model is constrained to one industry per brand which is planned to be relaxed in the future.
	Industries []RegisterDataHolderBrandIndustries `json:"industries"`

	// The date/time that the Data Holder Brand data was last updated in the Register
	LastUpdated time.Time `json:"lastUpdated"`

	// The data that is common to all organisations, regardless of the type (e.g. company, trust, partnership, government)
	LegalEntity LegalEntityDetail `json:"legalEntity"`

	// Brand logo URI
	LogoUri string                        `json:"logoUri"`
	Status  RegisterDataHolderBrandStatus `json:"status"`
}

// RegisterDataHolderBrandIndustries defines model for RegisterDataHolderBrand.Industries.
type RegisterDataHolderBrandIndustries string

// RegisterDataHolderBrandStatus defines model for RegisterDataHolderBrand.Status.
type RegisterDataHolderBrandStatus string

// Endpoints related to Data Holder Brand services
type RegisterDataHolderBrandServiceEndpoint struct {
	// Base URI for the Data Holder extension endpoints to the Consumer Data Standard (optional)
	ExtensionBaseUri *string `json:"extensionBaseUri,omitempty"`

	// Base URI for the Data Holder's Consumer Data Standard information security endpoints
	InfosecBaseUri string `json:"infosecBaseUri"`

	// Base URI for the Data Holder's Consumer Data Standard public endpoints
	PublicBaseUri string `json:"publicBaseUri"`

	// Base URI for the Data Holder's Consumer Data Standard resource endpoints
	ResourceBaseUri string `json:"resourceBaseUri"`

	// The major version of the high level standards. This is not the version of the endpoint or the payload being requested but the version of the overall standards being applied. This version number will be "v" followed by the major version of the standards as a positive integer (e.g. v1, v12 or v76)
	Version string `json:"version"`

	// Publicly available website or web resource URI
	WebsiteUri string `json:"websiteUri"`
}

// RegisterDataRecipient defines model for RegisterDataRecipient.
type RegisterDataRecipient struct {
	// Accreditation level of the Data Recipient in the CDR Register
	AccreditationLevel RegisterDataRecipientAccreditationLevel `json:"accreditationLevel"`

	// CDR Register issued human readable unique number given to Data Recipients upon accreditation
	AccreditationNumber string                        `json:"accreditationNumber"`
	DataRecipientBrands *[]DataRecipientBrandMetaData `json:"dataRecipientBrands,omitempty"`

	// The date/time that the Legal Entity was last updated in the CDR Register
	LastUpdated time.Time `json:"lastUpdated"`

	// Unique id of the Data Recipient Legal Entity issued by the CDR Register.
	LegalEntityId string `json:"legalEntityId"`

	// Legal name of the Data Recipient
	LegalEntityName string `json:"legalEntityName"`

	// Legal Entity logo URI
	LogoUri string `json:"logoUri"`

	// Data Recipient status in the CDR Register
	Status RegisterDataRecipientStatus `json:"status"`
}

// Accreditation level of the Data Recipient in the CDR Register
type RegisterDataRecipientAccreditationLevel string

// Data Recipient status in the CDR Register
type RegisterDataRecipientStatus string

// ResponseDataHoldersBrandSummaryList defines model for ResponseDataHoldersBrandSummaryList.
type ResponseDataHoldersBrandSummaryList struct {
	// Response data for the query
	Data  []DataHolderBrandSummary `json:"data"`
	Links Links                    `json:"links"`
	Meta  Meta                     `json:"meta"`
}

// ResponseErrorListV2 defines model for ResponseErrorListV2.
type ResponseErrorListV2 struct {
	Errors []ResponseErrorListV2Errors `json:"errors"`
}

// ResponseErrorListV2Errors defines model for ResponseErrorListV2_errors.
type ResponseErrorListV2Errors struct {
	// The code of the error encountered. Where the error is specific to the respondent, an application-specific error code, expressed as a string value. If the error is application-specific, the URN code that the specific error extends must be provided in the meta object. Otherwise, the value is the error code URN.
	Code string `json:"code"`

	// A human-readable explanation specific to this occurrence of the problem.
	Detail string `json:"detail"`

	// Additional data for customised error codes
	Meta *MetaError `json:"meta,omitempty"`

	// A short, human-readable summary of the problem that MUST NOT change from occurrence to occurrence of the problem represented by the error code.
	Title string `json:"title"`
}

// Response containing the JSON Web Key Set
type ResponseJWKS struct {
	// The value of the "keys" parameter is an array of JWK values
	Keys []JWK `json:"keys"`
}

// Response containing the Open ID Provider Configuration Metadata
type ResponseOpenIDProviderConfigMetadata struct {
	// JSON array containing a list of the Claim Names of the Claims that the CDR Register supplies values for
	ClaimsSupported []string `json:"claims_supported"`

	// JSON array containing a list of Proof Key for Code Exchange (PKCE) **[[RFC7636]](#nref-RFC7636)** code challenge methods supported by this authorization server. Given the CDR Register does not support PKCE, this field can be safely ignored
	CodeChallengeMethodsSupported []string `json:"code_challenge_methods_supported"`

	// JSON array containing a list of the OAuth 2.0 Grant Type values that the CDR Register supports
	GrantTypesSupported []string `json:"grant_types_supported"`

	// JSON array containing a list of the JWS signing algorithms (alg values) supported by the CDR Register for the ID Token to encode the Claims in a JWT. Given the CDR Register does not issue ID tokens, this field can be safely ignored
	IdTokenSigningAlgValuesSupported []string `json:"id_token_signing_alg_values_supported"`

	// URL using the https scheme with no query or fragment component that the CDR Register asserts as its Issuer Identifier
	Issuer string `json:"issuer"`

	// URL of the CDR Register's JSON Web Key Set **[[JWK]](#nref-JWK)** document. This contains the signing key(s) used to validate access tokens issued from the CDR Register. Note that this differs from the JWKS endpoint used to validate SSAs and CDR Register client authentication
	JwksUri string `json:"jwks_uri"`

	// JSON array containing a list of the OAuth 2.0 response_type values that the CDR Registrer supports
	ResponseTypesSupported []string `json:"response_types_supported"`

	// JSON array containing a list of the OAuth 2.0 **[[RFC6749]](#nref-RFC6749)** scope values that the CDR Register supports
	ScopesSupported []string `json:"scopes_supported"`

	// JSON array containing a list of the Subject Identifier types that the CDR Register supports. Given the CDR Register does not issue ID tokens, this field can be safely ignored
	SubjectTypesSupported []string `json:"subject_types_supported"`

	// Boolean value indicating server support for mutual TLS client certificate bound access tokens
	TlsClientCertificateBoundAccessTokens bool `json:"tls_client_certificate_bound_access_tokens"`

	// URL of the CDR Register's OAuth 2.0 Token Endpoint
	TokenEndpoint string `json:"token_endpoint"`

	// JSON array containing a list of Client Authentication methods supported by this Token Endpoint
	TokenEndpointAuthMethodsSupported []string `json:"token_endpoint_auth_methods_supported"`

	// JSON array containing a list of the JWS signing algorithms (alg values) supported by the token endpoint for the signature on the JWT **[[JWT]](#nref-JWT)** used to authenticate the client at the token endpoint for the \"private_key_jwt\" authentication method
	TokenEndpointAuthSigningAlgValuesSupported []string `json:"token_endpoint_auth_signing_alg_values_supported"`
}

// Response containing a list of CDR Register Data Holder Brand objects
type ResponseRegisterDataHolderBrandList struct {
	// Response data for the query
	Data  []RegisterDataHolderBrand `json:"data"`
	Links LinksPaginated            `json:"links"`
	Meta  MetaPaginated             `json:"meta"`
}

// Response containing a list of Data Recipients in the CDR Register
type ResponseRegisterDataRecipientList struct {
	// Response data for the query
	Data  []RegisterDataRecipient `json:"data"`
	Links Links                   `json:"links"`
	Meta  Meta                    `json:"meta"`
}

// Data Recipient Brand Software Products
type SoftwareProductMetaData struct {
	// Software product logo URI
	LogoUri string `json:"logoUri"`

	// Description of the software product
	SoftwareProductDescription *string `json:"softwareProductDescription,omitempty"`

	// Unique id of the Data Recipient software product issued by the CDR Register
	SoftwareProductId string `json:"softwareProductId"`

	// Name of the software product
	SoftwareProductName string `json:"softwareProductName"`

	// Software Product status in the CDR Register
	Status SoftwareProductMetaDataStatus `json:"status"`
}

// Software Product status in the CDR Register
type SoftwareProductMetaDataStatus string

// SoftwareProductStatus defines model for SoftwareProductStatus.
type SoftwareProductStatus struct {
	// Unique id of the software product issued by the CDR Register
	SoftwareProductId string `json:"softwareProductId"`

	// Software product status in the CDR Register
	Status SoftwareProductStatusStatus `json:"status"`
}

// Software product status in the CDR Register
type SoftwareProductStatusStatus string

// SoftwareProductsStatusList defines model for SoftwareProductsStatusList.
type SoftwareProductsStatusList struct {
	// Response data for the query
	Data  []SoftwareProductStatus `json:"data"`
	Links Links                   `json:"links"`
	Meta  Meta                    `json:"meta"`
}

// GetDataHolderBrandsParams defines parameters for GetDataHolderBrands.
type GetDataHolderBrandsParams struct {
	// query filter returns results updated since the specified date-time
	UpdatedSince *time.Time `form:"updated-since,omitempty" json:"updated-since,omitempty"`

	// the page number to return
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// the number of records to return per page
	PageSize *int32 `form:"page-size,omitempty" json:"page-size,omitempty"`

	// An Authorisation Token as per **[[RFC6750]](#nref-RFC6750)**.
	Authorization string `json:"Authorization"`

	// The version of the API end point requested by the client. Must be set to a positive integer.
	XV *string `json:"x-v,omitempty"`

	// The [minimum version](https://consumerdatastandardsaustralia.github.io/standards/#http-headers) of the API end point requested by the client. Must be set to a positive integer if provided.
	XMinV *string `json:"x-min-v,omitempty"`
}

// GetDataHolderBrandsParamsIndustry defines parameters for GetDataHolderBrands.
type GetDataHolderBrandsParamsIndustry string

// GetDataHolderBrandsSummaryParams defines parameters for GetDataHolderBrandsSummary.
type GetDataHolderBrandsSummaryParams struct {
	// The version of the API end point requested by the client. Must be set to a positive integer.
	XV string `json:"x-v"`

	// The [minimum version](https://consumerdatastandardsaustralia.github.io/standards/#http-headers) of the API end point requested by the client. Must be set to a positive integer if provided.
	XMinV *string `json:"x-min-v,omitempty"`

	// Makes the request method conditional on a recipient cache or origin server not having any current representation of the target resource with an entity-tag that does not match any of those listed in the field-value.
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// GetDataHolderBrandsSummaryParamsIndustry defines parameters for GetDataHolderBrandsSummary.
type GetDataHolderBrandsSummaryParamsIndustry string

// GetDataHolderStatusesParams defines parameters for GetDataHolderStatuses.
type GetDataHolderStatusesParams struct {
	// The version of the API end point requested by the client. Must be set to a positive integer.
	XV *string `json:"x-v,omitempty"`

	// The [minimum version](https://consumerdatastandardsaustralia.github.io/standards/#http-headers) of the API end point requested by the client. Must be set to a positive integer if provided.
	XMinV *string `json:"x-min-v,omitempty"`

	// Makes the request method conditional on a recipient cache or origin server not having any current representation of the target resource with an entity-tag that does not match any of those listed in the field-value.
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// GetDataHolderStatusesParamsIndustry defines parameters for GetDataHolderStatuses.
type GetDataHolderStatusesParamsIndustry string

// GetDataRecipientsParams defines parameters for GetDataRecipients.
type GetDataRecipientsParams struct {
	// The version of the API end point requested by the client. Must be set to a positive integer.
	XV *string `json:"x-v,omitempty"`

	// The [minimum version](https://consumerdatastandardsaustralia.github.io/standards/#http-headers) of the API end point requested by the client. Must be set to a positive integer if provided.
	XMinV *string `json:"x-min-v,omitempty"`

	// Makes the request method conditional on a recipient cache or origin server not having any current representation of the target resource with an entity-tag that does not match any of those listed in the field-value.
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// GetDataRecipientsParamsIndustry defines parameters for GetDataRecipients.
type GetDataRecipientsParamsIndustry string

// GetSoftwareProductsStatusesParams defines parameters for GetSoftwareProductsStatuses.
type GetSoftwareProductsStatusesParams struct {
	// The version of the API end point requested by the client. Must be set to a positive integer.
	XV *string `json:"x-v,omitempty"`

	// The [minimum version](https://consumerdatastandardsaustralia.github.io/standards/#http-headers) of the API end point requested by the client. Must be set to a positive integer if provided.
	XMinV *string `json:"x-min-v,omitempty"`

	// Makes the request method conditional on a recipient cache or origin server not having any current representation of the target resource with an entity-tag that does not match any of those listed in the field-value.
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// GetSoftwareProductsStatusesParamsIndustry defines parameters for GetSoftwareProductsStatuses.
type GetSoftwareProductsStatusesParamsIndustry string

// GetSoftwareStatementAssertionParams defines parameters for GetSoftwareStatementAssertion.
type GetSoftwareStatementAssertionParams struct {
	// The version of the API end point requested by the client. Must be set to a positive integer.
	XV *string `json:"x-v,omitempty"`

	// The [minimum version](https://consumerdatastandardsaustralia.github.io/standards/#http-headers) of the API end point requested by the client. Must be set to a positive integer if provided.
	XMinV *string `json:"x-min-v,omitempty"`

	// An Authorisation Token as per **[[RFC6750]](#nref-RFC6750)**.
	Authorization string `json:"Authorization"`
}

// GetSoftwareStatementAssertionParamsIndustry defines parameters for GetSoftwareStatementAssertion.
type GetSoftwareStatementAssertionParamsIndustry string

// GetDataRecipientsStatusesParams defines parameters for GetDataRecipientsStatuses.
type GetDataRecipientsStatusesParams struct {
	// The version of the API end point requested by the client. Must be set to a positive integer.
	XV *string `json:"x-v,omitempty"`

	// The [minimum version](https://consumerdatastandardsaustralia.github.io/standards/#http-headers) of the API end point requested by the client. Must be set to a positive integer if provided.
	XMinV *string `json:"x-min-v,omitempty"`

	// Makes the request method conditional on a recipient cache or origin server not having any current representation of the target resource with an entity-tag that does not match any of those listed in the field-value.
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// GetDataRecipientsStatusesParamsIndustry defines parameters for GetDataRecipientsStatuses.
type GetDataRecipientsStatusesParamsIndustry string

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetOpenIdProviderConfig request
	GetOpenIdProviderConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataHolderBrands request
	GetDataHolderBrands(ctx context.Context, industry GetDataHolderBrandsParamsIndustry, params *GetDataHolderBrandsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataHolderBrandsSummary request
	GetDataHolderBrandsSummary(ctx context.Context, industry GetDataHolderBrandsSummaryParamsIndustry, params *GetDataHolderBrandsSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataHolderStatuses request
	GetDataHolderStatuses(ctx context.Context, industry GetDataHolderStatusesParamsIndustry, params *GetDataHolderStatusesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataRecipients request
	GetDataRecipients(ctx context.Context, industry GetDataRecipientsParamsIndustry, params *GetDataRecipientsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSoftwareProductsStatuses request
	GetSoftwareProductsStatuses(ctx context.Context, industry GetSoftwareProductsStatusesParamsIndustry, params *GetSoftwareProductsStatusesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSoftwareStatementAssertion request
	GetSoftwareStatementAssertion(ctx context.Context, industry GetSoftwareStatementAssertionParamsIndustry, dataRecipientBrandId string, softwareProductId string, params *GetSoftwareStatementAssertionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataRecipientsStatuses request
	GetDataRecipientsStatuses(ctx context.Context, industry GetDataRecipientsStatusesParamsIndustry, params *GetDataRecipientsStatusesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJWKS request
	GetJWKS(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetOpenIdProviderConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenIdProviderConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataHolderBrands(ctx context.Context, industry GetDataHolderBrandsParamsIndustry, params *GetDataHolderBrandsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataHolderBrandsRequest(c.Server, industry, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataHolderBrandsSummary(ctx context.Context, industry GetDataHolderBrandsSummaryParamsIndustry, params *GetDataHolderBrandsSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataHolderBrandsSummaryRequest(c.Server, industry, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataHolderStatuses(ctx context.Context, industry GetDataHolderStatusesParamsIndustry, params *GetDataHolderStatusesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataHolderStatusesRequest(c.Server, industry, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataRecipients(ctx context.Context, industry GetDataRecipientsParamsIndustry, params *GetDataRecipientsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataRecipientsRequest(c.Server, industry, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSoftwareProductsStatuses(ctx context.Context, industry GetSoftwareProductsStatusesParamsIndustry, params *GetSoftwareProductsStatusesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSoftwareProductsStatusesRequest(c.Server, industry, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSoftwareStatementAssertion(ctx context.Context, industry GetSoftwareStatementAssertionParamsIndustry, dataRecipientBrandId string, softwareProductId string, params *GetSoftwareStatementAssertionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSoftwareStatementAssertionRequest(c.Server, industry, dataRecipientBrandId, softwareProductId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataRecipientsStatuses(ctx context.Context, industry GetDataRecipientsStatusesParamsIndustry, params *GetDataRecipientsStatusesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataRecipientsStatusesRequest(c.Server, industry, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJWKS(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJWKSRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetOpenIdProviderConfigRequest generates requests for GetOpenIdProviderConfig
func NewGetOpenIdProviderConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/.well-known/openid-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDataHolderBrandsRequest generates requests for GetDataHolderBrands
func NewGetDataHolderBrandsRequest(server string, industry GetDataHolderBrandsParamsIndustry, params *GetDataHolderBrandsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "industry", runtime.ParamLocationPath, industry)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cdr-register/v1/%s/data-holders/brands", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.UpdatedSince != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated-since", runtime.ParamLocationQuery, *params.UpdatedSince); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	if params.XV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, *params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam1)
	}

	if params.XMinV != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam2)
	}

	return req, nil
}

// NewGetDataHolderBrandsSummaryRequest generates requests for GetDataHolderBrandsSummary
func NewGetDataHolderBrandsSummaryRequest(server string, industry GetDataHolderBrandsSummaryParamsIndustry, params *GetDataHolderBrandsSummaryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "industry", runtime.ParamLocationPath, industry)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cdr-register/v1/%s/data-holders/brands/summary", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.IfNoneMatch != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-None-Match", headerParam2)
	}

	return req, nil
}

// NewGetDataHolderStatusesRequest generates requests for GetDataHolderStatuses
func NewGetDataHolderStatusesRequest(server string, industry GetDataHolderStatusesParamsIndustry, params *GetDataHolderStatusesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "industry", runtime.ParamLocationPath, industry)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cdr-register/v1/%s/data-holders/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XV != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, *params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)
	}

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.IfNoneMatch != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-None-Match", headerParam2)
	}

	return req, nil
}

// NewGetDataRecipientsRequest generates requests for GetDataRecipients
func NewGetDataRecipientsRequest(server string, industry GetDataRecipientsParamsIndustry, params *GetDataRecipientsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "industry", runtime.ParamLocationPath, industry)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cdr-register/v1/%s/data-recipients", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XV != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, *params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)
	}

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.IfNoneMatch != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-None-Match", headerParam2)
	}

	return req, nil
}

// NewGetSoftwareProductsStatusesRequest generates requests for GetSoftwareProductsStatuses
func NewGetSoftwareProductsStatusesRequest(server string, industry GetSoftwareProductsStatusesParamsIndustry, params *GetSoftwareProductsStatusesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "industry", runtime.ParamLocationPath, industry)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cdr-register/v1/%s/data-recipients/brands/software-products/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XV != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, *params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)
	}

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.IfNoneMatch != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-None-Match", headerParam2)
	}

	return req, nil
}

// NewGetSoftwareStatementAssertionRequest generates requests for GetSoftwareStatementAssertion
func NewGetSoftwareStatementAssertionRequest(server string, industry GetSoftwareStatementAssertionParamsIndustry, dataRecipientBrandId string, softwareProductId string, params *GetSoftwareStatementAssertionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "industry", runtime.ParamLocationPath, industry)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "dataRecipientBrandId", runtime.ParamLocationPath, dataRecipientBrandId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "softwareProductId", runtime.ParamLocationPath, softwareProductId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cdr-register/v1/%s/data-recipients/brands/%s/software-products/%s/ssa", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XV != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, *params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)
	}

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	var headerParam2 string

	headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam2)

	return req, nil
}

// NewGetDataRecipientsStatusesRequest generates requests for GetDataRecipientsStatuses
func NewGetDataRecipientsStatusesRequest(server string, industry GetDataRecipientsStatusesParamsIndustry, params *GetDataRecipientsStatusesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "industry", runtime.ParamLocationPath, industry)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cdr-register/v1/%s/data-recipients/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XV != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, *params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)
	}

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.IfNoneMatch != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-None-Match", headerParam2)
	}

	return req, nil
}

// NewGetJWKSRequest generates requests for GetJWKS
func NewGetJWKSRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jwks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetOpenIdProviderConfig request
	GetOpenIdProviderConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenIdProviderConfigResponse, error)

	// GetDataHolderBrands request
	GetDataHolderBrandsWithResponse(ctx context.Context, industry GetDataHolderBrandsParamsIndustry, params *GetDataHolderBrandsParams, reqEditors ...RequestEditorFn) (*GetDataHolderBrandsResponse, error)

	// GetDataHolderBrandsSummary request
	GetDataHolderBrandsSummaryWithResponse(ctx context.Context, industry GetDataHolderBrandsSummaryParamsIndustry, params *GetDataHolderBrandsSummaryParams, reqEditors ...RequestEditorFn) (*GetDataHolderBrandsSummaryResponse, error)

	// GetDataHolderStatuses request
	GetDataHolderStatusesWithResponse(ctx context.Context, industry GetDataHolderStatusesParamsIndustry, params *GetDataHolderStatusesParams, reqEditors ...RequestEditorFn) (*GetDataHolderStatusesResponse, error)

	// GetDataRecipients request
	GetDataRecipientsWithResponse(ctx context.Context, industry GetDataRecipientsParamsIndustry, params *GetDataRecipientsParams, reqEditors ...RequestEditorFn) (*GetDataRecipientsResponse, error)

	// GetSoftwareProductsStatuses request
	GetSoftwareProductsStatusesWithResponse(ctx context.Context, industry GetSoftwareProductsStatusesParamsIndustry, params *GetSoftwareProductsStatusesParams, reqEditors ...RequestEditorFn) (*GetSoftwareProductsStatusesResponse, error)

	// GetSoftwareStatementAssertion request
	GetSoftwareStatementAssertionWithResponse(ctx context.Context, industry GetSoftwareStatementAssertionParamsIndustry, dataRecipientBrandId string, softwareProductId string, params *GetSoftwareStatementAssertionParams, reqEditors ...RequestEditorFn) (*GetSoftwareStatementAssertionResponse, error)

	// GetDataRecipientsStatuses request
	GetDataRecipientsStatusesWithResponse(ctx context.Context, industry GetDataRecipientsStatusesParamsIndustry, params *GetDataRecipientsStatusesParams, reqEditors ...RequestEditorFn) (*GetDataRecipientsStatusesResponse, error)

	// GetJWKS request
	GetJWKSWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetJWKSResponse, error)
}

type GetOpenIdProviderConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseOpenIDProviderConfigMetadata
}

// Status returns HTTPResponse.Status
func (r GetOpenIdProviderConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenIdProviderConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataHolderBrandsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseRegisterDataHolderBrandList
	JSON400      *ResponseErrorListV2
	JSON401      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetDataHolderBrandsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataHolderBrandsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataHolderBrandsSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseDataHoldersBrandSummaryList
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetDataHolderBrandsSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataHolderBrandsSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataHolderStatusesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataHoldersStatusList
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetDataHolderStatusesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataHolderStatusesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataRecipientsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseRegisterDataRecipientList
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetDataRecipientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataRecipientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSoftwareProductsStatusesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SoftwareProductsStatusList
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetSoftwareProductsStatusesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSoftwareProductsStatusesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSoftwareStatementAssertionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON400      *ResponseErrorListV2
	JSON401      *ResponseErrorListV2
	JSON403      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetSoftwareStatementAssertionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSoftwareStatementAssertionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataRecipientsStatusesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataRecipientsStatusList
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetDataRecipientsStatusesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataRecipientsStatusesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJWKSResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseJWKS
}

// Status returns HTTPResponse.Status
func (r GetJWKSResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJWKSResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetOpenIdProviderConfigWithResponse request returning *GetOpenIdProviderConfigResponse
func (c *ClientWithResponses) GetOpenIdProviderConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenIdProviderConfigResponse, error) {
	rsp, err := c.GetOpenIdProviderConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenIdProviderConfigResponse(rsp)
}

// GetDataHolderBrandsWithResponse request returning *GetDataHolderBrandsResponse
func (c *ClientWithResponses) GetDataHolderBrandsWithResponse(ctx context.Context, industry GetDataHolderBrandsParamsIndustry, params *GetDataHolderBrandsParams, reqEditors ...RequestEditorFn) (*GetDataHolderBrandsResponse, error) {
	rsp, err := c.GetDataHolderBrands(ctx, industry, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataHolderBrandsResponse(rsp)
}

// GetDataHolderBrandsSummaryWithResponse request returning *GetDataHolderBrandsSummaryResponse
func (c *ClientWithResponses) GetDataHolderBrandsSummaryWithResponse(ctx context.Context, industry GetDataHolderBrandsSummaryParamsIndustry, params *GetDataHolderBrandsSummaryParams, reqEditors ...RequestEditorFn) (*GetDataHolderBrandsSummaryResponse, error) {
	rsp, err := c.GetDataHolderBrandsSummary(ctx, industry, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataHolderBrandsSummaryResponse(rsp)
}

// GetDataHolderStatusesWithResponse request returning *GetDataHolderStatusesResponse
func (c *ClientWithResponses) GetDataHolderStatusesWithResponse(ctx context.Context, industry GetDataHolderStatusesParamsIndustry, params *GetDataHolderStatusesParams, reqEditors ...RequestEditorFn) (*GetDataHolderStatusesResponse, error) {
	rsp, err := c.GetDataHolderStatuses(ctx, industry, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataHolderStatusesResponse(rsp)
}

// GetDataRecipientsWithResponse request returning *GetDataRecipientsResponse
func (c *ClientWithResponses) GetDataRecipientsWithResponse(ctx context.Context, industry GetDataRecipientsParamsIndustry, params *GetDataRecipientsParams, reqEditors ...RequestEditorFn) (*GetDataRecipientsResponse, error) {
	rsp, err := c.GetDataRecipients(ctx, industry, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataRecipientsResponse(rsp)
}

// GetSoftwareProductsStatusesWithResponse request returning *GetSoftwareProductsStatusesResponse
func (c *ClientWithResponses) GetSoftwareProductsStatusesWithResponse(ctx context.Context, industry GetSoftwareProductsStatusesParamsIndustry, params *GetSoftwareProductsStatusesParams, reqEditors ...RequestEditorFn) (*GetSoftwareProductsStatusesResponse, error) {
	rsp, err := c.GetSoftwareProductsStatuses(ctx, industry, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSoftwareProductsStatusesResponse(rsp)
}

// GetSoftwareStatementAssertionWithResponse request returning *GetSoftwareStatementAssertionResponse
func (c *ClientWithResponses) GetSoftwareStatementAssertionWithResponse(ctx context.Context, industry GetSoftwareStatementAssertionParamsIndustry, dataRecipientBrandId string, softwareProductId string, params *GetSoftwareStatementAssertionParams, reqEditors ...RequestEditorFn) (*GetSoftwareStatementAssertionResponse, error) {
	rsp, err := c.GetSoftwareStatementAssertion(ctx, industry, dataRecipientBrandId, softwareProductId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSoftwareStatementAssertionResponse(rsp)
}

// GetDataRecipientsStatusesWithResponse request returning *GetDataRecipientsStatusesResponse
func (c *ClientWithResponses) GetDataRecipientsStatusesWithResponse(ctx context.Context, industry GetDataRecipientsStatusesParamsIndustry, params *GetDataRecipientsStatusesParams, reqEditors ...RequestEditorFn) (*GetDataRecipientsStatusesResponse, error) {
	rsp, err := c.GetDataRecipientsStatuses(ctx, industry, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataRecipientsStatusesResponse(rsp)
}

// GetJWKSWithResponse request returning *GetJWKSResponse
func (c *ClientWithResponses) GetJWKSWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetJWKSResponse, error) {
	rsp, err := c.GetJWKS(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJWKSResponse(rsp)
}

// ParseGetOpenIdProviderConfigResponse parses an HTTP response from a GetOpenIdProviderConfigWithResponse call
func ParseGetOpenIdProviderConfigResponse(rsp *http.Response) (*GetOpenIdProviderConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenIdProviderConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseOpenIDProviderConfigMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDataHolderBrandsResponse parses an HTTP response from a GetDataHolderBrandsWithResponse call
func ParseGetDataHolderBrandsResponse(rsp *http.Response) (*GetDataHolderBrandsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataHolderBrandsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseRegisterDataHolderBrandList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetDataHolderBrandsSummaryResponse parses an HTTP response from a GetDataHolderBrandsSummaryWithResponse call
func ParseGetDataHolderBrandsSummaryResponse(rsp *http.Response) (*GetDataHolderBrandsSummaryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataHolderBrandsSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseDataHoldersBrandSummaryList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetDataHolderStatusesResponse parses an HTTP response from a GetDataHolderStatusesWithResponse call
func ParseGetDataHolderStatusesResponse(rsp *http.Response) (*GetDataHolderStatusesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataHolderStatusesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataHoldersStatusList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetDataRecipientsResponse parses an HTTP response from a GetDataRecipientsWithResponse call
func ParseGetDataRecipientsResponse(rsp *http.Response) (*GetDataRecipientsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataRecipientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseRegisterDataRecipientList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetSoftwareProductsStatusesResponse parses an HTTP response from a GetSoftwareProductsStatusesWithResponse call
func ParseGetSoftwareProductsStatusesResponse(rsp *http.Response) (*GetSoftwareProductsStatusesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSoftwareProductsStatusesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SoftwareProductsStatusList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetSoftwareStatementAssertionResponse parses an HTTP response from a GetSoftwareStatementAssertionWithResponse call
func ParseGetSoftwareStatementAssertionResponse(rsp *http.Response) (*GetSoftwareStatementAssertionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSoftwareStatementAssertionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetDataRecipientsStatusesResponse parses an HTTP response from a GetDataRecipientsStatusesWithResponse call
func ParseGetDataRecipientsStatusesResponse(rsp *http.Response) (*GetDataRecipientsStatusesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataRecipientsStatusesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataRecipientsStatusList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetJWKSResponse parses an HTTP response from a GetJWKSWithResponse call
func ParseGetJWKSResponse(rsp *http.Response) (*GetJWKSResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJWKSResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseJWKS
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
