// Package registry provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package registry

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// Defines values for DataHolderBrandSummaryIndustries.
const (
	DataHolderBrandSummaryIndustriesBanking DataHolderBrandSummaryIndustries = "banking"
	DataHolderBrandSummaryIndustriesEnergy  DataHolderBrandSummaryIndustries = "energy"
	DataHolderBrandSummaryIndustriesTelco   DataHolderBrandSummaryIndustries = "telco"
)

// Defines values for DataHolderStatusStatus.
const (
	DataHolderStatusStatusACTIVE  DataHolderStatusStatus = "ACTIVE"
	DataHolderStatusStatusREMOVED DataHolderStatusStatus = "REMOVED"
)

// Defines values for DataRecipientBrandMetaDataStatus.
const (
	DataRecipientBrandMetaDataStatusACTIVE   DataRecipientBrandMetaDataStatus = "ACTIVE"
	DataRecipientBrandMetaDataStatusINACTIVE DataRecipientBrandMetaDataStatus = "INACTIVE"
	DataRecipientBrandMetaDataStatusREMOVED  DataRecipientBrandMetaDataStatus = "REMOVED"
)

// Defines values for DataRecipientStatusStatus.
const (
	DataRecipientStatusStatusACTIVE      DataRecipientStatusStatus = "ACTIVE"
	DataRecipientStatusStatusREVOKED     DataRecipientStatusStatus = "REVOKED"
	DataRecipientStatusStatusSURRENDERED DataRecipientStatusStatus = "SURRENDERED"
	DataRecipientStatusStatusSUSPENDED   DataRecipientStatusStatus = "SUSPENDED"
)

// Defines values for LegalEntityDetailOrganisationType.
const (
	COMPANY          LegalEntityDetailOrganisationType = "COMPANY"
	GOVERNMENTENTITY LegalEntityDetailOrganisationType = "GOVERNMENT_ENTITY"
	OTHER            LegalEntityDetailOrganisationType = "OTHER"
	PARTNERSHIP      LegalEntityDetailOrganisationType = "PARTNERSHIP"
	SOLETRADER       LegalEntityDetailOrganisationType = "SOLE_TRADER"
	TRUST            LegalEntityDetailOrganisationType = "TRUST"
)

// Defines values for LegalEntityDetailStatus.
const (
	LegalEntityDetailStatusACTIVE  LegalEntityDetailStatus = "ACTIVE"
	LegalEntityDetailStatusREMOVED LegalEntityDetailStatus = "REMOVED"
)

// Defines values for RegisterDataHolderAuthRegisterUType.
const (
	SIGNEDJWT RegisterDataHolderAuthRegisterUType = "SIGNED-JWT"
)

// Defines values for RegisterDataHolderBrandIndustries.
const (
	RegisterDataHolderBrandIndustriesBanking RegisterDataHolderBrandIndustries = "banking"
	RegisterDataHolderBrandIndustriesEnergy  RegisterDataHolderBrandIndustries = "energy"
	RegisterDataHolderBrandIndustriesTelco   RegisterDataHolderBrandIndustries = "telco"
)

// Defines values for RegisterDataHolderBrandStatus.
const (
	RegisterDataHolderBrandStatusACTIVE   RegisterDataHolderBrandStatus = "ACTIVE"
	RegisterDataHolderBrandStatusINACTIVE RegisterDataHolderBrandStatus = "INACTIVE"
	RegisterDataHolderBrandStatusREMOVED  RegisterDataHolderBrandStatus = "REMOVED"
)

// Defines values for RegisterDataRecipientAccreditationLevel.
const (
	SPONSORED    RegisterDataRecipientAccreditationLevel = "SPONSORED"
	UNRESTRICTED RegisterDataRecipientAccreditationLevel = "UNRESTRICTED"
)

// Defines values for RegisterDataRecipientStatus.
const (
	RegisterDataRecipientStatusACTIVE      RegisterDataRecipientStatus = "ACTIVE"
	RegisterDataRecipientStatusREVOKED     RegisterDataRecipientStatus = "REVOKED"
	RegisterDataRecipientStatusSURRENDERED RegisterDataRecipientStatus = "SURRENDERED"
	RegisterDataRecipientStatusSUSPENDED   RegisterDataRecipientStatus = "SUSPENDED"
)

// Defines values for SoftwareProductMetaDataStatus.
const (
	SoftwareProductMetaDataStatusACTIVE   SoftwareProductMetaDataStatus = "ACTIVE"
	SoftwareProductMetaDataStatusINACTIVE SoftwareProductMetaDataStatus = "INACTIVE"
	SoftwareProductMetaDataStatusREMOVED  SoftwareProductMetaDataStatus = "REMOVED"
)

// Defines values for SoftwareProductStatusStatus.
const (
	SoftwareProductStatusStatusACTIVE   SoftwareProductStatusStatus = "ACTIVE"
	SoftwareProductStatusStatusINACTIVE SoftwareProductStatusStatus = "INACTIVE"
	SoftwareProductStatusStatusREMOVED  SoftwareProductStatusStatus = "REMOVED"
)

// DataHolderBrandSummary defines model for DataHolderBrandSummary.
type DataHolderBrandSummary struct {
	// Australian Business Number for the organisation
	Abn *string `json:"abn,omitempty"`

	// Australian Company Number for the organisation
	Acn *string `json:"acn,omitempty"`

	// Australian Registered Body Number.  ARBNs are issued to registrable Australian bodies and foreign companies
	Arbn *string `json:"arbn,omitempty"`

	// The name of Data Holder Brand
	BrandName string `json:"brandName"`

	// Unique id of the Data Holder Brand issued by the CDR Register
	DataHolderBrandId *string `json:"dataHolderBrandId,omitempty"`

	// The industries the Data Holder Brand belongs to. Please note that the CDR Register entity model is constrained to one industry per brand which is planned to be relaxed in the future.
	Industries []DataHolderBrandSummaryIndustries `json:"industries"`

	// Interim id of the Data Holder Brand issued by the CDR Register. This is to be used to uniquely identify the record when dataHolderBrandId is not populated and is not to be reused
	InterimId *string `json:"interimId,omitempty"`

	// The date/time that the Data Holder Brand data was last updated in the Register
	LastUpdated time.Time `json:"lastUpdated"`

	// Brand logo URI
	LogoUri string `json:"logoUri"`

	// Base URI for the Data Holder's Consumer Data Standard public endpoints
	PublicBaseUri string `json:"publicBaseUri"`
}

// DataHolderBrandSummaryIndustries defines model for DataHolderBrandSummary.Industries.
type DataHolderBrandSummaryIndustries string

// DataHolderStatus defines model for DataHolderStatus.
type DataHolderStatus struct {
	// Unique id of the Data Holder Legal Entity issued by the CDR Register.
	LegalEntityId string `json:"legalEntityId"`

	// Data Holder status in the CDR Register
	Status DataHolderStatusStatus `json:"status"`
}

// Data Holder status in the CDR Register
type DataHolderStatusStatus string

// DataHoldersStatusList defines model for DataHoldersStatusList.
type DataHoldersStatusList struct {
	// Response data for the query
	Data  []DataHolderStatus `json:"data"`
	Links Links              `json:"links"`
	Meta  Meta               `json:"meta"`
}

// Metadata related to Data Recipient Brand
type DataRecipientBrandMetaData struct {
	// Data Recipient Brand name
	BrandName string `json:"brandName"`

	// Unique id of the Data Recipient brand issued by the CDR Register
	DataRecipientBrandId string `json:"dataRecipientBrandId"`

	// Data Recipient Brand logo URI
	LogoUri          string                     `json:"logoUri"`
	SoftwareProducts *[]SoftwareProductMetaData `json:"softwareProducts,omitempty"`

	// Data Recipient Brand status in the CDR Register
	Status DataRecipientBrandMetaDataStatus `json:"status"`
}

// Data Recipient Brand status in the CDR Register
type DataRecipientBrandMetaDataStatus string

// DataRecipientStatus defines model for DataRecipientStatus.
type DataRecipientStatus struct {
	// Unique id of the Data Recipient Legal Entity issued by the CDR Register
	LegalEntityId string `json:"legalEntityId"`

	// Data Recipient status in the CDR Register
	Status DataRecipientStatusStatus `json:"status"`
}

// Data Recipient status in the CDR Register
type DataRecipientStatusStatus string

// DataRecipientsStatusList defines model for DataRecipientsStatusList.
type DataRecipientsStatusList struct {
	// Response data for the query
	Data  []DataRecipientStatus `json:"data"`
	Links Links                 `json:"links"`
	Meta  Meta                  `json:"meta"`
}

// Object representing a JSON Web Key
type JWK struct {
	// The "alg" (algorithm) parameter identifies the algorithm intended for use with the key
	Alg string `json:"alg"`

	// The "e" RSA public exponent parameter
	E string `json:"e"`

	// The "key_ops" (key operations) parameter identifies the operation(s) for which the key is intended to be used
	KeyOps []string `json:"key_ops"`

	// The "kid" (key ID) parameter is partially used to match a specific key. Note the "kid" parameter is not guaranteed unique and additional parameters should be used to progressively to identify a key within a set
	Kid string `json:"kid"`

	// The "kty" (key type) parameter identifies the cryptographic algorithm family used with the key
	Kty string `json:"kty"`

	// The "n" RSA public modulus parameter
	N string `json:"n"`
}

// The data that is common to all organisations, regardless of the type (e.g. company, trust, partnership, government)
type LegalEntityDetail struct {
	// Australian Business Number for the organisation
	Abn *string `json:"abn,omitempty"`

	// Australian Company Number for the organisation
	Acn *string `json:"acn,omitempty"`

	// ANZSIC division of the organisation. **[[ANZSIC-2006]](#iref-ANZSIC-2006)**
	AnzsicDivision *string `json:"anzsicDivision,omitempty"`

	// Australian Registered Body Number.  ARBNs are issued to registrable Australian bodies and foreign companies
	Arbn *string `json:"arbn,omitempty"`

	// Unique id of the organisation issued by the CDR Register
	LegalEntityId string `json:"legalEntityId"`

	// Unique legal name of the organisation
	LegalEntityName string `json:"legalEntityName"`

	// Legal Entity logo URI
	LogoUri string `json:"logoUri"`

	// Legal organisation type
	OrganisationType *LegalEntityDetailOrganisationType `json:"organisationType,omitempty"`

	// Country of registeration (if the company is registered outside Australia)
	RegisteredCountry *string `json:"registeredCountry,omitempty"`

	// Date of registration (if the company is registered outside Australia)
	RegistrationDate *openapi_types.Date `json:"registrationDate,omitempty"`

	// Unique registration number (if the company is registered outside Australia)
	RegistrationNumber *string                 `json:"registrationNumber,omitempty"`
	Status             LegalEntityDetailStatus `json:"status"`
}

// Legal organisation type
type LegalEntityDetailOrganisationType string

// LegalEntityDetailStatus defines model for LegalEntityDetail.Status.
type LegalEntityDetailStatus string

// Links defines model for Links.
type Links struct {
	// Fully qualified link to this API call
	Self string `json:"self"`
}

// LinksPaginated defines model for LinksPaginated.
type LinksPaginated struct {
	// URI to the first page of this set. Mandatory if this response is not the first page
	First *string `json:"first,omitempty"`

	// URI to the last page of this set. Mandatory if this response is not the last page
	Last *string `json:"last,omitempty"`

	// URI to the next page of this set. Mandatory if this response is not the last page
	Next *string `json:"next,omitempty"`

	// URI to the previous page of this set. Mandatory if this response is not the first page
	Prev *string `json:"prev,omitempty"`

	// Fully qualified link to this API call
	Self string `json:"self"`
}

// Meta defines model for Meta.
type Meta = map[string]interface{}

// Additional data for customised error codes
type MetaError struct {
	// The CDR error code URN which the application-specific error code extends. Mandatory if the error `code` is an application-specific error rather than a standardised error code.
	Urn *string `json:"urn,omitempty"`
}

// MetaPaginated defines model for MetaPaginated.
type MetaPaginated struct {
	// The total number of pages in the full set
	TotalPages int32 `json:"totalPages"`

	// The total number of records in the full set
	TotalRecords int32 `json:"totalRecords"`
}

// Defines the mechanism used and associated endpoints for Data Holder to Data Recipient authentication
type RegisterDataHolderAuth struct {
	// JWKS endpoint used for authentication by the Data Holder with the Data Recipient
	JwksEndpoint string `json:"jwksEndpoint"`

	// The type of authentication and authorisation mechanism in use
	RegisterUType RegisterDataHolderAuthRegisterUType `json:"registerUType"`
}

// The type of authentication and authorisation mechanism in use
type RegisterDataHolderAuthRegisterUType string

// RegisterDataHolderBrand defines model for RegisterDataHolderBrand.
type RegisterDataHolderBrand struct {
	AuthDetails []RegisterDataHolderAuth `json:"authDetails"`

	// The name of Data Holder Brand
	BrandName string `json:"brandName"`

	// Unique id of the Data Holder Brand issued by the CDR Register
	DataHolderBrandId string `json:"dataHolderBrandId"`

	// Endpoints related to Data Holder Brand services
	EndpointDetail RegisterDataHolderBrandServiceEndpoint `json:"endpointDetail"`

	// The industries the Data Holder Brand belongs to. Please note that the CDR Register entity model is constrained to one industry per brand which is planned to be relaxed in the future.
	Industries []RegisterDataHolderBrandIndustries `json:"industries"`

	// The date/time that the Data Holder Brand data was last updated in the Register
	LastUpdated time.Time `json:"lastUpdated"`

	// The data that is common to all organisations, regardless of the type (e.g. company, trust, partnership, government)
	LegalEntity LegalEntityDetail `json:"legalEntity"`

	// Brand logo URI
	LogoUri string                        `json:"logoUri"`
	Status  RegisterDataHolderBrandStatus `json:"status"`
}

// RegisterDataHolderBrandIndustries defines model for RegisterDataHolderBrand.Industries.
type RegisterDataHolderBrandIndustries string

// RegisterDataHolderBrandStatus defines model for RegisterDataHolderBrand.Status.
type RegisterDataHolderBrandStatus string

// Endpoints related to Data Holder Brand services
type RegisterDataHolderBrandServiceEndpoint struct {
	// Base URI for the Data Holder extension endpoints to the Consumer Data Standard (optional)
	ExtensionBaseUri *string `json:"extensionBaseUri,omitempty"`

	// Base URI for the Data Holder's Consumer Data Standard information security endpoints
	InfosecBaseUri string `json:"infosecBaseUri"`

	// Base URI for the Data Holder's Consumer Data Standard public endpoints
	PublicBaseUri string `json:"publicBaseUri"`

	// Base URI for the Data Holder's Consumer Data Standard resource endpoints
	ResourceBaseUri string `json:"resourceBaseUri"`

	// The major version of the high level standards. This is not the version of the endpoint or the payload being requested but the version of the overall standards being applied. This version number will be "v" followed by the major version of the standards as a positive integer (e.g. v1, v12 or v76)
	Version string `json:"version"`

	// Publicly available website or web resource URI
	WebsiteUri string `json:"websiteUri"`
}

// RegisterDataRecipient defines model for RegisterDataRecipient.
type RegisterDataRecipient struct {
	// Accreditation level of the Data Recipient in the CDR Register
	AccreditationLevel RegisterDataRecipientAccreditationLevel `json:"accreditationLevel"`

	// CDR Register issued human readable unique number given to Data Recipients upon accreditation
	AccreditationNumber string                        `json:"accreditationNumber"`
	DataRecipientBrands *[]DataRecipientBrandMetaData `json:"dataRecipientBrands,omitempty"`

	// The date/time that the Legal Entity was last updated in the CDR Register
	LastUpdated time.Time `json:"lastUpdated"`

	// Unique id of the Data Recipient Legal Entity issued by the CDR Register.
	LegalEntityId string `json:"legalEntityId"`

	// Legal name of the Data Recipient
	LegalEntityName string `json:"legalEntityName"`

	// Legal Entity logo URI
	LogoUri string `json:"logoUri"`

	// Data Recipient status in the CDR Register
	Status RegisterDataRecipientStatus `json:"status"`
}

// Accreditation level of the Data Recipient in the CDR Register
type RegisterDataRecipientAccreditationLevel string

// Data Recipient status in the CDR Register
type RegisterDataRecipientStatus string

// ResponseDataHoldersBrandSummaryList defines model for ResponseDataHoldersBrandSummaryList.
type ResponseDataHoldersBrandSummaryList struct {
	// Response data for the query
	Data  []DataHolderBrandSummary `json:"data"`
	Links Links                    `json:"links"`
	Meta  Meta                     `json:"meta"`
}

// ResponseErrorListV2 defines model for ResponseErrorListV2.
type ResponseErrorListV2 struct {
	Errors []ResponseErrorListV2Errors `json:"errors"`
}

// ResponseErrorListV2Errors defines model for ResponseErrorListV2_errors.
type ResponseErrorListV2Errors struct {
	// The code of the error encountered. Where the error is specific to the respondent, an application-specific error code, expressed as a string value. If the error is application-specific, the URN code that the specific error extends must be provided in the meta object. Otherwise, the value is the error code URN.
	Code string `json:"code"`

	// A human-readable explanation specific to this occurrence of the problem.
	Detail string `json:"detail"`

	// Additional data for customised error codes
	Meta *MetaError `json:"meta,omitempty"`

	// A short, human-readable summary of the problem that MUST NOT change from occurrence to occurrence of the problem represented by the error code.
	Title string `json:"title"`
}

// Response containing the JSON Web Key Set
type ResponseJWKS struct {
	// The value of the "keys" parameter is an array of JWK values
	Keys []JWK `json:"keys"`
}

// Response containing the Open ID Provider Configuration Metadata
type ResponseOpenIDProviderConfigMetadata struct {
	// JSON array containing a list of the Claim Names of the Claims that the CDR Register supplies values for
	ClaimsSupported []string `json:"claims_supported"`

	// JSON array containing a list of Proof Key for Code Exchange (PKCE) **[[RFC7636]](#nref-RFC7636)** code challenge methods supported by this authorization server. Given the CDR Register does not support PKCE, this field can be safely ignored
	CodeChallengeMethodsSupported []string `json:"code_challenge_methods_supported"`

	// JSON array containing a list of the OAuth 2.0 Grant Type values that the CDR Register supports
	GrantTypesSupported []string `json:"grant_types_supported"`

	// JSON array containing a list of the JWS signing algorithms (alg values) supported by the CDR Register for the ID Token to encode the Claims in a JWT. Given the CDR Register does not issue ID tokens, this field can be safely ignored
	IdTokenSigningAlgValuesSupported []string `json:"id_token_signing_alg_values_supported"`

	// URL using the https scheme with no query or fragment component that the CDR Register asserts as its Issuer Identifier
	Issuer string `json:"issuer"`

	// URL of the CDR Register's JSON Web Key Set **[[JWK]](#nref-JWK)** document. This contains the signing key(s) used to validate access tokens issued from the CDR Register. Note that this differs from the JWKS endpoint used to validate SSAs and CDR Register client authentication
	JwksUri string `json:"jwks_uri"`

	// JSON array containing a list of the OAuth 2.0 response_type values that the CDR Registrer supports
	ResponseTypesSupported []string `json:"response_types_supported"`

	// JSON array containing a list of the OAuth 2.0 **[[RFC6749]](#nref-RFC6749)** scope values that the CDR Register supports
	ScopesSupported []string `json:"scopes_supported"`

	// JSON array containing a list of the Subject Identifier types that the CDR Register supports. Given the CDR Register does not issue ID tokens, this field can be safely ignored
	SubjectTypesSupported []string `json:"subject_types_supported"`

	// Boolean value indicating server support for mutual TLS client certificate bound access tokens
	TlsClientCertificateBoundAccessTokens bool `json:"tls_client_certificate_bound_access_tokens"`

	// URL of the CDR Register's OAuth 2.0 Token Endpoint
	TokenEndpoint string `json:"token_endpoint"`

	// JSON array containing a list of Client Authentication methods supported by this Token Endpoint
	TokenEndpointAuthMethodsSupported []string `json:"token_endpoint_auth_methods_supported"`

	// JSON array containing a list of the JWS signing algorithms (alg values) supported by the token endpoint for the signature on the JWT **[[JWT]](#nref-JWT)** used to authenticate the client at the token endpoint for the \"private_key_jwt\" authentication method
	TokenEndpointAuthSigningAlgValuesSupported []string `json:"token_endpoint_auth_signing_alg_values_supported"`
}

// Response containing a list of CDR Register Data Holder Brand objects
type ResponseRegisterDataHolderBrandList struct {
	// Response data for the query
	Data  []RegisterDataHolderBrand `json:"data"`
	Links LinksPaginated            `json:"links"`
	Meta  MetaPaginated             `json:"meta"`
}

// Response containing a list of Data Recipients in the CDR Register
type ResponseRegisterDataRecipientList struct {
	// Response data for the query
	Data  []RegisterDataRecipient `json:"data"`
	Links Links                   `json:"links"`
	Meta  Meta                    `json:"meta"`
}

// Data Recipient Brand Software Products
type SoftwareProductMetaData struct {
	// Software product logo URI
	LogoUri string `json:"logoUri"`

	// Description of the software product
	SoftwareProductDescription *string `json:"softwareProductDescription,omitempty"`

	// Unique id of the Data Recipient software product issued by the CDR Register
	SoftwareProductId string `json:"softwareProductId"`

	// Name of the software product
	SoftwareProductName string `json:"softwareProductName"`

	// Software Product status in the CDR Register
	Status SoftwareProductMetaDataStatus `json:"status"`
}

// Software Product status in the CDR Register
type SoftwareProductMetaDataStatus string

// SoftwareProductStatus defines model for SoftwareProductStatus.
type SoftwareProductStatus struct {
	// Unique id of the software product issued by the CDR Register
	SoftwareProductId string `json:"softwareProductId"`

	// Software product status in the CDR Register
	Status SoftwareProductStatusStatus `json:"status"`
}

// Software product status in the CDR Register
type SoftwareProductStatusStatus string

// SoftwareProductsStatusList defines model for SoftwareProductsStatusList.
type SoftwareProductsStatusList struct {
	// Response data for the query
	Data  []SoftwareProductStatus `json:"data"`
	Links Links                   `json:"links"`
	Meta  Meta                    `json:"meta"`
}

// GetDataHolderBrandsParams defines parameters for GetDataHolderBrands.
type GetDataHolderBrandsParams struct {
	// query filter returns results updated since the specified date-time
	UpdatedSince *time.Time `form:"updated-since,omitempty" json:"updated-since,omitempty"`

	// the page number to return
	Page *int32 `form:"page,omitempty" json:"page,omitempty"`

	// the number of records to return per page
	PageSize *int32 `form:"page-size,omitempty" json:"page-size,omitempty"`

	// An Authorisation Token as per **[[RFC6750]](#nref-RFC6750)**.
	Authorization string `json:"Authorization"`

	// The version of the API end point requested by the client. Must be set to a positive integer.
	XV *string `json:"x-v,omitempty"`

	// The [minimum version](https://consumerdatastandardsaustralia.github.io/standards/#http-headers) of the API end point requested by the client. Must be set to a positive integer if provided.
	XMinV *string `json:"x-min-v,omitempty"`
}

// GetDataHolderBrandsParamsIndustry defines parameters for GetDataHolderBrands.
type GetDataHolderBrandsParamsIndustry string

// GetDataHolderBrandsSummaryParams defines parameters for GetDataHolderBrandsSummary.
type GetDataHolderBrandsSummaryParams struct {
	// The version of the API end point requested by the client. Must be set to a positive integer.
	XV string `json:"x-v"`

	// The [minimum version](https://consumerdatastandardsaustralia.github.io/standards/#http-headers) of the API end point requested by the client. Must be set to a positive integer if provided.
	XMinV *string `json:"x-min-v,omitempty"`

	// Makes the request method conditional on a recipient cache or origin server not having any current representation of the target resource with an entity-tag that does not match any of those listed in the field-value.
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// GetDataHolderBrandsSummaryParamsIndustry defines parameters for GetDataHolderBrandsSummary.
type GetDataHolderBrandsSummaryParamsIndustry string

// GetDataHolderStatusesParams defines parameters for GetDataHolderStatuses.
type GetDataHolderStatusesParams struct {
	// The version of the API end point requested by the client. Must be set to a positive integer.
	XV *string `json:"x-v,omitempty"`

	// The [minimum version](https://consumerdatastandardsaustralia.github.io/standards/#http-headers) of the API end point requested by the client. Must be set to a positive integer if provided.
	XMinV *string `json:"x-min-v,omitempty"`

	// Makes the request method conditional on a recipient cache or origin server not having any current representation of the target resource with an entity-tag that does not match any of those listed in the field-value.
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// GetDataHolderStatusesParamsIndustry defines parameters for GetDataHolderStatuses.
type GetDataHolderStatusesParamsIndustry string

// GetDataRecipientsParams defines parameters for GetDataRecipients.
type GetDataRecipientsParams struct {
	// The version of the API end point requested by the client. Must be set to a positive integer.
	XV *string `json:"x-v,omitempty"`

	// The [minimum version](https://consumerdatastandardsaustralia.github.io/standards/#http-headers) of the API end point requested by the client. Must be set to a positive integer if provided.
	XMinV *string `json:"x-min-v,omitempty"`

	// Makes the request method conditional on a recipient cache or origin server not having any current representation of the target resource with an entity-tag that does not match any of those listed in the field-value.
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// GetDataRecipientsParamsIndustry defines parameters for GetDataRecipients.
type GetDataRecipientsParamsIndustry string

// GetSoftwareProductsStatusesParams defines parameters for GetSoftwareProductsStatuses.
type GetSoftwareProductsStatusesParams struct {
	// The version of the API end point requested by the client. Must be set to a positive integer.
	XV *string `json:"x-v,omitempty"`

	// The [minimum version](https://consumerdatastandardsaustralia.github.io/standards/#http-headers) of the API end point requested by the client. Must be set to a positive integer if provided.
	XMinV *string `json:"x-min-v,omitempty"`

	// Makes the request method conditional on a recipient cache or origin server not having any current representation of the target resource with an entity-tag that does not match any of those listed in the field-value.
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// GetSoftwareProductsStatusesParamsIndustry defines parameters for GetSoftwareProductsStatuses.
type GetSoftwareProductsStatusesParamsIndustry string

// GetSoftwareStatementAssertionParams defines parameters for GetSoftwareStatementAssertion.
type GetSoftwareStatementAssertionParams struct {
	// The version of the API end point requested by the client. Must be set to a positive integer.
	XV *string `json:"x-v,omitempty"`

	// The [minimum version](https://consumerdatastandardsaustralia.github.io/standards/#http-headers) of the API end point requested by the client. Must be set to a positive integer if provided.
	XMinV *string `json:"x-min-v,omitempty"`

	// An Authorisation Token as per **[[RFC6750]](#nref-RFC6750)**.
	Authorization string `json:"Authorization"`
}

// GetSoftwareStatementAssertionParamsIndustry defines parameters for GetSoftwareStatementAssertion.
type GetSoftwareStatementAssertionParamsIndustry string

// GetDataRecipientsStatusesParams defines parameters for GetDataRecipientsStatuses.
type GetDataRecipientsStatusesParams struct {
	// The version of the API end point requested by the client. Must be set to a positive integer.
	XV *string `json:"x-v,omitempty"`

	// The [minimum version](https://consumerdatastandardsaustralia.github.io/standards/#http-headers) of the API end point requested by the client. Must be set to a positive integer if provided.
	XMinV *string `json:"x-min-v,omitempty"`

	// Makes the request method conditional on a recipient cache or origin server not having any current representation of the target resource with an entity-tag that does not match any of those listed in the field-value.
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// GetDataRecipientsStatusesParamsIndustry defines parameters for GetDataRecipientsStatuses.
type GetDataRecipientsStatusesParamsIndustry string

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get OpenId Provider Config
	// (GET /.well-known/openid-configuration)
	GetOpenIdProviderConfig(ctx echo.Context) error
	// Get Data Holder Brands
	// (GET /cdr-register/v1/{industry}/data-holders/brands)
	GetDataHolderBrands(ctx echo.Context, industry GetDataHolderBrandsParamsIndustry, params GetDataHolderBrandsParams) error
	// Get Data Holder Brands Summary
	// (GET /cdr-register/v1/{industry}/data-holders/brands/summary)
	GetDataHolderBrandsSummary(ctx echo.Context, industry GetDataHolderBrandsSummaryParamsIndustry, params GetDataHolderBrandsSummaryParams) error
	// Get Data Holder Statuses
	// (GET /cdr-register/v1/{industry}/data-holders/status)
	GetDataHolderStatuses(ctx echo.Context, industry GetDataHolderStatusesParamsIndustry, params GetDataHolderStatusesParams) error
	// Get Data Recipients
	// (GET /cdr-register/v1/{industry}/data-recipients)
	GetDataRecipients(ctx echo.Context, industry GetDataRecipientsParamsIndustry, params GetDataRecipientsParams) error
	// Get Software Products Statuses
	// (GET /cdr-register/v1/{industry}/data-recipients/brands/software-products/status)
	GetSoftwareProductsStatuses(ctx echo.Context, industry GetSoftwareProductsStatusesParamsIndustry, params GetSoftwareProductsStatusesParams) error
	// Get Software Statement Assertion (SSA)
	// (GET /cdr-register/v1/{industry}/data-recipients/brands/{dataRecipientBrandId}/software-products/{softwareProductId}/ssa)
	GetSoftwareStatementAssertion(ctx echo.Context, industry GetSoftwareStatementAssertionParamsIndustry, dataRecipientBrandId string, softwareProductId string, params GetSoftwareStatementAssertionParams) error
	// Get Data Recipients Statuses
	// (GET /cdr-register/v1/{industry}/data-recipients/status)
	GetDataRecipientsStatuses(ctx echo.Context, industry GetDataRecipientsStatusesParamsIndustry, params GetDataRecipientsStatusesParams) error
	// Get JWKS
	// (GET /jwks)
	GetJWKS(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetOpenIdProviderConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetOpenIdProviderConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetOpenIdProviderConfig(ctx)
	return err
}

// GetDataHolderBrands converts echo context to params.
func (w *ServerInterfaceWrapper) GetDataHolderBrands(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "industry" -------------
	var industry GetDataHolderBrandsParamsIndustry

	err = runtime.BindStyledParameterWithLocation("simple", false, "industry", runtime.ParamLocationPath, ctx.Param("industry"), &industry)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter industry: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDataHolderBrandsParams
	// ------------- Optional query parameter "updated-since" -------------

	err = runtime.BindQueryParameter("form", true, false, "updated-since", ctx.QueryParams(), &params.UpdatedSince)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter updated-since: %s", err))
	}

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "page-size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page-size", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page-size: %s", err))
	}

	headers := ctx.Request().Header
	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Authorization, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Authorization: %s", err))
		}

		params.Authorization = Authorization
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Authorization is required, but not found"))
	}
	// ------------- Optional header parameter "x-v" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-v")]; found {
		var XV string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-v, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, valueList[0], &XV)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-v: %s", err))
		}

		params.XV = &XV
	}
	// ------------- Optional header parameter "x-min-v" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-min-v")]; found {
		var XMinV string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-min-v, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, valueList[0], &XMinV)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-min-v: %s", err))
		}

		params.XMinV = &XMinV
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDataHolderBrands(ctx, industry, params)
	return err
}

// GetDataHolderBrandsSummary converts echo context to params.
func (w *ServerInterfaceWrapper) GetDataHolderBrandsSummary(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "industry" -------------
	var industry GetDataHolderBrandsSummaryParamsIndustry

	err = runtime.BindStyledParameterWithLocation("simple", false, "industry", runtime.ParamLocationPath, ctx.Param("industry"), &industry)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter industry: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDataHolderBrandsSummaryParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "x-v" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-v")]; found {
		var XV string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-v, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, valueList[0], &XV)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-v: %s", err))
		}

		params.XV = XV
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter x-v is required, but not found"))
	}
	// ------------- Optional header parameter "x-min-v" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-min-v")]; found {
		var XMinV string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-min-v, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, valueList[0], &XMinV)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-min-v: %s", err))
		}

		params.XMinV = &XMinV
	}
	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-None-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, valueList[0], &IfNoneMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-None-Match: %s", err))
		}

		params.IfNoneMatch = &IfNoneMatch
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDataHolderBrandsSummary(ctx, industry, params)
	return err
}

// GetDataHolderStatuses converts echo context to params.
func (w *ServerInterfaceWrapper) GetDataHolderStatuses(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "industry" -------------
	var industry GetDataHolderStatusesParamsIndustry

	err = runtime.BindStyledParameterWithLocation("simple", false, "industry", runtime.ParamLocationPath, ctx.Param("industry"), &industry)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter industry: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDataHolderStatusesParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "x-v" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-v")]; found {
		var XV string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-v, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, valueList[0], &XV)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-v: %s", err))
		}

		params.XV = &XV
	}
	// ------------- Optional header parameter "x-min-v" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-min-v")]; found {
		var XMinV string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-min-v, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, valueList[0], &XMinV)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-min-v: %s", err))
		}

		params.XMinV = &XMinV
	}
	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-None-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, valueList[0], &IfNoneMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-None-Match: %s", err))
		}

		params.IfNoneMatch = &IfNoneMatch
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDataHolderStatuses(ctx, industry, params)
	return err
}

// GetDataRecipients converts echo context to params.
func (w *ServerInterfaceWrapper) GetDataRecipients(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "industry" -------------
	var industry GetDataRecipientsParamsIndustry

	err = runtime.BindStyledParameterWithLocation("simple", false, "industry", runtime.ParamLocationPath, ctx.Param("industry"), &industry)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter industry: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDataRecipientsParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "x-v" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-v")]; found {
		var XV string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-v, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, valueList[0], &XV)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-v: %s", err))
		}

		params.XV = &XV
	}
	// ------------- Optional header parameter "x-min-v" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-min-v")]; found {
		var XMinV string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-min-v, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, valueList[0], &XMinV)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-min-v: %s", err))
		}

		params.XMinV = &XMinV
	}
	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-None-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, valueList[0], &IfNoneMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-None-Match: %s", err))
		}

		params.IfNoneMatch = &IfNoneMatch
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDataRecipients(ctx, industry, params)
	return err
}

// GetSoftwareProductsStatuses converts echo context to params.
func (w *ServerInterfaceWrapper) GetSoftwareProductsStatuses(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "industry" -------------
	var industry GetSoftwareProductsStatusesParamsIndustry

	err = runtime.BindStyledParameterWithLocation("simple", false, "industry", runtime.ParamLocationPath, ctx.Param("industry"), &industry)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter industry: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSoftwareProductsStatusesParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "x-v" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-v")]; found {
		var XV string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-v, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, valueList[0], &XV)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-v: %s", err))
		}

		params.XV = &XV
	}
	// ------------- Optional header parameter "x-min-v" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-min-v")]; found {
		var XMinV string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-min-v, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, valueList[0], &XMinV)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-min-v: %s", err))
		}

		params.XMinV = &XMinV
	}
	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-None-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, valueList[0], &IfNoneMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-None-Match: %s", err))
		}

		params.IfNoneMatch = &IfNoneMatch
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSoftwareProductsStatuses(ctx, industry, params)
	return err
}

// GetSoftwareStatementAssertion converts echo context to params.
func (w *ServerInterfaceWrapper) GetSoftwareStatementAssertion(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "industry" -------------
	var industry GetSoftwareStatementAssertionParamsIndustry

	err = runtime.BindStyledParameterWithLocation("simple", false, "industry", runtime.ParamLocationPath, ctx.Param("industry"), &industry)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter industry: %s", err))
	}

	// ------------- Path parameter "dataRecipientBrandId" -------------
	var dataRecipientBrandId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "dataRecipientBrandId", runtime.ParamLocationPath, ctx.Param("dataRecipientBrandId"), &dataRecipientBrandId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dataRecipientBrandId: %s", err))
	}

	// ------------- Path parameter "softwareProductId" -------------
	var softwareProductId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "softwareProductId", runtime.ParamLocationPath, ctx.Param("softwareProductId"), &softwareProductId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter softwareProductId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSoftwareStatementAssertionParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "x-v" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-v")]; found {
		var XV string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-v, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, valueList[0], &XV)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-v: %s", err))
		}

		params.XV = &XV
	}
	// ------------- Optional header parameter "x-min-v" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-min-v")]; found {
		var XMinV string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-min-v, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, valueList[0], &XMinV)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-min-v: %s", err))
		}

		params.XMinV = &XMinV
	}
	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for Authorization, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, valueList[0], &Authorization)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter Authorization: %s", err))
		}

		params.Authorization = Authorization
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter Authorization is required, but not found"))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSoftwareStatementAssertion(ctx, industry, dataRecipientBrandId, softwareProductId, params)
	return err
}

// GetDataRecipientsStatuses converts echo context to params.
func (w *ServerInterfaceWrapper) GetDataRecipientsStatuses(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "industry" -------------
	var industry GetDataRecipientsStatusesParamsIndustry

	err = runtime.BindStyledParameterWithLocation("simple", false, "industry", runtime.ParamLocationPath, ctx.Param("industry"), &industry)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter industry: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDataRecipientsStatusesParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "x-v" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-v")]; found {
		var XV string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-v, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, valueList[0], &XV)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-v: %s", err))
		}

		params.XV = &XV
	}
	// ------------- Optional header parameter "x-min-v" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-min-v")]; found {
		var XMinV string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for x-min-v, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, valueList[0], &XMinV)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter x-min-v: %s", err))
		}

		params.XMinV = &XMinV
	}
	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-None-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, valueList[0], &IfNoneMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-None-Match: %s", err))
		}

		params.IfNoneMatch = &IfNoneMatch
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDataRecipientsStatuses(ctx, industry, params)
	return err
}

// GetJWKS converts echo context to params.
func (w *ServerInterfaceWrapper) GetJWKS(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetJWKS(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/.well-known/openid-configuration", wrapper.GetOpenIdProviderConfig)
	router.GET(baseURL+"/cdr-register/v1/:industry/data-holders/brands", wrapper.GetDataHolderBrands)
	router.GET(baseURL+"/cdr-register/v1/:industry/data-holders/brands/summary", wrapper.GetDataHolderBrandsSummary)
	router.GET(baseURL+"/cdr-register/v1/:industry/data-holders/status", wrapper.GetDataHolderStatuses)
	router.GET(baseURL+"/cdr-register/v1/:industry/data-recipients", wrapper.GetDataRecipients)
	router.GET(baseURL+"/cdr-register/v1/:industry/data-recipients/brands/software-products/status", wrapper.GetSoftwareProductsStatuses)
	router.GET(baseURL+"/cdr-register/v1/:industry/data-recipients/brands/:dataRecipientBrandId/software-products/:softwareProductId/ssa", wrapper.GetSoftwareStatementAssertion)
	router.GET(baseURL+"/cdr-register/v1/:industry/data-recipients/status", wrapper.GetDataRecipientsStatuses)
	router.GET(baseURL+"/jwks", wrapper.GetJWKS)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
