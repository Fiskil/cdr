// Package registry provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package registry

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// Defines values for DataHolderBrandSummaryIndustries.
const (
	DataHolderBrandSummaryIndustriesBanking DataHolderBrandSummaryIndustries = "banking"
	DataHolderBrandSummaryIndustriesEnergy  DataHolderBrandSummaryIndustries = "energy"
	DataHolderBrandSummaryIndustriesTelco   DataHolderBrandSummaryIndustries = "telco"
)

// Defines values for DataHolderStatusStatus.
const (
	DataHolderStatusStatusACTIVE  DataHolderStatusStatus = "ACTIVE"
	DataHolderStatusStatusREMOVED DataHolderStatusStatus = "REMOVED"
)

// Defines values for DataRecipientBrandMetaDataStatus.
const (
	DataRecipientBrandMetaDataStatusACTIVE   DataRecipientBrandMetaDataStatus = "ACTIVE"
	DataRecipientBrandMetaDataStatusINACTIVE DataRecipientBrandMetaDataStatus = "INACTIVE"
	DataRecipientBrandMetaDataStatusREMOVED  DataRecipientBrandMetaDataStatus = "REMOVED"
)

// Defines values for DataRecipientStatusStatus.
const (
	DataRecipientStatusStatusACTIVE      DataRecipientStatusStatus = "ACTIVE"
	DataRecipientStatusStatusREVOKED     DataRecipientStatusStatus = "REVOKED"
	DataRecipientStatusStatusSURRENDERED DataRecipientStatusStatus = "SURRENDERED"
	DataRecipientStatusStatusSUSPENDED   DataRecipientStatusStatus = "SUSPENDED"
)

// Defines values for LegalEntityDetailOrganisationType.
const (
	COMPANY          LegalEntityDetailOrganisationType = "COMPANY"
	GOVERNMENTENTITY LegalEntityDetailOrganisationType = "GOVERNMENT_ENTITY"
	OTHER            LegalEntityDetailOrganisationType = "OTHER"
	PARTNERSHIP      LegalEntityDetailOrganisationType = "PARTNERSHIP"
	SOLETRADER       LegalEntityDetailOrganisationType = "SOLE_TRADER"
	TRUST            LegalEntityDetailOrganisationType = "TRUST"
)

// Defines values for LegalEntityDetailStatus.
const (
	LegalEntityDetailStatusACTIVE  LegalEntityDetailStatus = "ACTIVE"
	LegalEntityDetailStatusREMOVED LegalEntityDetailStatus = "REMOVED"
)

// Defines values for RegisterDataHolderAuthRegisterUType.
const (
	SIGNEDJWT RegisterDataHolderAuthRegisterUType = "SIGNED-JWT"
)

// Defines values for RegisterDataHolderBrandIndustries.
const (
	RegisterDataHolderBrandIndustriesBanking RegisterDataHolderBrandIndustries = "banking"
	RegisterDataHolderBrandIndustriesEnergy  RegisterDataHolderBrandIndustries = "energy"
	RegisterDataHolderBrandIndustriesTelco   RegisterDataHolderBrandIndustries = "telco"
)

// Defines values for RegisterDataHolderBrandStatus.
const (
	RegisterDataHolderBrandStatusACTIVE   RegisterDataHolderBrandStatus = "ACTIVE"
	RegisterDataHolderBrandStatusINACTIVE RegisterDataHolderBrandStatus = "INACTIVE"
	RegisterDataHolderBrandStatusREMOVED  RegisterDataHolderBrandStatus = "REMOVED"
)

// Defines values for RegisterDataRecipientAccreditationLevel.
const (
	SPONSORED    RegisterDataRecipientAccreditationLevel = "SPONSORED"
	UNRESTRICTED RegisterDataRecipientAccreditationLevel = "UNRESTRICTED"
)

// Defines values for RegisterDataRecipientStatus.
const (
	RegisterDataRecipientStatusACTIVE      RegisterDataRecipientStatus = "ACTIVE"
	RegisterDataRecipientStatusREVOKED     RegisterDataRecipientStatus = "REVOKED"
	RegisterDataRecipientStatusSURRENDERED RegisterDataRecipientStatus = "SURRENDERED"
	RegisterDataRecipientStatusSUSPENDED   RegisterDataRecipientStatus = "SUSPENDED"
)

// Defines values for SoftwareProductMetaDataStatus.
const (
	SoftwareProductMetaDataStatusACTIVE   SoftwareProductMetaDataStatus = "ACTIVE"
	SoftwareProductMetaDataStatusINACTIVE SoftwareProductMetaDataStatus = "INACTIVE"
	SoftwareProductMetaDataStatusREMOVED  SoftwareProductMetaDataStatus = "REMOVED"
)

// Defines values for SoftwareProductStatusStatus.
const (
	SoftwareProductStatusStatusACTIVE   SoftwareProductStatusStatus = "ACTIVE"
	SoftwareProductStatusStatusINACTIVE SoftwareProductStatusStatus = "INACTIVE"
	SoftwareProductStatusStatusREMOVED  SoftwareProductStatusStatus = "REMOVED"
)

// Defines values for GetDataHolderBrandsParamsIndustry.
const (
	GetDataHolderBrandsParamsIndustryAll     GetDataHolderBrandsParamsIndustry = "all"
	GetDataHolderBrandsParamsIndustryBanking GetDataHolderBrandsParamsIndustry = "banking"
	GetDataHolderBrandsParamsIndustryEnergy  GetDataHolderBrandsParamsIndustry = "energy"
	GetDataHolderBrandsParamsIndustryTelco   GetDataHolderBrandsParamsIndustry = "telco"
)

// Defines values for GetDataHolderBrandsSummaryParamsIndustry.
const (
	GetDataHolderBrandsSummaryParamsIndustryAll     GetDataHolderBrandsSummaryParamsIndustry = "all"
	GetDataHolderBrandsSummaryParamsIndustryBanking GetDataHolderBrandsSummaryParamsIndustry = "banking"
	GetDataHolderBrandsSummaryParamsIndustryEnergy  GetDataHolderBrandsSummaryParamsIndustry = "energy"
	GetDataHolderBrandsSummaryParamsIndustryTelco   GetDataHolderBrandsSummaryParamsIndustry = "telco"
)

// Defines values for GetDataHolderStatusesParamsIndustry.
const (
	GetDataHolderStatusesParamsIndustryAll     GetDataHolderStatusesParamsIndustry = "all"
	GetDataHolderStatusesParamsIndustryBanking GetDataHolderStatusesParamsIndustry = "banking"
	GetDataHolderStatusesParamsIndustryEnergy  GetDataHolderStatusesParamsIndustry = "energy"
	GetDataHolderStatusesParamsIndustryTelco   GetDataHolderStatusesParamsIndustry = "telco"
)

// Defines values for GetDataRecipientsParamsIndustry.
const (
	GetDataRecipientsParamsIndustryAll     GetDataRecipientsParamsIndustry = "all"
	GetDataRecipientsParamsIndustryBanking GetDataRecipientsParamsIndustry = "banking"
	GetDataRecipientsParamsIndustryEnergy  GetDataRecipientsParamsIndustry = "energy"
	GetDataRecipientsParamsIndustryTelco   GetDataRecipientsParamsIndustry = "telco"
)

// Defines values for GetSoftwareProductsStatusesParamsIndustry.
const (
	GetSoftwareProductsStatusesParamsIndustryAll     GetSoftwareProductsStatusesParamsIndustry = "all"
	GetSoftwareProductsStatusesParamsIndustryBanking GetSoftwareProductsStatusesParamsIndustry = "banking"
	GetSoftwareProductsStatusesParamsIndustryEnergy  GetSoftwareProductsStatusesParamsIndustry = "energy"
	GetSoftwareProductsStatusesParamsIndustryTelco   GetSoftwareProductsStatusesParamsIndustry = "telco"
)

// Defines values for GetSoftwareStatementAssertionParamsIndustry.
const (
	GetSoftwareStatementAssertionParamsIndustryAll     GetSoftwareStatementAssertionParamsIndustry = "all"
	GetSoftwareStatementAssertionParamsIndustryBanking GetSoftwareStatementAssertionParamsIndustry = "banking"
	GetSoftwareStatementAssertionParamsIndustryEnergy  GetSoftwareStatementAssertionParamsIndustry = "energy"
	GetSoftwareStatementAssertionParamsIndustryTelco   GetSoftwareStatementAssertionParamsIndustry = "telco"
)

// Defines values for GetDataRecipientsStatusesParamsIndustry.
const (
	All     GetDataRecipientsStatusesParamsIndustry = "all"
	Banking GetDataRecipientsStatusesParamsIndustry = "banking"
	Energy  GetDataRecipientsStatusesParamsIndustry = "energy"
	Telco   GetDataRecipientsStatusesParamsIndustry = "telco"
)

// DataHolderBrandSummary defines model for DataHolderBrandSummary.
type DataHolderBrandSummary struct {
	// Abn Australian Business Number for the organisation
	Abn *string `json:"abn,omitempty"`

	// Acn Australian Company Number for the organisation
	Acn *string `json:"acn,omitempty"`

	// Arbn Australian Registered Body Number.  ARBNs are issued to registrable Australian bodies and foreign companies
	Arbn *string `json:"arbn,omitempty"`

	// BrandName The name of Data Holder Brand
	BrandName string `json:"brandName"`

	// DataHolderBrandId Unique id of the Data Holder Brand issued by the CDR Register
	DataHolderBrandId *string `json:"dataHolderBrandId,omitempty"`

	// Industries The industries the Data Holder Brand belongs to
	Industries []DataHolderBrandSummaryIndustries `json:"industries"`

	// InterimId Interim id of the Data Holder Brand issued by the CDR Register. This is to be used to uniquely identify the record when dataHolderBrandId is not populated and is not to be reused
	InterimId *string `json:"interimId,omitempty"`

	// LastUpdated The date/time that the Data Holder Brand data was last updated in the Register
	LastUpdated string `json:"lastUpdated"`

	// LogoUri Brand logo URI
	LogoUri string `json:"logoUri"`

	// PublicBaseUri Base URI for the Data Holder's Consumer Data Standard public endpoints
	PublicBaseUri string `json:"publicBaseUri"`
}

// DataHolderBrandSummaryIndustries defines model for DataHolderBrandSummary.Industries.
type DataHolderBrandSummaryIndustries string

// DataHolderStatus defines model for DataHolderStatus.
type DataHolderStatus struct {
	// LegalEntityId Unique id of the Data Holder Legal Entity issued by the CDR Register.
	LegalEntityId string `json:"legalEntityId"`

	// Status Data Holder status in the CDR Register
	Status DataHolderStatusStatus `json:"status"`
}

// DataHolderStatusStatus Data Holder status in the CDR Register
type DataHolderStatusStatus string

// DataHoldersStatusList defines model for DataHoldersStatusList.
type DataHoldersStatusList struct {
	// Data Response data for the query
	Data  []DataHolderStatus     `json:"data"`
	Links Links                  `json:"links"`
	Meta  map[string]interface{} `json:"meta"`
}

// DataRecipientBrandMetaData Metadata related to Data Recipient Brand
type DataRecipientBrandMetaData struct {
	// BrandName Data Recipient Brand name
	BrandName string `json:"brandName"`

	// DataRecipientBrandId Unique id of the Data Recipient brand issued by the CDR Register
	DataRecipientBrandId string `json:"dataRecipientBrandId"`

	// LogoUri Data Recipient Brand logo URI
	LogoUri          string                     `json:"logoUri"`
	SoftwareProducts *[]SoftwareProductMetaData `json:"softwareProducts,omitempty"`

	// Status Data Recipient Brand status in the CDR Register
	Status DataRecipientBrandMetaDataStatus `json:"status"`
}

// DataRecipientBrandMetaDataStatus Data Recipient Brand status in the CDR Register
type DataRecipientBrandMetaDataStatus string

// DataRecipientStatus defines model for DataRecipientStatus.
type DataRecipientStatus struct {
	// LegalEntityId Unique id of the Data Recipient Legal Entity issued by the CDR Register
	LegalEntityId string `json:"legalEntityId"`

	// Status Data Recipient status in the CDR Register
	Status DataRecipientStatusStatus `json:"status"`
}

// DataRecipientStatusStatus Data Recipient status in the CDR Register
type DataRecipientStatusStatus string

// DataRecipientsStatusList defines model for DataRecipientsStatusList.
type DataRecipientsStatusList struct {
	// Data Response data for the query
	Data  []DataRecipientStatus  `json:"data"`
	Links Links                  `json:"links"`
	Meta  map[string]interface{} `json:"meta"`
}

// JWK Object representing a JSON Web Key
type JWK struct {
	// Alg The "alg" (algorithm) parameter identifies the algorithm intended for use with the key
	Alg string `json:"alg"`

	// E The "e" RSA public exponent parameter
	E string `json:"e"`

	// KeyOps The "key_ops" (key operations) parameter identifies the operation(s) for which the key is intended to be used
	KeyOps []string `json:"key_ops"`

	// Kid The "kid" (key ID) parameter is partially used to match a specific key. Note the "kid" parameter is not guaranteed unique and additional parameters should be used to progressively to identify a key within a set
	Kid string `json:"kid"`

	// Kty The "kty" (key type) parameter identifies the cryptographic algorithm family used with the key
	Kty string `json:"kty"`

	// N The "n" RSA public modulus parameter
	N string `json:"n"`
}

// LegalEntityDetail The data that is common to all organisations, regardless of the type (e.g. company, trust, partnership, government)
type LegalEntityDetail struct {
	// Abn Australian Business Number for the organisation
	Abn *string `json:"abn,omitempty"`

	// Acn Australian Company Number for the organisation
	Acn *string `json:"acn,omitempty"`

	// AnzsicDivision ANZSIC division of the organisation. **[[ANZSIC-2006]](#iref-ANZSIC-2006)**
	AnzsicDivision *string `json:"anzsicDivision,omitempty"`

	// Arbn Australian Registered Body Number.  ARBNs are issued to registrable Australian bodies and foreign companies
	Arbn *string `json:"arbn,omitempty"`

	// LegalEntityId Unique id of the organisation issued by the CDR Register
	LegalEntityId string `json:"legalEntityId"`

	// LegalEntityName Unique legal name of the organisation
	LegalEntityName string `json:"legalEntityName"`

	// LogoUri Legal Entity logo URI
	LogoUri string `json:"logoUri"`

	// OrganisationType Legal organisation type
	OrganisationType *LegalEntityDetailOrganisationType `json:"organisationType,omitempty"`

	// RegisteredCountry Country of registeration (if the company is registered outside Australia)
	RegisteredCountry *string `json:"registeredCountry,omitempty"`

	// RegistrationDate Date of registration (if the company is registered outside Australia)
	RegistrationDate *string `json:"registrationDate,omitempty"`

	// RegistrationNumber Unique registration number (if the company is registered outside Australia)
	RegistrationNumber *string                 `json:"registrationNumber,omitempty"`
	Status             LegalEntityDetailStatus `json:"status"`
}

// LegalEntityDetailOrganisationType Legal organisation type
type LegalEntityDetailOrganisationType string

// LegalEntityDetailStatus defines model for LegalEntityDetail.Status.
type LegalEntityDetailStatus string

// Links defines model for Links.
type Links struct {
	// Self Fully qualified link to this API call
	Self string `json:"self"`
}

// LinksPaginated defines model for LinksPaginated.
type LinksPaginated struct {
	// First URI to the first page of this set. Mandatory if this response is not the first page
	First *string `json:"first,omitempty"`

	// Last URI to the last page of this set. Mandatory if this response is not the last page
	Last *string `json:"last,omitempty"`

	// Next URI to the next page of this set. Mandatory if this response is not the last page
	Next *string `json:"next,omitempty"`

	// Prev URI to the previous page of this set. Mandatory if this response is not the first page
	Prev *string `json:"prev,omitempty"`

	// Self Fully qualified link to this API call
	Self string `json:"self"`
}

// MetaError Additional data for customised error codes
type MetaError struct {
	// Urn The CDR error code URN which the application-specific error code extends. Mandatory if the error `code` is an application-specific error rather than a standardised error code.
	Urn *string `json:"urn,omitempty"`
}

// MetaPaginated defines model for MetaPaginated.
type MetaPaginated struct {
	// TotalPages The total number of pages in the full set
	TotalPages int `json:"totalPages"`

	// TotalRecords The total number of records in the full set
	TotalRecords int `json:"totalRecords"`
}

// RegisterDataHolderAuth Defines the mechanism used and associated endpoints for Data Holder to Data Recipient authentication
type RegisterDataHolderAuth struct {
	// JwksEndpoint JWKS endpoint used for authentication by the Data Holder with the Data Recipient
	JwksEndpoint string `json:"jwksEndpoint"`

	// RegisterUType The type of authentication and authorisation mechanism in use
	RegisterUType RegisterDataHolderAuthRegisterUType `json:"registerUType"`
}

// RegisterDataHolderAuthRegisterUType The type of authentication and authorisation mechanism in use
type RegisterDataHolderAuthRegisterUType string

// RegisterDataHolderBrand defines model for RegisterDataHolderBrand.
type RegisterDataHolderBrand struct {
	AuthDetails []RegisterDataHolderAuth `json:"authDetails"`

	// BrandName The name of Data Holder Brand
	BrandName string `json:"brandName"`

	// DataHolderBrandId Unique id of the Data Holder Brand issued by the CDR Register
	DataHolderBrandId string `json:"dataHolderBrandId"`

	// EndpointDetail Endpoints related to Data Holder Brand services
	EndpointDetail RegisterDataHolderBrandServiceEndpoint `json:"endpointDetail"`

	// Industries The industries the Data Holder Brand belongs to
	Industries []RegisterDataHolderBrandIndustries `json:"industries"`

	// LastUpdated The date/time that the Data Holder Brand data was last updated in the Register
	LastUpdated string `json:"lastUpdated"`

	// LegalEntity The data that is common to all organisations, regardless of the type (e.g. company, trust, partnership, government)
	LegalEntity LegalEntityDetail `json:"legalEntity"`

	// LogoUri Brand logo URI
	LogoUri string                        `json:"logoUri"`
	Status  RegisterDataHolderBrandStatus `json:"status"`
}

// RegisterDataHolderBrandIndustries defines model for RegisterDataHolderBrand.Industries.
type RegisterDataHolderBrandIndustries string

// RegisterDataHolderBrandStatus defines model for RegisterDataHolderBrand.Status.
type RegisterDataHolderBrandStatus string

// RegisterDataHolderBrandServiceEndpoint Endpoints related to Data Holder Brand services
type RegisterDataHolderBrandServiceEndpoint struct {
	// ExtensionBaseUri Base URI for the Data Holder extension endpoints to the Consumer Data Standard (optional)
	ExtensionBaseUri *string `json:"extensionBaseUri,omitempty"`

	// InfosecBaseUri Base URI for the Data Holder's Consumer Data Standard information security endpoints
	InfosecBaseUri string `json:"infosecBaseUri"`

	// PublicBaseUri Base URI for the Data Holder's Consumer Data Standard public endpoints
	PublicBaseUri string `json:"publicBaseUri"`

	// ResourceBaseUri Base URI for the Data Holder's Consumer Data Standard resource endpoints
	ResourceBaseUri string `json:"resourceBaseUri"`

	// Version The major version of the high level standards. This is not the version of the endpoint or the payload being requested but the version of the overall standards being applied. This version number will be "v" followed by the major version of the standards as a positive integer (e.g. v1, v12 or v76)
	Version string `json:"version"`

	// WebsiteUri Publicly available website or web resource URI
	WebsiteUri string `json:"websiteUri"`
}

// RegisterDataRecipient defines model for RegisterDataRecipient.
type RegisterDataRecipient struct {
	// AccreditationLevel Accreditation level of the Data Recipient in the CDR Register
	AccreditationLevel RegisterDataRecipientAccreditationLevel `json:"accreditationLevel"`

	// AccreditationNumber CDR Register issued human readable unique number given to Data Recipients upon accreditation
	AccreditationNumber string                        `json:"accreditationNumber"`
	DataRecipientBrands *[]DataRecipientBrandMetaData `json:"dataRecipientBrands,omitempty"`

	// LastUpdated The date/time that the Legal Entity was last updated in the CDR Register
	LastUpdated string `json:"lastUpdated"`

	// LegalEntityId Unique id of the Data Recipient Legal Entity issued by the CDR Register.
	LegalEntityId string `json:"legalEntityId"`

	// LegalEntityName Legal name of the Data Recipient
	LegalEntityName string `json:"legalEntityName"`

	// LogoUri Legal Entity logo URI
	LogoUri string `json:"logoUri"`

	// Status Data Recipient status in the CDR Register
	Status RegisterDataRecipientStatus `json:"status"`
}

// RegisterDataRecipientAccreditationLevel Accreditation level of the Data Recipient in the CDR Register
type RegisterDataRecipientAccreditationLevel string

// RegisterDataRecipientStatus Data Recipient status in the CDR Register
type RegisterDataRecipientStatus string

// ResponseDataHoldersBrandSummaryList defines model for ResponseDataHoldersBrandSummaryList.
type ResponseDataHoldersBrandSummaryList struct {
	// Data Response data for the query
	Data  []DataHolderBrandSummary `json:"data"`
	Links Links                    `json:"links"`
	Meta  map[string]interface{}   `json:"meta"`
}

// ResponseErrorListV2 defines model for ResponseErrorListV2.
type ResponseErrorListV2 struct {
	Errors []ResponseErrorListV2Errors `json:"errors"`
}

// ResponseErrorListV2Errors defines model for ResponseErrorListV2_errors.
type ResponseErrorListV2Errors struct {
	// Code The code of the error encountered. Where the error is specific to the respondent, an application-specific error code, expressed as a string value. If the error is application-specific, the URN code that the specific error extends must be provided in the meta object. Otherwise, the value is the error code URN.
	Code string `json:"code"`

	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail string `json:"detail"`

	// Meta Additional data for customised error codes
	Meta *MetaError `json:"meta,omitempty"`

	// Title A short, human-readable summary of the problem that MUST NOT change from occurrence to occurrence of the problem represented by the error code.
	Title string `json:"title"`
}

// ResponseJWKS Response containing the JSON Web Key Set
type ResponseJWKS struct {
	// Keys The value of the "keys" parameter is an array of JWK values
	Keys []JWK `json:"keys"`
}

// ResponseOpenIDProviderConfigMetadata Response containing the Open ID Provider Configuration Metadata
type ResponseOpenIDProviderConfigMetadata struct {
	// ClaimsSupported JSON array containing a list of the Claim Names of the Claims that the CDR Register supplies values for
	ClaimsSupported []string `json:"claims_supported"`

	// CodeChallengeMethodsSupported JSON array containing a list of Proof Key for Code Exchange (PKCE) **[[RFC7636]](#nref-RFC7636)** code challenge methods supported by this authorization server. Given the CDR Register does not support PKCE, this field can be safely ignored
	CodeChallengeMethodsSupported []string `json:"code_challenge_methods_supported"`

	// GrantTypesSupported JSON array containing a list of the OAuth 2.0 Grant Type values that the CDR Register supports
	GrantTypesSupported []string `json:"grant_types_supported"`

	// IdTokenSigningAlgValuesSupported JSON array containing a list of the JWS signing algorithms (alg values) supported by the CDR Register for the ID Token to encode the Claims in a JWT. Given the CDR Register does not issue ID tokens, this field can be safely ignored
	IdTokenSigningAlgValuesSupported []string `json:"id_token_signing_alg_values_supported"`

	// Issuer URL using the https scheme with no query or fragment component that the CDR Register asserts as its Issuer Identifier
	Issuer string `json:"issuer"`

	// JwksUri URL of the CDR Register's JSON Web Key Set **[[JWK]](#nref-JWK)** document. This contains the signing key(s) used to validate access tokens issued from the CDR Register. Note that this differs from the JWKS endpoint used to validate SSAs and CDR Register client authentication
	JwksUri string `json:"jwks_uri"`

	// ResponseTypesSupported JSON array containing a list of the OAuth 2.0 response_type values that the CDR Registrer supports
	ResponseTypesSupported []string `json:"response_types_supported"`

	// ScopesSupported JSON array containing a list of the OAuth 2.0 **[[RFC6749]](#nref-RFC6749)** scope values that the CDR Register supports
	ScopesSupported []string `json:"scopes_supported"`

	// SubjectTypesSupported JSON array containing a list of the Subject Identifier types that the CDR Register supports. Given the CDR Register does not issue ID tokens, this field can be safely ignored
	SubjectTypesSupported []string `json:"subject_types_supported"`

	// TlsClientCertificateBoundAccessTokens Boolean value indicating server support for mutual TLS client certificate bound access tokens
	TlsClientCertificateBoundAccessTokens bool `json:"tls_client_certificate_bound_access_tokens"`

	// TokenEndpoint URL of the CDR Register's OAuth 2.0 Token Endpoint
	TokenEndpoint string `json:"token_endpoint"`

	// TokenEndpointAuthMethodsSupported JSON array containing a list of Client Authentication methods supported by this Token Endpoint
	TokenEndpointAuthMethodsSupported []string `json:"token_endpoint_auth_methods_supported"`

	// TokenEndpointAuthSigningAlgValuesSupported JSON array containing a list of the JWS signing algorithms (alg values) supported by the token endpoint for the signature on the JWT **[[JWT]](#nref-JWT)** used to authenticate the client at the token endpoint for the "private_key_jwt" authentication method
	TokenEndpointAuthSigningAlgValuesSupported []string `json:"token_endpoint_auth_signing_alg_values_supported"`
}

// ResponseRegisterDataHolderBrandList Response containing a list of CDR Register Data Holder Brand objects
type ResponseRegisterDataHolderBrandList struct {
	// Data Response data for the query
	Data  []RegisterDataHolderBrand `json:"data"`
	Links LinksPaginated            `json:"links"`
	Meta  MetaPaginated             `json:"meta"`
}

// ResponseRegisterDataRecipientList Response containing a list of Data Recipients in the CDR Register
type ResponseRegisterDataRecipientList struct {
	// Data Response data for the query
	Data  []RegisterDataRecipient `json:"data"`
	Links Links                   `json:"links"`
	Meta  map[string]interface{}  `json:"meta"`
}

// SoftwareProductMetaData Data Recipient Brand Software Products
type SoftwareProductMetaData struct {
	// LogoUri Software product logo URI
	LogoUri string `json:"logoUri"`

	// SoftwareProductDescription Description of the software product
	SoftwareProductDescription string `json:"softwareProductDescription"`

	// SoftwareProductId Unique id of the Data Recipient software product issued by the CDR Register
	SoftwareProductId string `json:"softwareProductId"`

	// SoftwareProductName Name of the software product
	SoftwareProductName string `json:"softwareProductName"`

	// Status Software Product status in the CDR Register
	Status SoftwareProductMetaDataStatus `json:"status"`
}

// SoftwareProductMetaDataStatus Software Product status in the CDR Register
type SoftwareProductMetaDataStatus string

// SoftwareProductStatus defines model for SoftwareProductStatus.
type SoftwareProductStatus struct {
	// SoftwareProductId Unique id of the software product issued by the CDR Register
	SoftwareProductId string `json:"softwareProductId"`

	// Status Software product status in the CDR Register
	Status SoftwareProductStatusStatus `json:"status"`
}

// SoftwareProductStatusStatus Software product status in the CDR Register
type SoftwareProductStatusStatus string

// SoftwareProductsStatusList defines model for SoftwareProductsStatusList.
type SoftwareProductsStatusList struct {
	// Data Response data for the query
	Data  []SoftwareProductStatus `json:"data"`
	Links Links                   `json:"links"`
	Meta  map[string]interface{}  `json:"meta"`
}

// GetDataHolderBrandsParams defines parameters for GetDataHolderBrands.
type GetDataHolderBrandsParams struct {
	// UpdatedSince query filter returns results updated since the specified date-time
	UpdatedSince *string `form:"updated-since,omitempty" json:"updated-since,omitempty"`

	// Page the page number to return
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize the number of records to return per page
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// Authorization An Authorisation Token as per **[[RFC6750]](#nref-RFC6750)**.
	Authorization string `json:"Authorization"`

	// XV The version of the API end point requested by the client. Must be set to a positive integer. For backwards compatiblity defaults to 1 if absent. Note that once version 1 is decommissioned the header will be mandatory for a valid response to be obtained
	XV *int `json:"x-v,omitempty"`

	// XMinV The [minimum version](https://consumerdatastandardsaustralia.github.io/standards/#http-headers) of the API end point requested by the client. Must be set to a positive integer if provided.
	XMinV *int `json:"x-min-v,omitempty"`
}

// GetDataHolderBrandsParamsIndustry defines parameters for GetDataHolderBrands.
type GetDataHolderBrandsParamsIndustry string

// GetDataHolderBrandsSummaryParams defines parameters for GetDataHolderBrandsSummary.
type GetDataHolderBrandsSummaryParams struct {
	// XV The version of the API end point requested by the client. Must be set to a positive integer.
	XV int `json:"x-v"`

	// XMinV The [minimum version](https://consumerdatastandardsaustralia.github.io/standards/#http-headers) of the API end point requested by the client. Must be set to a positive integer if provided.
	XMinV *int `json:"x-min-v,omitempty"`

	// IfNoneMatch Makes the request method conditional on a recipient cache or origin server not having any current representation of the target resource with an entity-tag that does not match any of those listed in the field-value.
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// GetDataHolderBrandsSummaryParamsIndustry defines parameters for GetDataHolderBrandsSummary.
type GetDataHolderBrandsSummaryParamsIndustry string

// GetDataHolderStatusesParams defines parameters for GetDataHolderStatuses.
type GetDataHolderStatusesParams struct {
	// XV The version of the API end point requested by the client. Must be set to a positive integer.  For backwards compatiblity defaults to 1 if absent. Note that once version 1 is decommissioned the header will be mandatory for a valid response to be obtained
	XV *int `json:"x-v,omitempty"`

	// XMinV The [minimum version](https://consumerdatastandardsaustralia.github.io/standards/#http-headers) of the API end point requested by the client. Must be set to a positive integer if provided.
	XMinV *int `json:"x-min-v,omitempty"`

	// IfNoneMatch Makes the request method conditional on a recipient cache or origin server not having any current representation of the target resource with an entity-tag that does not match any of those listed in the field-value.
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// GetDataHolderStatusesParamsIndustry defines parameters for GetDataHolderStatuses.
type GetDataHolderStatusesParamsIndustry string

// GetDataRecipientsParams defines parameters for GetDataRecipients.
type GetDataRecipientsParams struct {
	// XV The version of the API end point requested by the client. Must be set to a positive integer.  For backwards compatiblity defaults to 2 if absent. Note that once version 2 is decommissioned the header will be mandatory for a valid response to be obtained
	XV *int `json:"x-v,omitempty"`

	// XMinV The [minimum version](https://consumerdatastandardsaustralia.github.io/standards/#http-headers) of the API end point requested by the client. Must be set to a positive integer if provided.
	XMinV *int `json:"x-min-v,omitempty"`

	// IfNoneMatch Makes the request method conditional on a recipient cache or origin server not having any current representation of the target resource with an entity-tag that does not match any of those listed in the field-value.
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// GetDataRecipientsParamsIndustry defines parameters for GetDataRecipients.
type GetDataRecipientsParamsIndustry string

// GetSoftwareProductsStatusesParams defines parameters for GetSoftwareProductsStatuses.
type GetSoftwareProductsStatusesParams struct {
	// XV The version of the API end point requested by the client. Must be set to a positive integer.  For backwards compatiblity defaults to 1 if absent. Note that once version 1 is decommissioned the header will be mandatory for a valid response to be obtained
	XV *int `json:"x-v,omitempty"`

	// XMinV The [minimum version](https://consumerdatastandardsaustralia.github.io/standards/#http-headers) of the API end point requested by the client. Must be set to a positive integer if provided.
	XMinV *int `json:"x-min-v,omitempty"`

	// IfNoneMatch Makes the request method conditional on a recipient cache or origin server not having any current representation of the target resource with an entity-tag that does not match any of those listed in the field-value.
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// GetSoftwareProductsStatusesParamsIndustry defines parameters for GetSoftwareProductsStatuses.
type GetSoftwareProductsStatusesParamsIndustry string

// GetSoftwareStatementAssertionParams defines parameters for GetSoftwareStatementAssertion.
type GetSoftwareStatementAssertionParams struct {
	// XV The version of the API end point requested by the client. Must be set to a positive integer. For backwards compatiblity defaults to 1 if absent. Note that once version 1 is decommissioned the header will be mandatory for a valid response to be obtained
	XV *int `json:"x-v,omitempty"`

	// XMinV The [minimum version](https://consumerdatastandardsaustralia.github.io/standards/#http-headers) of the API end point requested by the client. Must be set to a positive integer if provided.
	XMinV *int `json:"x-min-v,omitempty"`

	// Authorization An Authorisation Token as per **[[RFC6750]](#nref-RFC6750)**.
	Authorization string `json:"Authorization"`
}

// GetSoftwareStatementAssertionParamsIndustry defines parameters for GetSoftwareStatementAssertion.
type GetSoftwareStatementAssertionParamsIndustry string

// GetDataRecipientsStatusesParams defines parameters for GetDataRecipientsStatuses.
type GetDataRecipientsStatusesParams struct {
	// XV The version of the API end point requested by the client. Must be set to a positive integer.  For backwards compatiblity defaults to 1 if absent. Note that once version 1 is decommissioned the header will be mandatory for a valid response to be obtained
	XV *int `json:"x-v,omitempty"`

	// XMinV The [minimum version](https://consumerdatastandardsaustralia.github.io/standards/#http-headers) of the API end point requested by the client. Must be set to a positive integer if provided.
	XMinV *int `json:"x-min-v,omitempty"`

	// IfNoneMatch Makes the request method conditional on a recipient cache or origin server not having any current representation of the target resource with an entity-tag that does not match any of those listed in the field-value.
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// GetDataRecipientsStatusesParamsIndustry defines parameters for GetDataRecipientsStatuses.
type GetDataRecipientsStatusesParamsIndustry string

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetOpenIdProviderConfig request
	GetOpenIdProviderConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataHolderBrands request
	GetDataHolderBrands(ctx context.Context, industry GetDataHolderBrandsParamsIndustry, params *GetDataHolderBrandsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataHolderBrandsSummary request
	GetDataHolderBrandsSummary(ctx context.Context, industry GetDataHolderBrandsSummaryParamsIndustry, params *GetDataHolderBrandsSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataHolderStatuses request
	GetDataHolderStatuses(ctx context.Context, industry GetDataHolderStatusesParamsIndustry, params *GetDataHolderStatusesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataRecipients request
	GetDataRecipients(ctx context.Context, industry GetDataRecipientsParamsIndustry, params *GetDataRecipientsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSoftwareProductsStatuses request
	GetSoftwareProductsStatuses(ctx context.Context, industry GetSoftwareProductsStatusesParamsIndustry, params *GetSoftwareProductsStatusesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSoftwareStatementAssertion request
	GetSoftwareStatementAssertion(ctx context.Context, industry GetSoftwareStatementAssertionParamsIndustry, dataRecipientBrandId string, softwareProductId string, params *GetSoftwareStatementAssertionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataRecipientsStatuses request
	GetDataRecipientsStatuses(ctx context.Context, industry GetDataRecipientsStatusesParamsIndustry, params *GetDataRecipientsStatusesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJWKS request
	GetJWKS(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetOpenIdProviderConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenIdProviderConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataHolderBrands(ctx context.Context, industry GetDataHolderBrandsParamsIndustry, params *GetDataHolderBrandsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataHolderBrandsRequest(c.Server, industry, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataHolderBrandsSummary(ctx context.Context, industry GetDataHolderBrandsSummaryParamsIndustry, params *GetDataHolderBrandsSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataHolderBrandsSummaryRequest(c.Server, industry, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataHolderStatuses(ctx context.Context, industry GetDataHolderStatusesParamsIndustry, params *GetDataHolderStatusesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataHolderStatusesRequest(c.Server, industry, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataRecipients(ctx context.Context, industry GetDataRecipientsParamsIndustry, params *GetDataRecipientsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataRecipientsRequest(c.Server, industry, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSoftwareProductsStatuses(ctx context.Context, industry GetSoftwareProductsStatusesParamsIndustry, params *GetSoftwareProductsStatusesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSoftwareProductsStatusesRequest(c.Server, industry, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSoftwareStatementAssertion(ctx context.Context, industry GetSoftwareStatementAssertionParamsIndustry, dataRecipientBrandId string, softwareProductId string, params *GetSoftwareStatementAssertionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSoftwareStatementAssertionRequest(c.Server, industry, dataRecipientBrandId, softwareProductId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataRecipientsStatuses(ctx context.Context, industry GetDataRecipientsStatusesParamsIndustry, params *GetDataRecipientsStatusesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataRecipientsStatusesRequest(c.Server, industry, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJWKS(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJWKSRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetOpenIdProviderConfigRequest generates requests for GetOpenIdProviderConfig
func NewGetOpenIdProviderConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/.well-known/openid-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDataHolderBrandsRequest generates requests for GetDataHolderBrands
func NewGetDataHolderBrandsRequest(server string, industry GetDataHolderBrandsParamsIndustry, params *GetDataHolderBrandsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "industry", runtime.ParamLocationPath, industry)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cdr-register/v1/%s/data-holders/brands", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.UpdatedSince != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated-since", runtime.ParamLocationQuery, *params.UpdatedSince); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam0)

	if params.XV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, *params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam1)
	}

	if params.XMinV != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam2)
	}

	return req, nil
}

// NewGetDataHolderBrandsSummaryRequest generates requests for GetDataHolderBrandsSummary
func NewGetDataHolderBrandsSummaryRequest(server string, industry GetDataHolderBrandsSummaryParamsIndustry, params *GetDataHolderBrandsSummaryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "industry", runtime.ParamLocationPath, industry)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cdr-register/v1/%s/data-holders/brands/summary", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.IfNoneMatch != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-None-Match", headerParam2)
	}

	return req, nil
}

// NewGetDataHolderStatusesRequest generates requests for GetDataHolderStatuses
func NewGetDataHolderStatusesRequest(server string, industry GetDataHolderStatusesParamsIndustry, params *GetDataHolderStatusesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "industry", runtime.ParamLocationPath, industry)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cdr-register/v1/%s/data-holders/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XV != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, *params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)
	}

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.IfNoneMatch != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-None-Match", headerParam2)
	}

	return req, nil
}

// NewGetDataRecipientsRequest generates requests for GetDataRecipients
func NewGetDataRecipientsRequest(server string, industry GetDataRecipientsParamsIndustry, params *GetDataRecipientsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "industry", runtime.ParamLocationPath, industry)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cdr-register/v1/%s/data-recipients", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XV != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, *params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)
	}

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.IfNoneMatch != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-None-Match", headerParam2)
	}

	return req, nil
}

// NewGetSoftwareProductsStatusesRequest generates requests for GetSoftwareProductsStatuses
func NewGetSoftwareProductsStatusesRequest(server string, industry GetSoftwareProductsStatusesParamsIndustry, params *GetSoftwareProductsStatusesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "industry", runtime.ParamLocationPath, industry)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cdr-register/v1/%s/data-recipients/brands/software-products/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XV != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, *params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)
	}

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.IfNoneMatch != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-None-Match", headerParam2)
	}

	return req, nil
}

// NewGetSoftwareStatementAssertionRequest generates requests for GetSoftwareStatementAssertion
func NewGetSoftwareStatementAssertionRequest(server string, industry GetSoftwareStatementAssertionParamsIndustry, dataRecipientBrandId string, softwareProductId string, params *GetSoftwareStatementAssertionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "industry", runtime.ParamLocationPath, industry)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "dataRecipientBrandId", runtime.ParamLocationPath, dataRecipientBrandId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "softwareProductId", runtime.ParamLocationPath, softwareProductId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cdr-register/v1/%s/data-recipients/brands/%s/software-products/%s/ssa", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XV != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, *params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)
	}

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	var headerParam2 string

	headerParam2, err = runtime.StyleParamWithLocation("simple", false, "Authorization", runtime.ParamLocationHeader, params.Authorization)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", headerParam2)

	return req, nil
}

// NewGetDataRecipientsStatusesRequest generates requests for GetDataRecipientsStatuses
func NewGetDataRecipientsStatusesRequest(server string, industry GetDataRecipientsStatusesParamsIndustry, params *GetDataRecipientsStatusesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "industry", runtime.ParamLocationPath, industry)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cdr-register/v1/%s/data-recipients/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XV != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, *params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)
	}

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.IfNoneMatch != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-None-Match", headerParam2)
	}

	return req, nil
}

// NewGetJWKSRequest generates requests for GetJWKS
func NewGetJWKSRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jwks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetOpenIdProviderConfig request
	GetOpenIdProviderConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenIdProviderConfigResponse, error)

	// GetDataHolderBrands request
	GetDataHolderBrandsWithResponse(ctx context.Context, industry GetDataHolderBrandsParamsIndustry, params *GetDataHolderBrandsParams, reqEditors ...RequestEditorFn) (*GetDataHolderBrandsResponse, error)

	// GetDataHolderBrandsSummary request
	GetDataHolderBrandsSummaryWithResponse(ctx context.Context, industry GetDataHolderBrandsSummaryParamsIndustry, params *GetDataHolderBrandsSummaryParams, reqEditors ...RequestEditorFn) (*GetDataHolderBrandsSummaryResponse, error)

	// GetDataHolderStatuses request
	GetDataHolderStatusesWithResponse(ctx context.Context, industry GetDataHolderStatusesParamsIndustry, params *GetDataHolderStatusesParams, reqEditors ...RequestEditorFn) (*GetDataHolderStatusesResponse, error)

	// GetDataRecipients request
	GetDataRecipientsWithResponse(ctx context.Context, industry GetDataRecipientsParamsIndustry, params *GetDataRecipientsParams, reqEditors ...RequestEditorFn) (*GetDataRecipientsResponse, error)

	// GetSoftwareProductsStatuses request
	GetSoftwareProductsStatusesWithResponse(ctx context.Context, industry GetSoftwareProductsStatusesParamsIndustry, params *GetSoftwareProductsStatusesParams, reqEditors ...RequestEditorFn) (*GetSoftwareProductsStatusesResponse, error)

	// GetSoftwareStatementAssertion request
	GetSoftwareStatementAssertionWithResponse(ctx context.Context, industry GetSoftwareStatementAssertionParamsIndustry, dataRecipientBrandId string, softwareProductId string, params *GetSoftwareStatementAssertionParams, reqEditors ...RequestEditorFn) (*GetSoftwareStatementAssertionResponse, error)

	// GetDataRecipientsStatuses request
	GetDataRecipientsStatusesWithResponse(ctx context.Context, industry GetDataRecipientsStatusesParamsIndustry, params *GetDataRecipientsStatusesParams, reqEditors ...RequestEditorFn) (*GetDataRecipientsStatusesResponse, error)

	// GetJWKS request
	GetJWKSWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetJWKSResponse, error)
}

type GetOpenIdProviderConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseOpenIDProviderConfigMetadata
}

// Status returns HTTPResponse.Status
func (r GetOpenIdProviderConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenIdProviderConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataHolderBrandsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseRegisterDataHolderBrandList
	JSON400      *ResponseErrorListV2
	JSON401      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetDataHolderBrandsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataHolderBrandsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataHolderBrandsSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseDataHoldersBrandSummaryList
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetDataHolderBrandsSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataHolderBrandsSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataHolderStatusesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataHoldersStatusList
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetDataHolderStatusesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataHolderStatusesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataRecipientsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseRegisterDataRecipientList
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetDataRecipientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataRecipientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSoftwareProductsStatusesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SoftwareProductsStatusList
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetSoftwareProductsStatusesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSoftwareProductsStatusesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSoftwareStatementAssertionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON400      *ResponseErrorListV2
	JSON401      *ResponseErrorListV2
	JSON403      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetSoftwareStatementAssertionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSoftwareStatementAssertionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataRecipientsStatusesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataRecipientsStatusList
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetDataRecipientsStatusesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataRecipientsStatusesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJWKSResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseJWKS
}

// Status returns HTTPResponse.Status
func (r GetJWKSResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJWKSResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetOpenIdProviderConfigWithResponse request returning *GetOpenIdProviderConfigResponse
func (c *ClientWithResponses) GetOpenIdProviderConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenIdProviderConfigResponse, error) {
	rsp, err := c.GetOpenIdProviderConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenIdProviderConfigResponse(rsp)
}

// GetDataHolderBrandsWithResponse request returning *GetDataHolderBrandsResponse
func (c *ClientWithResponses) GetDataHolderBrandsWithResponse(ctx context.Context, industry GetDataHolderBrandsParamsIndustry, params *GetDataHolderBrandsParams, reqEditors ...RequestEditorFn) (*GetDataHolderBrandsResponse, error) {
	rsp, err := c.GetDataHolderBrands(ctx, industry, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataHolderBrandsResponse(rsp)
}

// GetDataHolderBrandsSummaryWithResponse request returning *GetDataHolderBrandsSummaryResponse
func (c *ClientWithResponses) GetDataHolderBrandsSummaryWithResponse(ctx context.Context, industry GetDataHolderBrandsSummaryParamsIndustry, params *GetDataHolderBrandsSummaryParams, reqEditors ...RequestEditorFn) (*GetDataHolderBrandsSummaryResponse, error) {
	rsp, err := c.GetDataHolderBrandsSummary(ctx, industry, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataHolderBrandsSummaryResponse(rsp)
}

// GetDataHolderStatusesWithResponse request returning *GetDataHolderStatusesResponse
func (c *ClientWithResponses) GetDataHolderStatusesWithResponse(ctx context.Context, industry GetDataHolderStatusesParamsIndustry, params *GetDataHolderStatusesParams, reqEditors ...RequestEditorFn) (*GetDataHolderStatusesResponse, error) {
	rsp, err := c.GetDataHolderStatuses(ctx, industry, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataHolderStatusesResponse(rsp)
}

// GetDataRecipientsWithResponse request returning *GetDataRecipientsResponse
func (c *ClientWithResponses) GetDataRecipientsWithResponse(ctx context.Context, industry GetDataRecipientsParamsIndustry, params *GetDataRecipientsParams, reqEditors ...RequestEditorFn) (*GetDataRecipientsResponse, error) {
	rsp, err := c.GetDataRecipients(ctx, industry, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataRecipientsResponse(rsp)
}

// GetSoftwareProductsStatusesWithResponse request returning *GetSoftwareProductsStatusesResponse
func (c *ClientWithResponses) GetSoftwareProductsStatusesWithResponse(ctx context.Context, industry GetSoftwareProductsStatusesParamsIndustry, params *GetSoftwareProductsStatusesParams, reqEditors ...RequestEditorFn) (*GetSoftwareProductsStatusesResponse, error) {
	rsp, err := c.GetSoftwareProductsStatuses(ctx, industry, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSoftwareProductsStatusesResponse(rsp)
}

// GetSoftwareStatementAssertionWithResponse request returning *GetSoftwareStatementAssertionResponse
func (c *ClientWithResponses) GetSoftwareStatementAssertionWithResponse(ctx context.Context, industry GetSoftwareStatementAssertionParamsIndustry, dataRecipientBrandId string, softwareProductId string, params *GetSoftwareStatementAssertionParams, reqEditors ...RequestEditorFn) (*GetSoftwareStatementAssertionResponse, error) {
	rsp, err := c.GetSoftwareStatementAssertion(ctx, industry, dataRecipientBrandId, softwareProductId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSoftwareStatementAssertionResponse(rsp)
}

// GetDataRecipientsStatusesWithResponse request returning *GetDataRecipientsStatusesResponse
func (c *ClientWithResponses) GetDataRecipientsStatusesWithResponse(ctx context.Context, industry GetDataRecipientsStatusesParamsIndustry, params *GetDataRecipientsStatusesParams, reqEditors ...RequestEditorFn) (*GetDataRecipientsStatusesResponse, error) {
	rsp, err := c.GetDataRecipientsStatuses(ctx, industry, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataRecipientsStatusesResponse(rsp)
}

// GetJWKSWithResponse request returning *GetJWKSResponse
func (c *ClientWithResponses) GetJWKSWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetJWKSResponse, error) {
	rsp, err := c.GetJWKS(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJWKSResponse(rsp)
}

// ParseGetOpenIdProviderConfigResponse parses an HTTP response from a GetOpenIdProviderConfigWithResponse call
func ParseGetOpenIdProviderConfigResponse(rsp *http.Response) (*GetOpenIdProviderConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenIdProviderConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseOpenIDProviderConfigMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDataHolderBrandsResponse parses an HTTP response from a GetDataHolderBrandsWithResponse call
func ParseGetDataHolderBrandsResponse(rsp *http.Response) (*GetDataHolderBrandsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataHolderBrandsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseRegisterDataHolderBrandList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetDataHolderBrandsSummaryResponse parses an HTTP response from a GetDataHolderBrandsSummaryWithResponse call
func ParseGetDataHolderBrandsSummaryResponse(rsp *http.Response) (*GetDataHolderBrandsSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataHolderBrandsSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseDataHoldersBrandSummaryList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetDataHolderStatusesResponse parses an HTTP response from a GetDataHolderStatusesWithResponse call
func ParseGetDataHolderStatusesResponse(rsp *http.Response) (*GetDataHolderStatusesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataHolderStatusesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataHoldersStatusList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetDataRecipientsResponse parses an HTTP response from a GetDataRecipientsWithResponse call
func ParseGetDataRecipientsResponse(rsp *http.Response) (*GetDataRecipientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataRecipientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseRegisterDataRecipientList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetSoftwareProductsStatusesResponse parses an HTTP response from a GetSoftwareProductsStatusesWithResponse call
func ParseGetSoftwareProductsStatusesResponse(rsp *http.Response) (*GetSoftwareProductsStatusesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSoftwareProductsStatusesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SoftwareProductsStatusList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetSoftwareStatementAssertionResponse parses an HTTP response from a GetSoftwareStatementAssertionWithResponse call
func ParseGetSoftwareStatementAssertionResponse(rsp *http.Response) (*GetSoftwareStatementAssertionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSoftwareStatementAssertionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetDataRecipientsStatusesResponse parses an HTTP response from a GetDataRecipientsStatusesWithResponse call
func ParseGetDataRecipientsStatusesResponse(rsp *http.Response) (*GetDataRecipientsStatusesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataRecipientsStatusesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataRecipientsStatusList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetJWKSResponse parses an HTTP response from a GetJWKSWithResponse call
func ParseGetJWKSResponse(rsp *http.Response) (*GetJWKSResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJWKSResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseJWKS
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
