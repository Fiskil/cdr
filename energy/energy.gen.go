// Package energy provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package energy

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// Defines values for CommonPhysicalAddressAddressUType.
const (
	Paf    CommonPhysicalAddressAddressUType = "paf"
	Simple CommonPhysicalAddressAddressUType = "simple"
)

// Defines values for EnergyAccountBaseV2OpenStatus.
const (
	EnergyAccountBaseV2OpenStatusCLOSED EnergyAccountBaseV2OpenStatus = "CLOSED"
	EnergyAccountBaseV2OpenStatusOPEN   EnergyAccountBaseV2OpenStatus = "OPEN"
)

// Defines values for EnergyAccountDetailV2OpenStatus.
const (
	EnergyAccountDetailV2OpenStatusCLOSED EnergyAccountDetailV2OpenStatus = "CLOSED"
	EnergyAccountDetailV2OpenStatusOPEN   EnergyAccountDetailV2OpenStatus = "OPEN"
)

// Defines values for EnergyAccountDetailV2PlansPlanDetailFuelType.
const (
	EnergyAccountDetailV2PlansPlanDetailFuelTypeDUAL        EnergyAccountDetailV2PlansPlanDetailFuelType = "DUAL"
	EnergyAccountDetailV2PlansPlanDetailFuelTypeELECTRICITY EnergyAccountDetailV2PlansPlanDetailFuelType = "ELECTRICITY"
	EnergyAccountDetailV2PlansPlanDetailFuelTypeGAS         EnergyAccountDetailV2PlansPlanDetailFuelType = "GAS"
)

// Defines values for EnergyAccountV2OpenStatus.
const (
	EnergyAccountV2OpenStatusCLOSED EnergyAccountV2OpenStatus = "CLOSED"
	EnergyAccountV2OpenStatusOPEN   EnergyAccountV2OpenStatus = "OPEN"
)

// Defines values for EnergyBillingDemandTransactionCalculationFactorsType.
const (
	EnergyBillingDemandTransactionCalculationFactorsTypeDLF EnergyBillingDemandTransactionCalculationFactorsType = "DLF"
	EnergyBillingDemandTransactionCalculationFactorsTypeMLF EnergyBillingDemandTransactionCalculationFactorsType = "MLF"
)

// Defines values for EnergyBillingDemandTransactionTimeOfUseType.
const (
	EnergyBillingDemandTransactionTimeOfUseTypeAGGREGATE           EnergyBillingDemandTransactionTimeOfUseType = "AGGREGATE"
	EnergyBillingDemandTransactionTimeOfUseTypeCONTROLLEDLOAD      EnergyBillingDemandTransactionTimeOfUseType = "CONTROLLED_LOAD"
	EnergyBillingDemandTransactionTimeOfUseTypeOFFPEAK             EnergyBillingDemandTransactionTimeOfUseType = "OFF_PEAK"
	EnergyBillingDemandTransactionTimeOfUseTypeOFFPEAKDEMANDCHARGE EnergyBillingDemandTransactionTimeOfUseType = "OFF_PEAK_DEMAND_CHARGE"
	EnergyBillingDemandTransactionTimeOfUseTypePEAK                EnergyBillingDemandTransactionTimeOfUseType = "PEAK"
	EnergyBillingDemandTransactionTimeOfUseTypeSHOULDER            EnergyBillingDemandTransactionTimeOfUseType = "SHOULDER"
	EnergyBillingDemandTransactionTimeOfUseTypeSHOULDER1           EnergyBillingDemandTransactionTimeOfUseType = "SHOULDER1"
	EnergyBillingDemandTransactionTimeOfUseTypeSHOULDER2           EnergyBillingDemandTransactionTimeOfUseType = "SHOULDER2"
	EnergyBillingDemandTransactionTimeOfUseTypeSOLAR               EnergyBillingDemandTransactionTimeOfUseType = "SOLAR"
)

// Defines values for EnergyBillingOtherTransactionCalculationFactorsType.
const (
	EnergyBillingOtherTransactionCalculationFactorsTypeDLF EnergyBillingOtherTransactionCalculationFactorsType = "DLF"
	EnergyBillingOtherTransactionCalculationFactorsTypeMLF EnergyBillingOtherTransactionCalculationFactorsType = "MLF"
)

// Defines values for EnergyBillingOtherTransactionType.
const (
	EnergyBillingOtherTransactionTypeENVIRONMENTAL EnergyBillingOtherTransactionType = "ENVIRONMENTAL"
	EnergyBillingOtherTransactionTypeMETERING      EnergyBillingOtherTransactionType = "METERING"
	EnergyBillingOtherTransactionTypeNETWORK       EnergyBillingOtherTransactionType = "NETWORK"
	EnergyBillingOtherTransactionTypeOTHER         EnergyBillingOtherTransactionType = "OTHER"
	EnergyBillingOtherTransactionTypeRCTI          EnergyBillingOtherTransactionType = "RCTI"
	EnergyBillingOtherTransactionTypeREGULATED     EnergyBillingOtherTransactionType = "REGULATED"
	EnergyBillingOtherTransactionTypeRETAILSERVICE EnergyBillingOtherTransactionType = "RETAIL_SERVICE"
)

// Defines values for EnergyBillingPaymentTransactionMethod.
const (
	EnergyBillingPaymentTransactionMethodBPAY        EnergyBillingPaymentTransactionMethod = "BPAY"
	EnergyBillingPaymentTransactionMethodCARD        EnergyBillingPaymentTransactionMethod = "CARD"
	EnergyBillingPaymentTransactionMethodCASH        EnergyBillingPaymentTransactionMethod = "CASH"
	EnergyBillingPaymentTransactionMethodCHEQUE      EnergyBillingPaymentTransactionMethod = "CHEQUE"
	EnergyBillingPaymentTransactionMethodDIRECTDEBIT EnergyBillingPaymentTransactionMethod = "DIRECT_DEBIT"
	EnergyBillingPaymentTransactionMethodOTHER       EnergyBillingPaymentTransactionMethod = "OTHER"
	EnergyBillingPaymentTransactionMethodTRANSFER    EnergyBillingPaymentTransactionMethod = "TRANSFER"
)

// Defines values for EnergyBillingTransactionTransactionUType.
const (
	Demand       EnergyBillingTransactionTransactionUType = "demand"
	OnceOff      EnergyBillingTransactionTransactionUType = "onceOff"
	OtherCharges EnergyBillingTransactionTransactionUType = "otherCharges"
	Payment      EnergyBillingTransactionTransactionUType = "payment"
	Usage        EnergyBillingTransactionTransactionUType = "usage"
)

// Defines values for EnergyBillingUsageTransactionCalculationFactorsType.
const (
	DLF EnergyBillingUsageTransactionCalculationFactorsType = "DLF"
	MLF EnergyBillingUsageTransactionCalculationFactorsType = "MLF"
)

// Defines values for EnergyBillingUsageTransactionMeasureUnit.
const (
	EnergyBillingUsageTransactionMeasureUnitDAYS  EnergyBillingUsageTransactionMeasureUnit = "DAYS"
	EnergyBillingUsageTransactionMeasureUnitKVA   EnergyBillingUsageTransactionMeasureUnit = "KVA"
	EnergyBillingUsageTransactionMeasureUnitKVAR  EnergyBillingUsageTransactionMeasureUnit = "KVAR"
	EnergyBillingUsageTransactionMeasureUnitKVARH EnergyBillingUsageTransactionMeasureUnit = "KVARH"
	EnergyBillingUsageTransactionMeasureUnitKW    EnergyBillingUsageTransactionMeasureUnit = "KW"
	EnergyBillingUsageTransactionMeasureUnitKWH   EnergyBillingUsageTransactionMeasureUnit = "KWH"
	EnergyBillingUsageTransactionMeasureUnitMETER EnergyBillingUsageTransactionMeasureUnit = "METER"
	EnergyBillingUsageTransactionMeasureUnitMONTH EnergyBillingUsageTransactionMeasureUnit = "MONTH"
)

// Defines values for EnergyBillingUsageTransactionTimeOfUseType.
const (
	EnergyBillingUsageTransactionTimeOfUseTypeAGGREGATE           EnergyBillingUsageTransactionTimeOfUseType = "AGGREGATE"
	EnergyBillingUsageTransactionTimeOfUseTypeCONTROLLEDLOAD      EnergyBillingUsageTransactionTimeOfUseType = "CONTROLLED_LOAD"
	EnergyBillingUsageTransactionTimeOfUseTypeOFFPEAK             EnergyBillingUsageTransactionTimeOfUseType = "OFF_PEAK"
	EnergyBillingUsageTransactionTimeOfUseTypeOFFPEAKDEMANDCHARGE EnergyBillingUsageTransactionTimeOfUseType = "OFF_PEAK_DEMAND_CHARGE"
	EnergyBillingUsageTransactionTimeOfUseTypePEAK                EnergyBillingUsageTransactionTimeOfUseType = "PEAK"
	EnergyBillingUsageTransactionTimeOfUseTypeSHOULDER            EnergyBillingUsageTransactionTimeOfUseType = "SHOULDER"
	EnergyBillingUsageTransactionTimeOfUseTypeSHOULDER1           EnergyBillingUsageTransactionTimeOfUseType = "SHOULDER1"
	EnergyBillingUsageTransactionTimeOfUseTypeSHOULDER2           EnergyBillingUsageTransactionTimeOfUseType = "SHOULDER2"
	EnergyBillingUsageTransactionTimeOfUseTypeSOLAR               EnergyBillingUsageTransactionTimeOfUseType = "SOLAR"
)

// Defines values for EnergyConcessionAppliedTo.
const (
	CONTROLLEDLOAD EnergyConcessionAppliedTo = "CONTROLLED_LOAD"
	INVOICE        EnergyConcessionAppliedTo = "INVOICE"
	SERVICECHARGE  EnergyConcessionAppliedTo = "SERVICE_CHARGE"
	USAGE          EnergyConcessionAppliedTo = "USAGE"
)

// Defines values for EnergyConcessionType.
const (
	EnergyConcessionTypeFIXEDAMOUNT     EnergyConcessionType = "FIXED_AMOUNT"
	EnergyConcessionTypeFIXEDPERCENTAGE EnergyConcessionType = "FIXED_PERCENTAGE"
	EnergyConcessionTypeVARIABLE        EnergyConcessionType = "VARIABLE"
)

// Defines values for EnergyDerRecordAcConnectionsDerDevicesStatus.
const (
	EnergyDerRecordAcConnectionsDerDevicesStatusACTIVE         EnergyDerRecordAcConnectionsDerDevicesStatus = "ACTIVE"
	EnergyDerRecordAcConnectionsDerDevicesStatusDECOMMISSIONED EnergyDerRecordAcConnectionsDerDevicesStatus = "DECOMMISSIONED"
	EnergyDerRecordAcConnectionsDerDevicesStatusINACTIVE       EnergyDerRecordAcConnectionsDerDevicesStatus = "INACTIVE"
)

// Defines values for EnergyDerRecordAcConnectionsDerDevicesType.
const (
	EnergyDerRecordAcConnectionsDerDevicesTypeFOSSIL     EnergyDerRecordAcConnectionsDerDevicesType = "FOSSIL"
	EnergyDerRecordAcConnectionsDerDevicesTypeGEOTHERMAL EnergyDerRecordAcConnectionsDerDevicesType = "GEOTHERMAL"
	EnergyDerRecordAcConnectionsDerDevicesTypeHYDRO      EnergyDerRecordAcConnectionsDerDevicesType = "HYDRO"
	EnergyDerRecordAcConnectionsDerDevicesTypeOTHER      EnergyDerRecordAcConnectionsDerDevicesType = "OTHER"
	EnergyDerRecordAcConnectionsDerDevicesTypeRENEWABLE  EnergyDerRecordAcConnectionsDerDevicesType = "RENEWABLE"
	EnergyDerRecordAcConnectionsDerDevicesTypeSOLARPV    EnergyDerRecordAcConnectionsDerDevicesType = "SOLAR_PV"
	EnergyDerRecordAcConnectionsDerDevicesTypeSTORAGE    EnergyDerRecordAcConnectionsDerDevicesType = "STORAGE"
	EnergyDerRecordAcConnectionsDerDevicesTypeWIND       EnergyDerRecordAcConnectionsDerDevicesType = "WIND"
)

// Defines values for EnergyDerRecordAcConnectionsEquipmentType.
const (
	EnergyDerRecordAcConnectionsEquipmentTypeINVERTER EnergyDerRecordAcConnectionsEquipmentType = "INVERTER"
	EnergyDerRecordAcConnectionsEquipmentTypeOTHER    EnergyDerRecordAcConnectionsEquipmentType = "OTHER"
)

// Defines values for EnergyDerRecordAcConnectionsStatus.
const (
	EnergyDerRecordAcConnectionsStatusACTIVE         EnergyDerRecordAcConnectionsStatus = "ACTIVE"
	EnergyDerRecordAcConnectionsStatusDECOMMISSIONED EnergyDerRecordAcConnectionsStatus = "DECOMMISSIONED"
	EnergyDerRecordAcConnectionsStatusINACTIVE       EnergyDerRecordAcConnectionsStatus = "INACTIVE"
)

// Defines values for EnergyInvoicePaymentStatus.
const (
	NOTPAID       EnergyInvoicePaymentStatus = "NOT_PAID"
	PAID          EnergyInvoicePaymentStatus = "PAID"
	PARTIALLYPAID EnergyInvoicePaymentStatus = "PARTIALLY_PAID"
)

// Defines values for EnergyInvoiceElectricityUsageChargesOtherChargesType.
const (
	EnergyInvoiceElectricityUsageChargesOtherChargesTypeENVIRONMENTAL EnergyInvoiceElectricityUsageChargesOtherChargesType = "ENVIRONMENTAL"
	EnergyInvoiceElectricityUsageChargesOtherChargesTypeMETERING      EnergyInvoiceElectricityUsageChargesOtherChargesType = "METERING"
	EnergyInvoiceElectricityUsageChargesOtherChargesTypeNETWORK       EnergyInvoiceElectricityUsageChargesOtherChargesType = "NETWORK"
	EnergyInvoiceElectricityUsageChargesOtherChargesTypeOTHER         EnergyInvoiceElectricityUsageChargesOtherChargesType = "OTHER"
	EnergyInvoiceElectricityUsageChargesOtherChargesTypeRCTI          EnergyInvoiceElectricityUsageChargesOtherChargesType = "RCTI"
	EnergyInvoiceElectricityUsageChargesOtherChargesTypeREGULATED     EnergyInvoiceElectricityUsageChargesOtherChargesType = "REGULATED"
	EnergyInvoiceElectricityUsageChargesOtherChargesTypeRETAILSERVICE EnergyInvoiceElectricityUsageChargesOtherChargesType = "RETAIL_SERVICE"
)

// Defines values for EnergyInvoiceGasUsageChargesOtherChargesType.
const (
	EnergyInvoiceGasUsageChargesOtherChargesTypeENVIRONMENTAL EnergyInvoiceGasUsageChargesOtherChargesType = "ENVIRONMENTAL"
	EnergyInvoiceGasUsageChargesOtherChargesTypeMETERING      EnergyInvoiceGasUsageChargesOtherChargesType = "METERING"
	EnergyInvoiceGasUsageChargesOtherChargesTypeNETWORK       EnergyInvoiceGasUsageChargesOtherChargesType = "NETWORK"
	EnergyInvoiceGasUsageChargesOtherChargesTypeOTHER         EnergyInvoiceGasUsageChargesOtherChargesType = "OTHER"
	EnergyInvoiceGasUsageChargesOtherChargesTypeRCTI          EnergyInvoiceGasUsageChargesOtherChargesType = "RCTI"
	EnergyInvoiceGasUsageChargesOtherChargesTypeREGULATED     EnergyInvoiceGasUsageChargesOtherChargesType = "REGULATED"
	EnergyInvoiceGasUsageChargesOtherChargesTypeRETAILSERVICE EnergyInvoiceGasUsageChargesOtherChargesType = "RETAIL_SERVICE"
)

// Defines values for EnergyPaymentScheduleCardDebitCalculationType.
const (
	EnergyPaymentScheduleCardDebitCalculationTypeBALANCE    EnergyPaymentScheduleCardDebitCalculationType = "BALANCE"
	EnergyPaymentScheduleCardDebitCalculationTypeCALCULATED EnergyPaymentScheduleCardDebitCalculationType = "CALCULATED"
	EnergyPaymentScheduleCardDebitCalculationTypeSTATIC     EnergyPaymentScheduleCardDebitCalculationType = "STATIC"
)

// Defines values for EnergyPaymentScheduleCardDebitCardScheme.
const (
	EnergyPaymentScheduleCardDebitCardSchemeAMEX       EnergyPaymentScheduleCardDebitCardScheme = "AMEX"
	EnergyPaymentScheduleCardDebitCardSchemeDINERS     EnergyPaymentScheduleCardDebitCardScheme = "DINERS"
	EnergyPaymentScheduleCardDebitCardSchemeMASTERCARD EnergyPaymentScheduleCardDebitCardScheme = "MASTERCARD"
	EnergyPaymentScheduleCardDebitCardSchemeOTHER      EnergyPaymentScheduleCardDebitCardScheme = "OTHER"
	EnergyPaymentScheduleCardDebitCardSchemeUNKNOWN    EnergyPaymentScheduleCardDebitCardScheme = "UNKNOWN"
	EnergyPaymentScheduleCardDebitCardSchemeVISA       EnergyPaymentScheduleCardDebitCardScheme = "VISA"
)

// Defines values for EnergyPaymentScheduleDigitalWalletCalculationType.
const (
	EnergyPaymentScheduleDigitalWalletCalculationTypeBALANCE    EnergyPaymentScheduleDigitalWalletCalculationType = "BALANCE"
	EnergyPaymentScheduleDigitalWalletCalculationTypeCALCULATED EnergyPaymentScheduleDigitalWalletCalculationType = "CALCULATED"
	EnergyPaymentScheduleDigitalWalletCalculationTypeSTATIC     EnergyPaymentScheduleDigitalWalletCalculationType = "STATIC"
)

// Defines values for EnergyPaymentScheduleDigitalWalletProvider.
const (
	EnergyPaymentScheduleDigitalWalletProviderOTHER    EnergyPaymentScheduleDigitalWalletProvider = "OTHER"
	EnergyPaymentScheduleDigitalWalletProviderPAYPALAU EnergyPaymentScheduleDigitalWalletProvider = "PAYPAL_AU"
)

// Defines values for EnergyPaymentScheduleDigitalWalletType.
const (
	CONTACTNAME EnergyPaymentScheduleDigitalWalletType = "CONTACT_NAME"
	EMAIL       EnergyPaymentScheduleDigitalWalletType = "EMAIL"
	TELEPHONE   EnergyPaymentScheduleDigitalWalletType = "TELEPHONE"
)

// Defines values for EnergyPaymentScheduleDirectDebitCalculationType.
const (
	BALANCE    EnergyPaymentScheduleDirectDebitCalculationType = "BALANCE"
	CALCULATED EnergyPaymentScheduleDirectDebitCalculationType = "CALCULATED"
	STATIC     EnergyPaymentScheduleDirectDebitCalculationType = "STATIC"
)

// Defines values for EnergyPaymentSchedulePaymentScheduleUType.
const (
	CardDebit     EnergyPaymentSchedulePaymentScheduleUType = "cardDebit"
	DigitalWallet EnergyPaymentSchedulePaymentScheduleUType = "digitalWallet"
	DirectDebit   EnergyPaymentSchedulePaymentScheduleUType = "directDebit"
	ManualPayment EnergyPaymentSchedulePaymentScheduleUType = "manualPayment"
)

// Defines values for EnergyPlanCustomerType.
const (
	EnergyPlanCustomerTypeBUSINESS    EnergyPlanCustomerType = "BUSINESS"
	EnergyPlanCustomerTypeRESIDENTIAL EnergyPlanCustomerType = "RESIDENTIAL"
)

// Defines values for EnergyPlanFuelType.
const (
	EnergyPlanFuelTypeDUAL        EnergyPlanFuelType = "DUAL"
	EnergyPlanFuelTypeELECTRICITY EnergyPlanFuelType = "ELECTRICITY"
	EnergyPlanFuelTypeGAS         EnergyPlanFuelType = "GAS"
)

// Defines values for EnergyPlanType.
const (
	EnergyPlanTypeMARKET    EnergyPlanType = "MARKET"
	EnergyPlanTypeREGULATED EnergyPlanType = "REGULATED"
	EnergyPlanTypeSTANDING  EnergyPlanType = "STANDING"
)

// Defines values for EnergyPlanContractPaymentOption.
const (
	EnergyPlanContractPaymentOptionBPAY        EnergyPlanContractPaymentOption = "BPAY"
	EnergyPlanContractPaymentOptionCREDITCARD  EnergyPlanContractPaymentOption = "CREDIT_CARD"
	EnergyPlanContractPaymentOptionDIRECTDEBIT EnergyPlanContractPaymentOption = "DIRECT_DEBIT"
	EnergyPlanContractPaymentOptionOTHER       EnergyPlanContractPaymentOption = "OTHER"
	EnergyPlanContractPaymentOptionPAPERBILL   EnergyPlanContractPaymentOption = "PAPER_BILL"
)

// Defines values for EnergyPlanContractPricingModel.
const (
	EnergyPlanContractPricingModelFLEXIBLE           EnergyPlanContractPricingModel = "FLEXIBLE"
	EnergyPlanContractPricingModelFLEXIBLECONTLOAD   EnergyPlanContractPricingModel = "FLEXIBLE_CONT_LOAD"
	EnergyPlanContractPricingModelQUOTA              EnergyPlanContractPricingModel = "QUOTA"
	EnergyPlanContractPricingModelSINGLERATE         EnergyPlanContractPricingModel = "SINGLE_RATE"
	EnergyPlanContractPricingModelSINGLERATECONTLOAD EnergyPlanContractPricingModel = "SINGLE_RATE_CONT_LOAD"
	EnergyPlanContractPricingModelTIMEOFUSE          EnergyPlanContractPricingModel = "TIME_OF_USE"
	EnergyPlanContractPricingModelTIMEOFUSECONTLOAD  EnergyPlanContractPricingModel = "TIME_OF_USE_CONT_LOAD"
)

// Defines values for EnergyPlanContractTimeZone.
const (
	EnergyPlanContractTimeZoneAEST  EnergyPlanContractTimeZone = "AEST"
	EnergyPlanContractTimeZoneLOCAL EnergyPlanContractTimeZone = "LOCAL"
)

// Defines values for EnergyPlanContractFullPaymentOption.
const (
	EnergyPlanContractFullPaymentOptionBPAY        EnergyPlanContractFullPaymentOption = "BPAY"
	EnergyPlanContractFullPaymentOptionCREDITCARD  EnergyPlanContractFullPaymentOption = "CREDIT_CARD"
	EnergyPlanContractFullPaymentOptionDIRECTDEBIT EnergyPlanContractFullPaymentOption = "DIRECT_DEBIT"
	EnergyPlanContractFullPaymentOptionOTHER       EnergyPlanContractFullPaymentOption = "OTHER"
	EnergyPlanContractFullPaymentOptionPAPERBILL   EnergyPlanContractFullPaymentOption = "PAPER_BILL"
)

// Defines values for EnergyPlanContractFullPricingModel.
const (
	EnergyPlanContractFullPricingModelFLEXIBLE           EnergyPlanContractFullPricingModel = "FLEXIBLE"
	EnergyPlanContractFullPricingModelFLEXIBLECONTLOAD   EnergyPlanContractFullPricingModel = "FLEXIBLE_CONT_LOAD"
	EnergyPlanContractFullPricingModelQUOTA              EnergyPlanContractFullPricingModel = "QUOTA"
	EnergyPlanContractFullPricingModelSINGLERATE         EnergyPlanContractFullPricingModel = "SINGLE_RATE"
	EnergyPlanContractFullPricingModelSINGLERATECONTLOAD EnergyPlanContractFullPricingModel = "SINGLE_RATE_CONT_LOAD"
	EnergyPlanContractFullPricingModelTIMEOFUSE          EnergyPlanContractFullPricingModel = "TIME_OF_USE"
	EnergyPlanContractFullPricingModelTIMEOFUSECONTLOAD  EnergyPlanContractFullPricingModel = "TIME_OF_USE_CONT_LOAD"
)

// Defines values for EnergyPlanContractFullTermType.
const (
	EnergyPlanContractFullTermTypeN1YEAR  EnergyPlanContractFullTermType = "1_YEAR"
	EnergyPlanContractFullTermTypeN2YEAR  EnergyPlanContractFullTermType = "2_YEAR"
	EnergyPlanContractFullTermTypeN3YEAR  EnergyPlanContractFullTermType = "3_YEAR"
	EnergyPlanContractFullTermTypeN4YEAR  EnergyPlanContractFullTermType = "4_YEAR"
	EnergyPlanContractFullTermTypeN5YEAR  EnergyPlanContractFullTermType = "5_YEAR"
	EnergyPlanContractFullTermTypeONGOING EnergyPlanContractFullTermType = "ONGOING"
	EnergyPlanContractFullTermTypeOTHER   EnergyPlanContractFullTermType = "OTHER"
)

// Defines values for EnergyPlanContractFullTimeZone.
const (
	EnergyPlanContractFullTimeZoneAEST  EnergyPlanContractFullTimeZone = "AEST"
	EnergyPlanContractFullTimeZoneLOCAL EnergyPlanContractFullTimeZone = "LOCAL"
)

// Defines values for EnergyPlanControlledLoadRateBlockUType.
const (
	EnergyPlanControlledLoadRateBlockUTypeSingleRate     EnergyPlanControlledLoadRateBlockUType = "singleRate"
	EnergyPlanControlledLoadRateBlockUTypeTimeOfUseRates EnergyPlanControlledLoadRateBlockUType = "timeOfUseRates"
)

// Defines values for EnergyPlanControlledLoadSingleRateRatesMeasureUnit.
const (
	EnergyPlanControlledLoadSingleRateRatesMeasureUnitDAYS  EnergyPlanControlledLoadSingleRateRatesMeasureUnit = "DAYS"
	EnergyPlanControlledLoadSingleRateRatesMeasureUnitKVA   EnergyPlanControlledLoadSingleRateRatesMeasureUnit = "KVA"
	EnergyPlanControlledLoadSingleRateRatesMeasureUnitKVAR  EnergyPlanControlledLoadSingleRateRatesMeasureUnit = "KVAR"
	EnergyPlanControlledLoadSingleRateRatesMeasureUnitKVARH EnergyPlanControlledLoadSingleRateRatesMeasureUnit = "KVARH"
	EnergyPlanControlledLoadSingleRateRatesMeasureUnitKW    EnergyPlanControlledLoadSingleRateRatesMeasureUnit = "KW"
	EnergyPlanControlledLoadSingleRateRatesMeasureUnitKWH   EnergyPlanControlledLoadSingleRateRatesMeasureUnit = "KWH"
	EnergyPlanControlledLoadSingleRateRatesMeasureUnitMETER EnergyPlanControlledLoadSingleRateRatesMeasureUnit = "METER"
	EnergyPlanControlledLoadSingleRateRatesMeasureUnitMONTH EnergyPlanControlledLoadSingleRateRatesMeasureUnit = "MONTH"
)

// Defines values for EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnit.
const (
	EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnitDAYS  EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnit = "DAYS"
	EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnitKVA   EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnit = "KVA"
	EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnitKVAR  EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnit = "KVAR"
	EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnitKVARH EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnit = "KVARH"
	EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnitKW    EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnit = "KW"
	EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnitKWH   EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnit = "KWH"
	EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnitMETER EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnit = "METER"
	EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnitMONTH EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnit = "MONTH"
)

// Defines values for EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDays.
const (
	EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDaysFRI            EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDays = "FRI"
	EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDaysMON            EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDays = "MON"
	EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDaysPUBLICHOLIDAYS EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDays = "PUBLIC_HOLIDAYS"
	EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDaysSAT            EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDays = "SAT"
	EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDaysSUN            EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDays = "SUN"
	EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDaysTHU            EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDays = "THU"
	EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDaysTUE            EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDays = "TUE"
	EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDaysWED            EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDays = "WED"
)

// Defines values for EnergyPlanControlledLoadTimeOfUseRatesType.
const (
	EnergyPlanControlledLoadTimeOfUseRatesTypeOFFPEAK     EnergyPlanControlledLoadTimeOfUseRatesType = "OFF_PEAK"
	EnergyPlanControlledLoadTimeOfUseRatesTypePEAK        EnergyPlanControlledLoadTimeOfUseRatesType = "PEAK"
	EnergyPlanControlledLoadTimeOfUseRatesTypeSHOULDER    EnergyPlanControlledLoadTimeOfUseRatesType = "SHOULDER"
	EnergyPlanControlledLoadTimeOfUseRatesTypeSOLARSPONGE EnergyPlanControlledLoadTimeOfUseRatesType = "SOLAR_SPONGE"
)

// Defines values for EnergyPlanDetailCustomerType.
const (
	EnergyPlanDetailCustomerTypeBUSINESS    EnergyPlanDetailCustomerType = "BUSINESS"
	EnergyPlanDetailCustomerTypeRESIDENTIAL EnergyPlanDetailCustomerType = "RESIDENTIAL"
)

// Defines values for EnergyPlanDetailFuelType.
const (
	DUAL        EnergyPlanDetailFuelType = "DUAL"
	ELECTRICITY EnergyPlanDetailFuelType = "ELECTRICITY"
	GAS         EnergyPlanDetailFuelType = "GAS"
)

// Defines values for EnergyPlanDetailType.
const (
	EnergyPlanDetailTypeMARKET    EnergyPlanDetailType = "MARKET"
	EnergyPlanDetailTypeREGULATED EnergyPlanDetailType = "REGULATED"
	EnergyPlanDetailTypeSTANDING  EnergyPlanDetailType = "STANDING"
)

// Defines values for EnergyPlanDiscountsCategory.
const (
	EnergyPlanDiscountsCategoryDIRECTDEBIT        EnergyPlanDiscountsCategory = "DIRECT_DEBIT"
	EnergyPlanDiscountsCategoryGUARANTEEDDISCOUNT EnergyPlanDiscountsCategory = "GUARANTEED_DISCOUNT"
	EnergyPlanDiscountsCategoryOTHER              EnergyPlanDiscountsCategory = "OTHER"
	EnergyPlanDiscountsCategoryPAYONTIME          EnergyPlanDiscountsCategory = "PAY_ON_TIME"
)

// Defines values for EnergyPlanDiscountsMethodUType.
const (
	FixedAmount          EnergyPlanDiscountsMethodUType = "fixedAmount"
	PercentOfBill        EnergyPlanDiscountsMethodUType = "percentOfBill"
	PercentOfUse         EnergyPlanDiscountsMethodUType = "percentOfUse"
	PercentOverThreshold EnergyPlanDiscountsMethodUType = "percentOverThreshold"
)

// Defines values for EnergyPlanDiscountsType.
const (
	EnergyPlanDiscountsTypeCONDITIONAL EnergyPlanDiscountsType = "CONDITIONAL"
	EnergyPlanDiscountsTypeGUARANTEED  EnergyPlanDiscountsType = "GUARANTEED"
	EnergyPlanDiscountsTypeOTHER       EnergyPlanDiscountsType = "OTHER"
)

// Defines values for EnergyPlanEligibilityType.
const (
	EnergyPlanEligibilityTypeCONTINGENTPLAN     EnergyPlanEligibilityType = "CONTINGENT_PLAN"
	EnergyPlanEligibilityTypeEXISTINGBASICMETER EnergyPlanEligibilityType = "EXISTING_BASIC_METER"
	EnergyPlanEligibilityTypeEXISTINGBATTERY    EnergyPlanEligibilityType = "EXISTING_BATTERY"
	EnergyPlanEligibilityTypeEXISTINGCUST       EnergyPlanEligibilityType = "EXISTING_CUST"
	EnergyPlanEligibilityTypeEXISTINGPOOL       EnergyPlanEligibilityType = "EXISTING_POOL"
	EnergyPlanEligibilityTypeEXISTINGSMARTMETER EnergyPlanEligibilityType = "EXISTING_SMART_METER"
	EnergyPlanEligibilityTypeEXISTINGSOLAR      EnergyPlanEligibilityType = "EXISTING_SOLAR"
	EnergyPlanEligibilityTypeGROUPBUYMEMBER     EnergyPlanEligibilityType = "GROUP_BUY_MEMBER"
	EnergyPlanEligibilityTypeLOYALTYMEMBER      EnergyPlanEligibilityType = "LOYALTY_MEMBER"
	EnergyPlanEligibilityTypeMINIMUMUSAGE       EnergyPlanEligibilityType = "MINIMUM_USAGE"
	EnergyPlanEligibilityTypeNEWCUSTOMER        EnergyPlanEligibilityType = "NEW_CUSTOMER"
	EnergyPlanEligibilityTypeNOSOLARFIT         EnergyPlanEligibilityType = "NO_SOLAR_FIT"
	EnergyPlanEligibilityTypeONLINEONLY         EnergyPlanEligibilityType = "ONLINE_ONLY"
	EnergyPlanEligibilityTypeORGMEMBER          EnergyPlanEligibilityType = "ORG_MEMBER"
	EnergyPlanEligibilityTypeOTHER              EnergyPlanEligibilityType = "OTHER"
	EnergyPlanEligibilityTypeREQEQUIPSUPPLIER   EnergyPlanEligibilityType = "REQ_EQUIP_SUPPLIER"
	EnergyPlanEligibilityTypeSENIORCARD         EnergyPlanEligibilityType = "SENIOR_CARD"
	EnergyPlanEligibilityTypeSMALLBUSINESS      EnergyPlanEligibilityType = "SMALL_BUSINESS"
	EnergyPlanEligibilityTypeSPECIFICLOCATION   EnergyPlanEligibilityType = "SPECIFIC_LOCATION"
	EnergyPlanEligibilityTypeSPORTCLUBMEMBER    EnergyPlanEligibilityType = "SPORT_CLUB_MEMBER"
	EnergyPlanEligibilityTypeTHIRDPARTYONLY     EnergyPlanEligibilityType = "THIRD_PARTY_ONLY"
)

// Defines values for EnergyPlanFeesTerm.
const (
	EnergyPlanFeesTermANNUAL        EnergyPlanFeesTerm = "ANNUAL"
	EnergyPlanFeesTermBIANNUAL      EnergyPlanFeesTerm = "BIANNUAL"
	EnergyPlanFeesTermDAILY         EnergyPlanFeesTerm = "DAILY"
	EnergyPlanFeesTermFIXED         EnergyPlanFeesTerm = "FIXED"
	EnergyPlanFeesTermMONTHLY       EnergyPlanFeesTerm = "MONTHLY"
	EnergyPlanFeesTermN1YEAR        EnergyPlanFeesTerm = "1_YEAR"
	EnergyPlanFeesTermN2YEAR        EnergyPlanFeesTerm = "2_YEAR"
	EnergyPlanFeesTermN3YEAR        EnergyPlanFeesTerm = "3_YEAR"
	EnergyPlanFeesTermN4YEAR        EnergyPlanFeesTerm = "4_YEAR"
	EnergyPlanFeesTermN5YEAR        EnergyPlanFeesTerm = "5_YEAR"
	EnergyPlanFeesTermPERCENTOFBILL EnergyPlanFeesTerm = "PERCENT_OF_BILL"
	EnergyPlanFeesTermVARIABLE      EnergyPlanFeesTerm = "VARIABLE"
	EnergyPlanFeesTermWEEKLY        EnergyPlanFeesTerm = "WEEKLY"
)

// Defines values for EnergyPlanFeesType.
const (
	EnergyPlanFeesTypeCCPROCESSING      EnergyPlanFeesType = "CC_PROCESSING"
	EnergyPlanFeesTypeCHEQUEDISHONOUR   EnergyPlanFeesType = "CHEQUE_DISHONOUR"
	EnergyPlanFeesTypeCONNECTION        EnergyPlanFeesType = "CONNECTION"
	EnergyPlanFeesTypeCONTRIBUTION      EnergyPlanFeesType = "CONTRIBUTION"
	EnergyPlanFeesTypeDDDISHONOUR       EnergyPlanFeesType = "DD_DISHONOUR"
	EnergyPlanFeesTypeDISCONNECTION     EnergyPlanFeesType = "DISCONNECTION"
	EnergyPlanFeesTypeDISCONNECTMOVEOUT EnergyPlanFeesType = "DISCONNECT_MOVE_OUT"
	EnergyPlanFeesTypeDISCONNECTNONPAY  EnergyPlanFeesType = "DISCONNECT_NON_PAY"
	EnergyPlanFeesTypeESTABLISHMENT     EnergyPlanFeesType = "ESTABLISHMENT"
	EnergyPlanFeesTypeEXIT              EnergyPlanFeesType = "EXIT"
	EnergyPlanFeesTypeLATEPAYMENT       EnergyPlanFeesType = "LATE_PAYMENT"
	EnergyPlanFeesTypeMEMBERSHIP        EnergyPlanFeesType = "MEMBERSHIP"
	EnergyPlanFeesTypeOTHER             EnergyPlanFeesType = "OTHER"
	EnergyPlanFeesTypePAPERBILL         EnergyPlanFeesType = "PAPER_BILL"
	EnergyPlanFeesTypePAYMENTPROCESSING EnergyPlanFeesType = "PAYMENT_PROCESSING"
	EnergyPlanFeesTypeRECONNECTION      EnergyPlanFeesType = "RECONNECTION"
)

// Defines values for EnergyPlanGreenPowerChargesScheme.
const (
	EnergyPlanGreenPowerChargesSchemeGREENPOWER EnergyPlanGreenPowerChargesScheme = "GREENPOWER"
	EnergyPlanGreenPowerChargesSchemeOTHER      EnergyPlanGreenPowerChargesScheme = "OTHER"
)

// Defines values for EnergyPlanGreenPowerChargesType.
const (
	FIXEDPERDAY   EnergyPlanGreenPowerChargesType = "FIXED_PER_DAY"
	FIXEDPERMONTH EnergyPlanGreenPowerChargesType = "FIXED_PER_MONTH"
	FIXEDPERUNIT  EnergyPlanGreenPowerChargesType = "FIXED_PER_UNIT"
	FIXEDPERWEEK  EnergyPlanGreenPowerChargesType = "FIXED_PER_WEEK"
	PERCENTOFBILL EnergyPlanGreenPowerChargesType = "PERCENT_OF_BILL"
	PERCENTOFUSE  EnergyPlanGreenPowerChargesType = "PERCENT_OF_USE"
)

// Defines values for EnergyPlanIncentivesCategory.
const (
	EnergyPlanIncentivesCategoryACCOUNTCREDIT EnergyPlanIncentivesCategory = "ACCOUNT_CREDIT"
	EnergyPlanIncentivesCategoryGIFT          EnergyPlanIncentivesCategory = "GIFT"
	EnergyPlanIncentivesCategoryOTHER         EnergyPlanIncentivesCategory = "OTHER"
)

// Defines values for EnergyPlanSolarFeedInTariffPayerType.
const (
	GOVERNMENT EnergyPlanSolarFeedInTariffPayerType = "GOVERNMENT"
	RETAILER   EnergyPlanSolarFeedInTariffPayerType = "RETAILER"
)

// Defines values for EnergyPlanSolarFeedInTariffScheme.
const (
	EnergyPlanSolarFeedInTariffSchemeOTHER   EnergyPlanSolarFeedInTariffScheme = "OTHER"
	EnergyPlanSolarFeedInTariffSchemePREMIUM EnergyPlanSolarFeedInTariffScheme = "PREMIUM"
)

// Defines values for EnergyPlanSolarFeedInTariffTariffUType.
const (
	SingleTariff       EnergyPlanSolarFeedInTariffTariffUType = "singleTariff"
	TimeVaryingTariffs EnergyPlanSolarFeedInTariffTariffUType = "timeVaryingTariffs"
)

// Defines values for EnergyPlanSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays.
const (
	EnergyPlanSolarFeedInTariffTimeVaryingTariffsTimeVariationsDaysFRI            EnergyPlanSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays = "FRI"
	EnergyPlanSolarFeedInTariffTimeVaryingTariffsTimeVariationsDaysMON            EnergyPlanSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays = "MON"
	EnergyPlanSolarFeedInTariffTimeVaryingTariffsTimeVariationsDaysPUBLICHOLIDAYS EnergyPlanSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays = "PUBLIC_HOLIDAYS"
	EnergyPlanSolarFeedInTariffTimeVaryingTariffsTimeVariationsDaysSAT            EnergyPlanSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays = "SAT"
	EnergyPlanSolarFeedInTariffTimeVaryingTariffsTimeVariationsDaysSUN            EnergyPlanSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays = "SUN"
	EnergyPlanSolarFeedInTariffTimeVaryingTariffsTimeVariationsDaysTHU            EnergyPlanSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays = "THU"
	EnergyPlanSolarFeedInTariffTimeVaryingTariffsTimeVariationsDaysTUE            EnergyPlanSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays = "TUE"
	EnergyPlanSolarFeedInTariffTimeVaryingTariffsTimeVariationsDaysWED            EnergyPlanSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays = "WED"
)

// Defines values for EnergyPlanSolarFeedInTariffTimeVaryingTariffsType.
const (
	EnergyPlanSolarFeedInTariffTimeVaryingTariffsTypeOFFPEAK  EnergyPlanSolarFeedInTariffTimeVaryingTariffsType = "OFF_PEAK"
	EnergyPlanSolarFeedInTariffTimeVaryingTariffsTypePEAK     EnergyPlanSolarFeedInTariffTimeVaryingTariffsType = "PEAK"
	EnergyPlanSolarFeedInTariffTimeVaryingTariffsTypeSHOULDER EnergyPlanSolarFeedInTariffTimeVaryingTariffsType = "SHOULDER"
)

// Defines values for EnergyPlanTariffPeriodDemandChargesChargePeriod.
const (
	EnergyPlanTariffPeriodDemandChargesChargePeriodDAY          EnergyPlanTariffPeriodDemandChargesChargePeriod = "DAY"
	EnergyPlanTariffPeriodDemandChargesChargePeriodMONTH        EnergyPlanTariffPeriodDemandChargesChargePeriod = "MONTH"
	EnergyPlanTariffPeriodDemandChargesChargePeriodTARIFFPERIOD EnergyPlanTariffPeriodDemandChargesChargePeriod = "TARIFF_PERIOD"
)

// Defines values for EnergyPlanTariffPeriodDemandChargesDays.
const (
	EnergyPlanTariffPeriodDemandChargesDaysFRI            EnergyPlanTariffPeriodDemandChargesDays = "FRI"
	EnergyPlanTariffPeriodDemandChargesDaysMON            EnergyPlanTariffPeriodDemandChargesDays = "MON"
	EnergyPlanTariffPeriodDemandChargesDaysPUBLICHOLIDAYS EnergyPlanTariffPeriodDemandChargesDays = "PUBLIC_HOLIDAYS"
	EnergyPlanTariffPeriodDemandChargesDaysSAT            EnergyPlanTariffPeriodDemandChargesDays = "SAT"
	EnergyPlanTariffPeriodDemandChargesDaysSUN            EnergyPlanTariffPeriodDemandChargesDays = "SUN"
	EnergyPlanTariffPeriodDemandChargesDaysTHU            EnergyPlanTariffPeriodDemandChargesDays = "THU"
	EnergyPlanTariffPeriodDemandChargesDaysTUE            EnergyPlanTariffPeriodDemandChargesDays = "TUE"
	EnergyPlanTariffPeriodDemandChargesDaysWED            EnergyPlanTariffPeriodDemandChargesDays = "WED"
)

// Defines values for EnergyPlanTariffPeriodDemandChargesMeasureUnit.
const (
	EnergyPlanTariffPeriodDemandChargesMeasureUnitDAYS  EnergyPlanTariffPeriodDemandChargesMeasureUnit = "DAYS"
	EnergyPlanTariffPeriodDemandChargesMeasureUnitKVA   EnergyPlanTariffPeriodDemandChargesMeasureUnit = "KVA"
	EnergyPlanTariffPeriodDemandChargesMeasureUnitKVAR  EnergyPlanTariffPeriodDemandChargesMeasureUnit = "KVAR"
	EnergyPlanTariffPeriodDemandChargesMeasureUnitKVARH EnergyPlanTariffPeriodDemandChargesMeasureUnit = "KVARH"
	EnergyPlanTariffPeriodDemandChargesMeasureUnitKW    EnergyPlanTariffPeriodDemandChargesMeasureUnit = "KW"
	EnergyPlanTariffPeriodDemandChargesMeasureUnitKWH   EnergyPlanTariffPeriodDemandChargesMeasureUnit = "KWH"
	EnergyPlanTariffPeriodDemandChargesMeasureUnitMETER EnergyPlanTariffPeriodDemandChargesMeasureUnit = "METER"
	EnergyPlanTariffPeriodDemandChargesMeasureUnitMONTH EnergyPlanTariffPeriodDemandChargesMeasureUnit = "MONTH"
)

// Defines values for EnergyPlanTariffPeriodDemandChargesMeasurementPeriod.
const (
	EnergyPlanTariffPeriodDemandChargesMeasurementPeriodDAY          EnergyPlanTariffPeriodDemandChargesMeasurementPeriod = "DAY"
	EnergyPlanTariffPeriodDemandChargesMeasurementPeriodMONTH        EnergyPlanTariffPeriodDemandChargesMeasurementPeriod = "MONTH"
	EnergyPlanTariffPeriodDemandChargesMeasurementPeriodTARIFFPERIOD EnergyPlanTariffPeriodDemandChargesMeasurementPeriod = "TARIFF_PERIOD"
)

// Defines values for EnergyPlanTariffPeriodRateBlockUType.
const (
	EnergyPlanTariffPeriodRateBlockUTypeDemandCharges  EnergyPlanTariffPeriodRateBlockUType = "demandCharges"
	EnergyPlanTariffPeriodRateBlockUTypeSingleRate     EnergyPlanTariffPeriodRateBlockUType = "singleRate"
	EnergyPlanTariffPeriodRateBlockUTypeTimeOfUseRates EnergyPlanTariffPeriodRateBlockUType = "timeOfUseRates"
)

// Defines values for EnergyPlanTariffPeriodSingleRateRatesMeasureUnit.
const (
	EnergyPlanTariffPeriodSingleRateRatesMeasureUnitDAYS  EnergyPlanTariffPeriodSingleRateRatesMeasureUnit = "DAYS"
	EnergyPlanTariffPeriodSingleRateRatesMeasureUnitKVA   EnergyPlanTariffPeriodSingleRateRatesMeasureUnit = "KVA"
	EnergyPlanTariffPeriodSingleRateRatesMeasureUnitKVAR  EnergyPlanTariffPeriodSingleRateRatesMeasureUnit = "KVAR"
	EnergyPlanTariffPeriodSingleRateRatesMeasureUnitKVARH EnergyPlanTariffPeriodSingleRateRatesMeasureUnit = "KVARH"
	EnergyPlanTariffPeriodSingleRateRatesMeasureUnitKW    EnergyPlanTariffPeriodSingleRateRatesMeasureUnit = "KW"
	EnergyPlanTariffPeriodSingleRateRatesMeasureUnitKWH   EnergyPlanTariffPeriodSingleRateRatesMeasureUnit = "KWH"
	EnergyPlanTariffPeriodSingleRateRatesMeasureUnitMETER EnergyPlanTariffPeriodSingleRateRatesMeasureUnit = "METER"
	EnergyPlanTariffPeriodSingleRateRatesMeasureUnitMONTH EnergyPlanTariffPeriodSingleRateRatesMeasureUnit = "MONTH"
)

// Defines values for EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnit.
const (
	EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnitDAYS  EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnit = "DAYS"
	EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnitKVA   EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnit = "KVA"
	EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnitKVAR  EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnit = "KVAR"
	EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnitKVARH EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnit = "KVARH"
	EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnitKW    EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnit = "KW"
	EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnitKWH   EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnit = "KWH"
	EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnitMETER EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnit = "METER"
	EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnitMONTH EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnit = "MONTH"
)

// Defines values for EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDays.
const (
	EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDaysFRI            EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDays = "FRI"
	EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDaysMON            EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDays = "MON"
	EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDaysPUBLICHOLIDAYS EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDays = "PUBLIC_HOLIDAYS"
	EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDaysSAT            EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDays = "SAT"
	EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDaysSUN            EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDays = "SUN"
	EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDaysTHU            EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDays = "THU"
	EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDaysTUE            EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDays = "TUE"
	EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDaysWED            EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDays = "WED"
)

// Defines values for EnergyPlanTariffPeriodTimeOfUseRatesType.
const (
	EnergyPlanTariffPeriodTimeOfUseRatesTypeOFFPEAK   EnergyPlanTariffPeriodTimeOfUseRatesType = "OFF_PEAK"
	EnergyPlanTariffPeriodTimeOfUseRatesTypePEAK      EnergyPlanTariffPeriodTimeOfUseRatesType = "PEAK"
	EnergyPlanTariffPeriodTimeOfUseRatesTypeSHOULDER  EnergyPlanTariffPeriodTimeOfUseRatesType = "SHOULDER"
	EnergyPlanTariffPeriodTimeOfUseRatesTypeSHOULDER1 EnergyPlanTariffPeriodTimeOfUseRatesType = "SHOULDER1"
	EnergyPlanTariffPeriodTimeOfUseRatesTypeSHOULDER2 EnergyPlanTariffPeriodTimeOfUseRatesType = "SHOULDER2"
)

// Defines values for EnergyPlanTariffPeriodTimeZone.
const (
	AEST  EnergyPlanTariffPeriodTimeZone = "AEST"
	LOCAL EnergyPlanTariffPeriodTimeZone = "LOCAL"
)

// Defines values for EnergyPlanTariffPeriodType.
const (
	ENVIRONMENTAL EnergyPlanTariffPeriodType = "ENVIRONMENTAL"
	METERING      EnergyPlanTariffPeriodType = "METERING"
	NETWORK       EnergyPlanTariffPeriodType = "NETWORK"
	OTHER         EnergyPlanTariffPeriodType = "OTHER"
	RCTI          EnergyPlanTariffPeriodType = "RCTI"
	REGULATED     EnergyPlanTariffPeriodType = "REGULATED"
	RETAILSERVICE EnergyPlanTariffPeriodType = "RETAIL_SERVICE"
)

// Defines values for EnergyServicePointConsumerProfileClassification.
const (
	EnergyServicePointConsumerProfileClassificationBUSINESS    EnergyServicePointConsumerProfileClassification = "BUSINESS"
	EnergyServicePointConsumerProfileClassificationRESIDENTIAL EnergyServicePointConsumerProfileClassification = "RESIDENTIAL"
)

// Defines values for EnergyServicePointJurisdictionCode.
const (
	EnergyServicePointJurisdictionCodeACT EnergyServicePointJurisdictionCode = "ACT"
	EnergyServicePointJurisdictionCodeALL EnergyServicePointJurisdictionCode = "ALL"
	EnergyServicePointJurisdictionCodeNEM EnergyServicePointJurisdictionCode = "NEM"
	EnergyServicePointJurisdictionCodeNSW EnergyServicePointJurisdictionCode = "NSW"
	EnergyServicePointJurisdictionCodeQLD EnergyServicePointJurisdictionCode = "QLD"
	EnergyServicePointJurisdictionCodeSA  EnergyServicePointJurisdictionCode = "SA"
	EnergyServicePointJurisdictionCodeTAS EnergyServicePointJurisdictionCode = "TAS"
	EnergyServicePointJurisdictionCodeVIC EnergyServicePointJurisdictionCode = "VIC"
)

// Defines values for EnergyServicePointServicePointClassification.
const (
	EnergyServicePointServicePointClassificationDISTRIBUTIONWHOLESALE          EnergyServicePointServicePointClassification = "DISTRIBUTION_WHOLESALE"
	EnergyServicePointServicePointClassificationEXTERNALPROFILE                EnergyServicePointServicePointClassification = "EXTERNAL_PROFILE"
	EnergyServicePointServicePointClassificationGENERATOR                      EnergyServicePointServicePointClassification = "GENERATOR"
	EnergyServicePointServicePointClassificationLARGE                          EnergyServicePointServicePointClassification = "LARGE"
	EnergyServicePointServicePointClassificationNONCONTESTUNMETEREDLOAD        EnergyServicePointServicePointClassification = "NON_CONTEST_UNMETERED_LOAD"
	EnergyServicePointServicePointClassificationNONREGISTEREDEMBEDDEDGENERATOR EnergyServicePointServicePointClassification = "NON_REGISTERED_EMBEDDED_GENERATOR"
	EnergyServicePointServicePointClassificationSMALL                          EnergyServicePointServicePointClassification = "SMALL"
	EnergyServicePointServicePointClassificationWHOLESALE                      EnergyServicePointServicePointClassification = "WHOLESALE"
)

// Defines values for EnergyServicePointServicePointStatus.
const (
	EnergyServicePointServicePointStatusACTIVE      EnergyServicePointServicePointStatus = "ACTIVE"
	EnergyServicePointServicePointStatusDEENERGISED EnergyServicePointServicePointStatus = "DE_ENERGISED"
	EnergyServicePointServicePointStatusEXTINCT     EnergyServicePointServicePointStatus = "EXTINCT"
	EnergyServicePointServicePointStatusGREENFIELD  EnergyServicePointServicePointStatus = "GREENFIELD"
	EnergyServicePointServicePointStatusOFFMARKET   EnergyServicePointServicePointStatus = "OFF_MARKET"
)

// Defines values for EnergyServicePointDetailConsumerProfileClassification.
const (
	EnergyServicePointDetailConsumerProfileClassificationBUSINESS    EnergyServicePointDetailConsumerProfileClassification = "BUSINESS"
	EnergyServicePointDetailConsumerProfileClassificationRESIDENTIAL EnergyServicePointDetailConsumerProfileClassification = "RESIDENTIAL"
)

// Defines values for EnergyServicePointDetailJurisdictionCode.
const (
	EnergyServicePointDetailJurisdictionCodeACT EnergyServicePointDetailJurisdictionCode = "ACT"
	EnergyServicePointDetailJurisdictionCodeALL EnergyServicePointDetailJurisdictionCode = "ALL"
	EnergyServicePointDetailJurisdictionCodeNEM EnergyServicePointDetailJurisdictionCode = "NEM"
	EnergyServicePointDetailJurisdictionCodeNSW EnergyServicePointDetailJurisdictionCode = "NSW"
	EnergyServicePointDetailJurisdictionCodeQLD EnergyServicePointDetailJurisdictionCode = "QLD"
	EnergyServicePointDetailJurisdictionCodeSA  EnergyServicePointDetailJurisdictionCode = "SA"
	EnergyServicePointDetailJurisdictionCodeTAS EnergyServicePointDetailJurisdictionCode = "TAS"
	EnergyServicePointDetailJurisdictionCodeVIC EnergyServicePointDetailJurisdictionCode = "VIC"
)

// Defines values for EnergyServicePointDetailMetersRegistersConsumptionType.
const (
	EnergyServicePointDetailMetersRegistersConsumptionTypeACTUAL     EnergyServicePointDetailMetersRegistersConsumptionType = "ACTUAL"
	EnergyServicePointDetailMetersRegistersConsumptionTypeCUMULATIVE EnergyServicePointDetailMetersRegistersConsumptionType = "CUMULATIVE"
)

// Defines values for EnergyServicePointDetailMetersRegistersRegisterConsumptionType.
const (
	EnergyServicePointDetailMetersRegistersRegisterConsumptionTypeACTIVE         EnergyServicePointDetailMetersRegistersRegisterConsumptionType = "ACTIVE"
	EnergyServicePointDetailMetersRegistersRegisterConsumptionTypeACTIVEIMPORT   EnergyServicePointDetailMetersRegistersRegisterConsumptionType = "ACTIVE_IMPORT"
	EnergyServicePointDetailMetersRegistersRegisterConsumptionTypeBASIC          EnergyServicePointDetailMetersRegistersRegisterConsumptionType = "BASIC"
	EnergyServicePointDetailMetersRegistersRegisterConsumptionTypeINTERVAL       EnergyServicePointDetailMetersRegistersRegisterConsumptionType = "INTERVAL"
	EnergyServicePointDetailMetersRegistersRegisterConsumptionTypePROFILEDATA    EnergyServicePointDetailMetersRegistersRegisterConsumptionType = "PROFILE_DATA"
	EnergyServicePointDetailMetersRegistersRegisterConsumptionTypeREACTIVE       EnergyServicePointDetailMetersRegistersRegisterConsumptionType = "REACTIVE"
	EnergyServicePointDetailMetersRegistersRegisterConsumptionTypeREACTIVEIMPORT EnergyServicePointDetailMetersRegistersRegisterConsumptionType = "REACTIVE_IMPORT"
)

// Defines values for EnergyServicePointDetailMetersRegistersTimeOfDay.
const (
	EnergyServicePointDetailMetersRegistersTimeOfDayALLDAY     EnergyServicePointDetailMetersRegistersTimeOfDay = "ALLDAY"
	EnergyServicePointDetailMetersRegistersTimeOfDayBUSINESS   EnergyServicePointDetailMetersRegistersTimeOfDay = "BUSINESS"
	EnergyServicePointDetailMetersRegistersTimeOfDayCONTROLLED EnergyServicePointDetailMetersRegistersTimeOfDay = "CONTROLLED"
	EnergyServicePointDetailMetersRegistersTimeOfDayDEMAND     EnergyServicePointDetailMetersRegistersTimeOfDay = "DEMAND"
	EnergyServicePointDetailMetersRegistersTimeOfDayEVENING    EnergyServicePointDetailMetersRegistersTimeOfDay = "EVENING"
	EnergyServicePointDetailMetersRegistersTimeOfDayINTERVAL   EnergyServicePointDetailMetersRegistersTimeOfDay = "INTERVAL"
	EnergyServicePointDetailMetersRegistersTimeOfDayOFFPEAK    EnergyServicePointDetailMetersRegistersTimeOfDay = "OFFPEAK"
	EnergyServicePointDetailMetersRegistersTimeOfDayPEAK       EnergyServicePointDetailMetersRegistersTimeOfDay = "PEAK"
	EnergyServicePointDetailMetersRegistersTimeOfDaySHOULDER   EnergyServicePointDetailMetersRegistersTimeOfDay = "SHOULDER"
)

// Defines values for EnergyServicePointDetailMetersSpecificationsInstallationType.
const (
	BASIC    EnergyServicePointDetailMetersSpecificationsInstallationType = "BASIC"
	COMMS1   EnergyServicePointDetailMetersSpecificationsInstallationType = "COMMS1"
	COMMS2   EnergyServicePointDetailMetersSpecificationsInstallationType = "COMMS2"
	COMMS3   EnergyServicePointDetailMetersSpecificationsInstallationType = "COMMS3"
	COMMS4   EnergyServicePointDetailMetersSpecificationsInstallationType = "COMMS4"
	COMMS4C  EnergyServicePointDetailMetersSpecificationsInstallationType = "COMMS4C"
	COMMS4D  EnergyServicePointDetailMetersSpecificationsInstallationType = "COMMS4D"
	MRAM     EnergyServicePointDetailMetersSpecificationsInstallationType = "MRAM"
	MRIM     EnergyServicePointDetailMetersSpecificationsInstallationType = "MRIM"
	NCOLNUML EnergyServicePointDetailMetersSpecificationsInstallationType = "NCOLNUML"
	PROF     EnergyServicePointDetailMetersSpecificationsInstallationType = "PROF"
	SAMPLE   EnergyServicePointDetailMetersSpecificationsInstallationType = "SAMPLE"
	UMCP     EnergyServicePointDetailMetersSpecificationsInstallationType = "UMCP"
	VICAMI   EnergyServicePointDetailMetersSpecificationsInstallationType = "VICAMI"
)

// Defines values for EnergyServicePointDetailMetersSpecificationsStatus.
const (
	CURRENT      EnergyServicePointDetailMetersSpecificationsStatus = "CURRENT"
	DISCONNECTED EnergyServicePointDetailMetersSpecificationsStatus = "DISCONNECTED"
)

// Defines values for EnergyServicePointDetailRelatedParticipantsRole.
const (
	DRSP EnergyServicePointDetailRelatedParticipantsRole = "DRSP"
	FRMP EnergyServicePointDetailRelatedParticipantsRole = "FRMP"
	LNSP EnergyServicePointDetailRelatedParticipantsRole = "LNSP"
)

// Defines values for EnergyServicePointDetailServicePointClassification.
const (
	EnergyServicePointDetailServicePointClassificationDISTRIBUTIONWHOLESALE          EnergyServicePointDetailServicePointClassification = "DISTRIBUTION_WHOLESALE"
	EnergyServicePointDetailServicePointClassificationEXTERNALPROFILE                EnergyServicePointDetailServicePointClassification = "EXTERNAL_PROFILE"
	EnergyServicePointDetailServicePointClassificationGENERATOR                      EnergyServicePointDetailServicePointClassification = "GENERATOR"
	EnergyServicePointDetailServicePointClassificationLARGE                          EnergyServicePointDetailServicePointClassification = "LARGE"
	EnergyServicePointDetailServicePointClassificationNONCONTESTUNMETEREDLOAD        EnergyServicePointDetailServicePointClassification = "NON_CONTEST_UNMETERED_LOAD"
	EnergyServicePointDetailServicePointClassificationNONREGISTEREDEMBEDDEDGENERATOR EnergyServicePointDetailServicePointClassification = "NON_REGISTERED_EMBEDDED_GENERATOR"
	EnergyServicePointDetailServicePointClassificationSMALL                          EnergyServicePointDetailServicePointClassification = "SMALL"
	EnergyServicePointDetailServicePointClassificationWHOLESALE                      EnergyServicePointDetailServicePointClassification = "WHOLESALE"
)

// Defines values for EnergyServicePointDetailServicePointStatus.
const (
	ACTIVE      EnergyServicePointDetailServicePointStatus = "ACTIVE"
	DEENERGISED EnergyServicePointDetailServicePointStatus = "DE_ENERGISED"
	EXTINCT     EnergyServicePointDetailServicePointStatus = "EXTINCT"
	GREENFIELD  EnergyServicePointDetailServicePointStatus = "GREENFIELD"
	OFFMARKET   EnergyServicePointDetailServicePointStatus = "OFF_MARKET"
)

// Defines values for EnergyUsageReadBasicReadQuality.
const (
	EnergyUsageReadBasicReadQualityACTUAL          EnergyUsageReadBasicReadQuality = "ACTUAL"
	EnergyUsageReadBasicReadQualityFINALSUBSTITUTE EnergyUsageReadBasicReadQuality = "FINAL_SUBSTITUTE"
	EnergyUsageReadBasicReadQualitySUBSTITUTE      EnergyUsageReadBasicReadQuality = "SUBSTITUTE"
)

// Defines values for EnergyUsageReadIntervalReadReadQualitiesQuality.
const (
	FINALSUBSTITUTE EnergyUsageReadIntervalReadReadQualitiesQuality = "FINAL_SUBSTITUTE"
	SUBSTITUTE      EnergyUsageReadIntervalReadReadQualitiesQuality = "SUBSTITUTE"
)

// Defines values for EnergyUsageReadReadUType.
const (
	BasicRead    EnergyUsageReadReadUType = "basicRead"
	IntervalRead EnergyUsageReadReadUType = "intervalRead"
)

// Defines values for IntervalReads.
const (
	FULL  IntervalReads = "FULL"
	MIN30 IntervalReads = "MIN_30"
	NONE  IntervalReads = "NONE"
)

// Defines values for OpenStatus.
const (
	OpenStatusALL    OpenStatus = "ALL"
	OpenStatusCLOSED OpenStatus = "CLOSED"
	OpenStatusOPEN   OpenStatus = "OPEN"
)

// Australian address formatted according to the file format defined by the [PAF file format](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf). Required if addressUType is set to paf
type CommonPAFAddress struct {
	// Building/Property name 1
	BuildingName1 *string `json:"buildingName1,omitempty"`

	// Building/Property name 2
	BuildingName2 *string `json:"buildingName2,omitempty"`

	// Unique identifier for an address as defined by Australia Post.  Also known as Delivery Point Identifier
	Dpid *string `json:"dpid,omitempty"`

	// Unit number (including suffix, if applicable)
	FlatUnitNumber *string `json:"flatUnitNumber,omitempty"`

	// Type of flat or unit for the address
	FlatUnitType *string `json:"flatUnitType,omitempty"`

	// Floor or level number (including alpha characters)
	FloorLevelNumber *string `json:"floorLevelNumber,omitempty"`

	// Type of floor or level for the address
	FloorLevelType *string `json:"floorLevelType,omitempty"`

	// Full name of locality
	LocalityName string `json:"localityName"`

	// Allotment number for the address
	LotNumber *string `json:"lotNumber,omitempty"`

	// Postal delivery number if the address is a postal delivery type
	PostalDeliveryNumber *int `json:"postalDeliveryNumber,omitempty"`

	// Postal delivery number prefix related to the postal delivery number
	PostalDeliveryNumberPrefix *string `json:"postalDeliveryNumberPrefix,omitempty"`

	// Postal delivery number suffix related to the postal delivery number
	PostalDeliveryNumberSuffix *string `json:"postalDeliveryNumberSuffix,omitempty"`

	// Postal delivery type. (eg. PO BOX). Valid enumeration defined by Australia Post PAF code file
	PostalDeliveryType *string `json:"postalDeliveryType,omitempty"`

	// Postcode for the locality
	Postcode string `json:"postcode"`

	// State in which the address belongs. Valid enumeration defined by Australia Post PAF code file [State Type Abbreviation](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf). NSW, QLD, VIC, NT, WA, SA, TAS, ACT, AAT
	State string `json:"state"`

	// The name of the street
	StreetName *string `json:"streetName,omitempty"`

	// The street type suffix. Valid enumeration defined by Australia Post PAF code file
	StreetSuffix *string `json:"streetSuffix,omitempty"`

	// The street type. Valid enumeration defined by Australia Post PAF code file
	StreetType *string `json:"streetType,omitempty"`

	// Thoroughfare number for a property (first number in a property ranged address)
	ThoroughfareNumber1 *int `json:"thoroughfareNumber1,omitempty"`

	// Suffix for the thoroughfare number. Only relevant is thoroughfareNumber1 is populated
	ThoroughfareNumber1Suffix *string `json:"thoroughfareNumber1Suffix,omitempty"`

	// Second thoroughfare number (only used if the property has a ranged address eg 23-25)
	ThoroughfareNumber2 *int `json:"thoroughfareNumber2,omitempty"`

	// Suffix for the second thoroughfare number. Only relevant is thoroughfareNumber2 is populated
	ThoroughfareNumber2Suffix *string `json:"thoroughfareNumber2Suffix,omitempty"`
}

// CommonPhysicalAddress defines model for CommonPhysicalAddress.
type CommonPhysicalAddress struct {
	// The type of address object present
	AddressUType CommonPhysicalAddressAddressUType `json:"addressUType"`

	// Australian address formatted according to the file format defined by the [PAF file format](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf). Required if addressUType is set to paf
	Paf *CommonPAFAddress `json:"paf,omitempty"`

	// Required if addressUType is set to simple
	Simple *CommonSimpleAddress `json:"simple,omitempty"`
}

// The type of address object present
type CommonPhysicalAddressAddressUType string

// Required if addressUType is set to simple
type CommonSimpleAddress struct {
	// First line of the standard address object
	AddressLine1 string `json:"addressLine1"`

	// Second line of the standard address object
	AddressLine2 *string `json:"addressLine2,omitempty"`

	// Third line of the standard address object
	AddressLine3 *string `json:"addressLine3,omitempty"`

	// Name of the city or locality
	City string `json:"city"`

	// A valid [ISO 3166 Alpha-3](https://www.iso.org/iso-3166-country-codes.html) country code. Australia (AUS) is assumed if country is not present.
	Country *string `json:"country,omitempty"`

	// Name of the individual or business formatted for inclusion in an address used for physical mail
	MailingName *string `json:"mailingName,omitempty"`

	// Mandatory for Australian addresses
	Postcode *string `json:"postcode,omitempty"`

	// Free text if the country is not Australia. If country is Australia then must be one of the values defined by the [State Type Abbreviation](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf) in the PAF file format. NSW, QLD, VIC, NT, WA, SA, TAS, ACT, AAT
	State string `json:"state"`
}

// EnergyAccountBaseV2 defines model for EnergyAccountBaseV2.
type EnergyAccountBaseV2 struct {
	// The ID of the account.  To be created in accordance with CDR ID permanence requirements
	AccountId string `json:"accountId"`

	// Optional identifier of the account as defined by the data holder.  This must be the value presented on physical statements (if it exists) and must not be used for the value of accountId
	AccountNumber *string `json:"accountNumber,omitempty"`

	// The date that the account was created or opened. Mandatory if openStatus is OPEN
	CreationDate *string `json:"creationDate,omitempty"`

	// An optional display name for the account if one exists or can be derived.  The content of this field is at the discretion of the data holder
	DisplayName *string `json:"displayName,omitempty"`

	// Open or closed status for the account. If not present then OPEN is assumed
	OpenStatus *EnergyAccountBaseV2OpenStatus `json:"openStatus,omitempty"`
}

// Open or closed status for the account. If not present then OPEN is assumed
type EnergyAccountBaseV2OpenStatus string

// EnergyAccountDetailResponseV2 defines model for EnergyAccountDetailResponseV2.
type EnergyAccountDetailResponseV2 struct {
	Data  EnergyAccountDetailV2 `json:"data"`
	Links Links                 `json:"links"`
	Meta  Meta                  `json:"meta"`
}

// EnergyAccountDetailV2 defines model for EnergyAccountDetailV2.
type EnergyAccountDetailV2 struct {
	// The ID of the account.  To be created in accordance with CDR ID permanence requirements
	AccountId string `json:"accountId"`

	// Optional identifier of the account as defined by the data holder.  This must be the value presented on physical statements (if it exists) and must not be used for the value of accountId
	AccountNumber *string `json:"accountNumber,omitempty"`

	// The date that the account was created or opened. Mandatory if openStatus is OPEN
	CreationDate *string `json:"creationDate,omitempty"`

	// An optional display name for the account if one exists or can be derived.  The content of this field is at the discretion of the data holder
	DisplayName *string `json:"displayName,omitempty"`

	// Open or closed status for the account. If not present then OPEN is assumed
	OpenStatus *EnergyAccountDetailV2OpenStatus `json:"openStatus,omitempty"`

	// The array of plans containing service points and associated plan details
	Plans []struct {
		// An array of additional contacts that are authorised to act on this account
		AuthorisedContacts *[]struct {
			// For people with single names this field need not be present. The single name should be in the lastName field
			FirstName *string `json:"firstName,omitempty"`

			// For people with single names the single name should be in this field
			LastName string `json:"lastName"`

			// Field is mandatory but array may be empty
			MiddleNames *[]string `json:"middleNames,omitempty"`

			// Also known as title or salutation. The prefix to the name (e.g. Mr, Mrs, Ms, Miss, Sir, etc)
			Prefix *string `json:"prefix,omitempty"`

			// Used for a trailing suffix to the name (e.g. Jr)
			Suffix *string `json:"suffix,omitempty"`
		} `json:"authorisedContacts,omitempty"`

		// Optional display name for the plan provided by the customer to help differentiate multiple plans
		Nickname *string `json:"nickname,omitempty"`

		// Detail on the plan applicable to this account. Mandatory if openStatus is OPEN
		PlanDetail *struct {
			ElectricityContract *EnergyPlanContract `json:"electricityContract,omitempty"`

			// The fuel types covered by the plan
			FuelType    EnergyAccountDetailV2PlansPlanDetailFuelType `json:"fuelType"`
			GasContract *EnergyPlanContract                          `json:"gasContract,omitempty"`

			// Flag that indicates that the plan is contingent on the customer taking up an alternate fuel plan from the same retailer (for instance, if the fuelType is ELECTRICITY then a GAS plan from the same retailer must be taken up). Has no meaning if the plan has a fuelType of DUAL. If absent the value is assumed to be false
			IsContingentPlan *bool `json:"isContingentPlan,omitempty"`

			// Charges for metering included in the plan
			MeteringCharges *[]struct {
				// Description of the charge
				Description *string `json:"description,omitempty"`

				// Display name of the charge
				DisplayName string `json:"displayName"`

				// The upper limit of the charge if the charge could occur in a range
				MaximumValue *string `json:"maximumValue,omitempty"`

				// Minimum value of the charge if the charge is a range or the absolute value of the charge if no range is specified
				MinimumValue string `json:"minimumValue"`

				// The charges that occur on a schedule indicates the frequency. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
				Period *string `json:"period,omitempty"`
			} `json:"meteringCharges,omitempty"`
		} `json:"planDetail,omitempty"`

		// Mandatory if openStatus is OPEN
		PlanOverview *struct {
			// The name of the plan if one exists
			DisplayName *string `json:"displayName,omitempty"`

			// The end date of the applicability of this plan
			EndDate *string `json:"endDate,omitempty"`

			// The start date of the applicability of this plan
			StartDate string `json:"startDate"`
		} `json:"planOverview,omitempty"`

		// An array of servicePointIds, representing NMIs, that this account is linked to
		ServicePointIds []string `json:"servicePointIds"`
	} `json:"plans"`
}

// Open or closed status for the account. If not present then OPEN is assumed
type EnergyAccountDetailV2OpenStatus string

// The fuel types covered by the plan
type EnergyAccountDetailV2PlansPlanDetailFuelType string

// EnergyAccountListResponseV2 defines model for EnergyAccountListResponseV2.
type EnergyAccountListResponseV2 struct {
	Data struct {
		// Array of accounts
		Accounts []EnergyAccountV2 `json:"accounts"`
	} `json:"data"`
	Links LinksPaginated `json:"links"`
	Meta  MetaPaginated  `json:"meta"`
}

// EnergyAccountV2 defines model for EnergyAccountV2.
type EnergyAccountV2 struct {
	AccountId string `json:"accountId" example:"1bbc12c2-ae16-4875-a0f9-8c4ce79c770e"` // The ID of the account.  To be created in accordance with CDR ID permanence requirements

	AccountNumber *string `json:"accountNumber,omitempty" example:"1bbc12c2-ae16-4875-a0f9-8c4ce79c770e"` // Optional identifier of the account as defined by the data holder.  This must be the value presented on physical statements (if it exists) and must not be used for the value of accountId

	CreationDate *string `json:"creationDate,omitempty" example:"2022-01-01"`                     // The date that the account was created or opened. Mandatory if openStatus is OPEN
	
	DisplayName *string `json:"displayName,omitempty" example:"Albert Wood"`                      // An optional display name for the account if one exists or can be derived.  The content of this field is at the discretion of the data holder

	OpenStatus *EnergyAccountV2OpenStatus `json:"openStatus,omitempty" example:"OPEN"`                               // Open or closed status for the account. If not present then OPEN is assumed

	// The array of plans containing service points and associated plan details
	Plans []struct {
		Nickname *string `json:"nickname,omitempty" example:"Nickname"` // Optional display name for the plan provided by the customer to help differentiate multiple plans

		// Mandatory if openStatus is OPEN
		PlanOverview *struct {
			
			DisplayName *string `json:"displayName,omitempty" example:"Albert Wood"` // The name of the plan if one exists

			EndDate *string `json:"endDate,omitempty" example:"2022-01-01"` // The end date of the applicability of this plan

			StartDate string `json:"startDate" example:"2022-01-01"` // The start date of the applicability of this plan
		} `json:"planOverview,omitempty"`
		
		ServicePointIds []string `json:"servicePointIds" example:"servicepointid1,servicepointid2"` // An array of servicePointIds, representing NMIs, that this plan is linked to.  If there are no service points allocated to this plan then an empty array would be expected
	} `json:"plans"`
}

// Open or closed status for the account. If not present then OPEN is assumed
type EnergyAccountV2OpenStatus string

// EnergyBalanceListResponse defines model for EnergyBalanceListResponse.
type EnergyBalanceListResponse struct {
	Data struct {
		// Array of account balances
		Balances []struct {
			// The ID of the account
			AccountId string `json:"accountId"`

			// The current balance of the account.  A positive value indicates that amount is owing to be paid.  A negative value indicates that the account is in credit
			Balance string `json:"balance"`
		} `json:"balances"`
	} `json:"data"`
	Links LinksPaginated `json:"links"`
	Meta  MetaPaginated  `json:"meta"`
}

// EnergyBalanceResponse defines model for EnergyBalanceResponse.
type EnergyBalanceResponse struct {
	Data struct {
		// The current balance of the account.  A positive value indicates that amount is owing to be paid.  A negative value indicates that the account is in credit
		Balance string `json:"balance"`
	} `json:"data"`
	Links Links `json:"links"`
	Meta  Meta  `json:"meta"`
}

// EnergyBillingDemandTransaction defines model for EnergyBillingDemandTransaction.
type EnergyBillingDemandTransaction struct {
	// Optional array of adjustments arising for this transaction
	Adjustments *[]struct {
		// The amount of the adjustment
		Amount string `json:"amount"`

		// A free text description of the adjustment
		Description string `json:"description"`
	} `json:"adjustments,omitempty"`

	// The amount charged or credited for this transaction prior to any adjustments being applied.  A negative value indicates a credit
	Amount string `json:"amount"`

	// Additional calculation factors that inform the transaction
	CalculationFactors *[]struct {
		// The type of the calculation factor
		Type EnergyBillingDemandTransactionCalculationFactorsType `json:"type"`

		// The value of the calculation factor
		Value float32 `json:"value"`
	} `json:"calculationFactors,omitempty"`

	// Optional description of the transaction that can be used for display purposes
	Description *string `json:"description,omitempty"`

	// Date and time when the demand period ends
	EndDate string `json:"endDate"`

	// The number of the invoice in which this transaction is included if it has been issued
	InvoiceNumber *string `json:"invoiceNumber,omitempty"`

	// Flag indicating if the usage is estimated or actual.  True indicates estimate.  False or absent indicates actual
	IsEstimate *bool `json:"isEstimate,omitempty"`

	// The rate for the demand charge in kVA.  A negative value indicates power generated
	Rate float32 `json:"rate"`

	// The ID of the service point to which this transaction applies if any
	ServicePointId *string `json:"servicePointId,omitempty"`

	// Date and time when the demand period starts
	StartDate string `json:"startDate"`

	// The time of use type that the transaction applies to
	TimeOfUseType EnergyBillingDemandTransactionTimeOfUseType `json:"timeOfUseType"`
}

// The type of the calculation factor
type EnergyBillingDemandTransactionCalculationFactorsType string

// The time of use type that the transaction applies to
type EnergyBillingDemandTransactionTimeOfUseType string

// EnergyBillingListResponse defines model for EnergyBillingListResponse.
type EnergyBillingListResponse struct {
	Data struct {
		// Array of transactions sorted by date and time in descending order
		Transactions []EnergyBillingTransaction `json:"transactions"`
	} `json:"data"`
	Links LinksPaginated `json:"links"`
	Meta  MetaPaginated  `json:"meta"`
}

// EnergyBillingOnceOffTransaction defines model for EnergyBillingOnceOffTransaction.
type EnergyBillingOnceOffTransaction struct {
	// The amount of the charge or credit.  A positive value indicates a charge and a negative value indicates a credit
	Amount string `json:"amount"`

	// A free text description of the item
	Description string `json:"description"`

	// The number of the invoice in which this transaction is included if it has been issued
	InvoiceNumber *string `json:"invoiceNumber,omitempty"`

	// The ID of the service point to which this transaction applies if any
	ServicePointId *string `json:"servicePointId,omitempty"`
}

// EnergyBillingOtherTransaction defines model for EnergyBillingOtherTransaction.
type EnergyBillingOtherTransaction struct {
	// Optional array of adjustments arising for this transaction
	Adjustments *[]struct {
		// The amount of the adjustment
		Amount string `json:"amount"`

		// A free text description of the adjustment
		Description string `json:"description"`
	} `json:"adjustments,omitempty"`

	// The amount of the charge
	Amount string `json:"amount"`

	// Additional calculation factors that inform the transaction
	CalculationFactors *[]struct {
		// The type of the calculation factor
		Type EnergyBillingOtherTransactionCalculationFactorsType `json:"type"`

		// The value of the calculation factor
		Value float32 `json:"value"`
	} `json:"calculationFactors,omitempty"`

	// A free text description of the item
	Description string `json:"description"`

	// Optional end date for the application of the charge
	EndDate *string `json:"endDate,omitempty"`

	// The number of the invoice in which this transaction is included if it has been issued
	InvoiceNumber *string `json:"invoiceNumber,omitempty"`

	// The ID of the service point to which this transaction applies if any
	ServicePointId *string `json:"servicePointId,omitempty"`

	// Optional start date for the application of the charge
	StartDate *string `json:"startDate,omitempty"`

	// Type of charge. Assumed to be other if absent
	Type *EnergyBillingOtherTransactionType `json:"type,omitempty"`
}

// The type of the calculation factor
type EnergyBillingOtherTransactionCalculationFactorsType string

// Type of charge. Assumed to be other if absent
type EnergyBillingOtherTransactionType string

// EnergyBillingPaymentTransaction defines model for EnergyBillingPaymentTransaction.
type EnergyBillingPaymentTransaction struct {
	// The amount paid
	Amount string `json:"amount"`

	// The method of payment
	Method EnergyBillingPaymentTransactionMethod `json:"method"`
}

// The method of payment
type EnergyBillingPaymentTransactionMethod string

// EnergyBillingTransaction defines model for EnergyBillingTransaction.
type EnergyBillingTransaction struct {
	// The ID of the account for which transaction applies
	AccountId string                          `json:"accountId"`
	Demand    *EnergyBillingDemandTransaction `json:"demand,omitempty"`

	// The date and time that the transaction occurred
	ExecutionDateTime string `json:"executionDateTime"`

	// The GST incurred in the transaction.  Should not be included for credits or payments.  If absent zero is assumed
	Gst          *string                          `json:"gst,omitempty"`
	OnceOff      *EnergyBillingOnceOffTransaction `json:"onceOff,omitempty"`
	OtherCharges *EnergyBillingOtherTransaction   `json:"otherCharges,omitempty"`
	Payment      *EnergyBillingPaymentTransaction `json:"payment,omitempty"`

	// Indicator of the type of transaction object present in this record
	TransactionUType EnergyBillingTransactionTransactionUType `json:"transactionUType"`
	Usage            *EnergyBillingUsageTransaction           `json:"usage,omitempty"`
}

// Indicator of the type of transaction object present in this record
type EnergyBillingTransactionTransactionUType string

// EnergyBillingUsageTransaction defines model for EnergyBillingUsageTransaction.
type EnergyBillingUsageTransaction struct {
	// Optional array of adjustments arising for this transaction
	Adjustments *[]struct {
		// The amount of the adjustment
		Amount string `json:"amount"`

		// A free text description of the adjustment
		Description string `json:"description"`
	} `json:"adjustments,omitempty"`

	// The amount charged or credited for this transaction prior to any adjustments being applied.  A negative value indicates a credit
	Amount string `json:"amount"`

	// Additional calculation factors that inform the transaction
	CalculationFactors *[]struct {
		// The type of the calculation factor
		Type EnergyBillingUsageTransactionCalculationFactorsType `json:"type"`

		// The value of the calculation factor
		Value float32 `json:"value"`
	} `json:"calculationFactors,omitempty"`

	// Optional description of the transaction that can be used for display purposes
	Description *string `json:"description,omitempty"`

	// Date and time when the usage period ends
	EndDate string `json:"endDate"`

	// The number of the invoice in which this transaction is included if it has been issued
	InvoiceNumber *string `json:"invoiceNumber,omitempty"`

	// Flag indicating if the usage is estimated or actual.  True indicates estimate.  False or absent indicates actual
	IsEstimate *bool `json:"isEstimate,omitempty"`

	// The measurement unit of rate. Assumed to be KWH if absent
	MeasureUnit *EnergyBillingUsageTransactionMeasureUnit `json:"measureUnit,omitempty"`

	// The ID of the service point to which this transaction applies if any
	ServicePointId *string `json:"servicePointId,omitempty"`

	// Date and time when the usage period starts
	StartDate string `json:"startDate"`

	// The time of use type that the transaction applies to
	TimeOfUseType EnergyBillingUsageTransactionTimeOfUseType `json:"timeOfUseType"`

	// The usage for the period in measure unit.  A negative value indicates power generated
	Usage float32 `json:"usage"`
}

// The type of the calculation factor
type EnergyBillingUsageTransactionCalculationFactorsType string

// The measurement unit of rate. Assumed to be KWH if absent
type EnergyBillingUsageTransactionMeasureUnit string

// The time of use type that the transaction applies to
type EnergyBillingUsageTransactionTimeOfUseType string

// EnergyConcession defines model for EnergyConcession.
type EnergyConcession struct {
	// Display text providing more information on the concession. Mandatory if type is VARIABLE
	AdditionalInfo *string `json:"additionalInfo,omitempty"`

	// Optional link to additional information regarding the concession
	AdditionalInfoUri *string `json:"additionalInfoUri,omitempty"`

	// Conditional attribute for the amount of discount for the concession- required if type is FIXED_AMOUNT
	Amount *string `json:"amount,omitempty"`

	// Array of ENUM's to specify what the concession applies to. Multiple ENUM values can be provided. If absent, USAGE is assumed
	AppliedTo *[]EnergyConcessionAppliedTo `json:"appliedTo,omitempty"`

	// Conditional attribute for frequency at which a concession is applied. Required if type is FIXED_AMOUNT or FIXED_PERCENTAGE. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	DiscountFrequency *string `json:"discountFrequency,omitempty"`

	// The display name of the concession
	DisplayName string `json:"displayName"`

	// Optional end date for the application of the concession
	EndDate *string `json:"endDate,omitempty"`

	// Conditional attribute for the percentage of discount of concession - required if type is FIXED_PERCENTAGE
	Percentage *string `json:"percentage,omitempty"`

	// Optional start date for the application of the concession
	StartDate *string `json:"startDate,omitempty"`

	// Indicator of the method of concession calculation
	Type EnergyConcessionType `json:"type"`
}

// EnergyConcessionAppliedTo defines model for EnergyConcession.AppliedTo.
type EnergyConcessionAppliedTo string

// Indicator of the method of concession calculation
type EnergyConcessionType string

// EnergyConcessionsResponse defines model for EnergyConcessionsResponse.
type EnergyConcessionsResponse struct {
	Data struct {
		// Array may be empty if no concessions exist
		Concessions []EnergyConcession `json:"concessions"`
	} `json:"data"`
	Links Links `json:"links"`
	Meta  Meta  `json:"meta"`
}

// EnergyDerDetailResponse defines model for EnergyDerDetailResponse.
type EnergyDerDetailResponse struct {
	Data  EnergyDerRecord `json:"data"`
	Links Links           `json:"links"`
	Meta  Meta            `json:"meta"`
}

// EnergyDerListResponse defines model for EnergyDerListResponse.
type EnergyDerListResponse struct {
	Data struct {
		// Array of meter reads
		DerRecords []EnergyDerRecord `json:"derRecords"`
	} `json:"data"`
	Links LinksPaginated `json:"links"`
	Meta  MetaPaginated  `json:"meta"`
}

// EnergyDerRecord defines model for EnergyDerRecord.
type EnergyDerRecord struct {
	AcConnections []struct {
		// The date that the DER installation is commissioned
		CommissioningDate string `json:"commissioningDate"`

		// AC Connection ID as defined in the DER register.  Does not align with CDR ID permanence standards
		ConnectionIdentifier float32 `json:"connectionIdentifier"`

		// Number of AC Connections in the group. For the suite of AC Connections to be considered as a group, all of the AC Connections included must have the same attributes
		Count      int `json:"count"`
		DerDevices []struct {
			// Number of devices in the group of DER devices
			Count int `json:"count"`

			// Unique identifier for a single DER device or a group of DER devices with the same attributes. Does not align with CDR ID permanence standards
			DeviceIdentifier float32 `json:"deviceIdentifier"`

			// The name of the device manufacturer. If absent then assumed to be unknown
			Manufacturer *string `json:"manufacturer,omitempty"`

			// The model number of the device. If absent then assumed to be unknown
			ModelNumber *string `json:"modelNumber,omitempty"`

			// Maximum output in kVA that is listed in the product specification by the manufacturer. This refers to the capacity of each unit within the device group
			NominalRatedCapacity float32 `json:"nominalRatedCapacity"`

			// Maximum storage capacity in kVAh. This refers to the capacity of each storage module within the device group. Mandatory if type is equal to STORAGE
			NominalStorageCapacity *float32 `json:"nominalStorageCapacity,omitempty"`

			// Code used to indicate the status of the device. This will be used to identify if an inverter is active or inactive or decommissioned
			Status *EnergyDerRecordAcConnectionsDerDevicesStatus `json:"status,omitempty"`

			// Used to indicate the primary technology used in the DER device. This field is also used to record for example the battery chemistry, or the type of PV panel. It is also used to record if a battery is contained in an electric vehicle connected in a vehicle-to-grid arrangement. If absent then assumed to be other
			Subtype *string `json:"subtype,omitempty"`

			// Used to indicate the primary technology used in the DER device
			Type EnergyDerRecordAcConnectionsDerDevicesType `json:"type"`
		} `json:"derDevices"`

		// Indicates whether the DER device is connected via an inverter (and what category of inverter it is) or not (e.g. rotating machine). If absent, assume equipment type to be OTHER.
		EquipmentType *EnergyDerRecordAcConnectionsEquipmentType `json:"equipmentType,omitempty"`

		// The rated AC output power that is listed in the product specified by the manufacturer. Mandatory if equipmentType is INVERTER
		InverterDeviceCapacity *float32 `json:"inverterDeviceCapacity,omitempty"`

		// The inverter model number. Mandatory if equipmentType is INVERTER
		InverterModelNumber *string `json:"inverterModelNumber,omitempty"`

		// The inverter series. Mandatory if equipmentType is INVERTER
		InverterSeries *string `json:"inverterSeries,omitempty"`

		// The name of the inverter manufacturer. Mandatory if equipmentType is INVERTER
		ManufacturerName *string `json:"manufacturerName,omitempty"`

		// Code used to indicate the status of the Inverter. This will be used to identify if an inverter is active or inactive or decommissioned
		Status EnergyDerRecordAcConnectionsStatus `json:"status"`
	} `json:"acConnections"`

	// Approved small generating unit capacity as agreed with NSP in the connection agreement, expressed in kVA
	ApprovedCapacity float32 `json:"approvedCapacity"`

	// The number of phases available for the installation of DER. Acceptable values are 1, 2 or 3.
	AvailablePhasesCount int `json:"availablePhasesCount"`

	// For DER installations where NSPs specify the need for additional forms of protection above those inbuilt in an inverter.  If absent then assumed to be false
	HasCentralProtectionControl *bool `json:"hasCentralProtectionControl,omitempty"`

	// The number of phases that DER is connected to. Acceptable values are 1, 2 or 3.
	InstalledPhasesCount int `json:"installedPhasesCount"`

	// For identification of small generating units designed with the ability to operate in an islanded mode
	IslandableInstallation bool `json:"islandableInstallation"`

	// Required only when the hasCentralProtectionAndControl flag is set to true.  One or more of the object fields will be provided to describe the protection modes in place
	ProtectionMode *struct {
		// Maximum amount of power (kVA) that may be exported from a connection point to the grid, as monitored by a control / relay function. An absent value indicates no limit
		ExportLimitKva *float32 `json:"exportLimitKva,omitempty"`

		// Rate of change of frequency trip point (Hz/s).
		FrequencyRateOfChange *float32 `json:"frequencyRateOfChange,omitempty"`

		// Description of the form of inter-trip (e.g. 'from local substation').
		InterTripScheme *string `json:"interTripScheme,omitempty"`

		// Trip voltage.
		NeutralVoltageDisplacement *float32 `json:"neutralVoltageDisplacement,omitempty"`

		// Protective function limit in Hz.
		OverFrequencyProtection *float32 `json:"overFrequencyProtection,omitempty"`

		// Trip delay time in seconds.
		OverFrequencyProtectionDelay *float32 `json:"overFrequencyProtectionDelay,omitempty"`

		// Protective function limit in V.
		OverVoltageProtection *float32 `json:"overVoltageProtection,omitempty"`

		// Trip delay time in seconds.
		OverVoltageProtectionDelay *float32 `json:"overVoltageProtectionDelay,omitempty"`

		// Sustained over voltage.
		SustainedOverVoltage *float32 `json:"sustainedOverVoltage,omitempty"`

		// Sustained Over voltage protection delay in seconds.
		SustainedOverVoltageDelay *float32 `json:"sustainedOverVoltageDelay,omitempty"`

		// Protective function limit in Hz.
		UnderFrequencyProtection *float32 `json:"underFrequencyProtection,omitempty"`

		// Trip delay time in seconds.
		UnderFrequencyProtectionDelay *float32 `json:"underFrequencyProtectionDelay,omitempty"`

		// Protective function limit in V.
		UnderVoltageProtection *float32 `json:"underVoltageProtection,omitempty"`

		// Trip delay time in seconds.
		UnderVoltageProtectionDelay *float32 `json:"underVoltageProtectionDelay,omitempty"`

		// Trip angle in degrees.
		VoltageVectorShift *float32 `json:"voltageVectorShift,omitempty"`
	} `json:"protectionMode,omitempty"`

	// Tokenised ID of the service point to be used for referring to the service point in the CDR API suite.  To be created in accordance with CDR ID permanence requirements
	ServicePointId string `json:"servicePointId"`
}

// Code used to indicate the status of the device. This will be used to identify if an inverter is active or inactive or decommissioned
type EnergyDerRecordAcConnectionsDerDevicesStatus string

// Used to indicate the primary technology used in the DER device
type EnergyDerRecordAcConnectionsDerDevicesType string

// Indicates whether the DER device is connected via an inverter (and what category of inverter it is) or not (e.g. rotating machine). If absent, assume equipment type to be OTHER.
type EnergyDerRecordAcConnectionsEquipmentType string

// Code used to indicate the status of the Inverter. This will be used to identify if an inverter is active or inactive or decommissioned
type EnergyDerRecordAcConnectionsStatus string

// EnergyInvoice defines model for EnergyInvoice.
type EnergyInvoice struct {
	// Object contain charges and credits related to electricity usage
	AccountCharges *EnergyInvoiceAccountCharges `json:"accountCharges,omitempty"`

	// The ID of the account for which the invoice was issued
	AccountId string `json:"accountId"`

	// The account balance at the time the invoice was issued
	BalanceAtIssue string `json:"balanceAtIssue"`

	// The date that the invoice is due to be paid
	DueDate     *string                               `json:"dueDate,omitempty"`
	Electricity *EnergyInvoiceElectricityUsageCharges `json:"electricity,omitempty"`
	Gas         *EnergyInvoiceGasUsageCharges         `json:"gas,omitempty"`

	// The total GST amount for this invoice.  If absent then zero is assumed
	GstAmount *string `json:"gstAmount,omitempty"`

	// The net amount due for this invoice regardless of previous balance
	InvoiceAmount *string `json:"invoiceAmount,omitempty"`

	// The number assigned to this invoice by the energy Retailer
	InvoiceNumber string `json:"invoiceNumber"`

	// The date that the invoice was actually issued (as opposed to generated or calculated)
	IssueDate string `json:"issueDate"`

	// A discount for on time payment
	PayOnTimeDiscount *struct {
		// The date by which the invoice must be paid to receive the pay on time discount
		Date string `json:"date"`

		// The amount that will be discounted if the invoice is paid by the date specified
		DiscountAmount string `json:"discountAmount"`

		// The GST amount that will be discounted if the invoice is paid by the date specified.  If absent then zero is assumed
		GstAmount *string `json:"gstAmount,omitempty"`
	} `json:"payOnTimeDiscount,omitempty"`

	// Indicator of the payment status for the invoice
	PaymentStatus EnergyInvoicePaymentStatus `json:"paymentStatus"`

	// Object containing the start and end date for the period covered by the invoice.  Mandatory if any usage or demand based charges are included in the invoice
	Period *struct {
		// The end date of the period covered by this invoice
		EndDate string `json:"endDate"`

		// The start date of the period covered by this invoice
		StartDate string `json:"startDate"`
	} `json:"period,omitempty"`

	// Array of service point IDs to which this invoice applies. May be empty if the invoice contains no electricity usage related charges
	ServicePoints []string `json:"servicePoints"`
}

// Indicator of the payment status for the invoice
type EnergyInvoicePaymentStatus string

// Object contain charges and credits related to electricity usage
type EnergyInvoiceAccountCharges struct {
	// The aggregate total of account level charges for the period covered by the invoice
	TotalCharges string `json:"totalCharges"`

	// The aggregate total of account level discounts or credits for the period covered by the invoice
	TotalDiscounts string `json:"totalDiscounts"`

	// The total GST for all account level charges.  If absent then zero is assumed
	TotalGst *string `json:"totalGst,omitempty"`
}

// EnergyInvoiceElectricityUsageCharges defines model for EnergyInvoiceElectricityUsageCharges.
type EnergyInvoiceElectricityUsageCharges struct {
	// Optional array of charges that may be part of the invoice (for e.g. environmental charges for C&I consumers) (exclusive of GST)
	OtherCharges *[]struct {
		// The aggregate total of charges for this item (exclusive of GST)
		Amount string `json:"amount"`

		// A free text description of the type of charge
		Description string `json:"description"`

		// Type of charge. Assumed to be other if absent
		Type *EnergyInvoiceElectricityUsageChargesOtherChargesType `json:"type,omitempty"`
	} `json:"otherCharges,omitempty"`

	// The aggregate total of generation credits for the period covered by the invoice (exclusive of GST)
	TotalGenerationCredits string `json:"totalGenerationCredits"`

	// The total GST for all electricity usage charges.  If absent then zero is assumed
	TotalGst *string `json:"totalGst,omitempty"`

	// The aggregate total of any once off charges arising from electricity usage for the period covered by the invoice (exclusive of GST)
	TotalOnceOffCharges string `json:"totalOnceOffCharges"`

	// The aggregate total of any once off discounts or credits arising from electricity usage for the period covered by the invoice (exclusive of GST)
	TotalOnceOffDiscounts string `json:"totalOnceOffDiscounts"`

	// The aggregate total of usage charges for the period covered by the invoice (exclusive of GST)
	TotalUsageCharges string `json:"totalUsageCharges"`
}

// Type of charge. Assumed to be other if absent
type EnergyInvoiceElectricityUsageChargesOtherChargesType string

// EnergyInvoiceGasUsageCharges defines model for EnergyInvoiceGasUsageCharges.
type EnergyInvoiceGasUsageCharges struct {
	// Optional array of charges that may be part of the invoice (for e.g. environmental charges for C&I consumers) (exclusive of GST)
	OtherCharges *[]struct {
		// The aggregate total of charges for this item (exclusive of GST)
		Amount string `json:"amount"`

		// A free text description of the type of charge
		Description string `json:"description"`

		// Type of charge. Assumed to be other if absent
		Type *EnergyInvoiceGasUsageChargesOtherChargesType `json:"type,omitempty"`
	} `json:"otherCharges,omitempty"`

	// The aggregate total of generation credits for the period covered by the invoice (exclusive of GST)
	TotalGenerationCredits string `json:"totalGenerationCredits"`

	// The total GST for all electricity usage charges.  If absent then zero is assumed
	TotalGst *string `json:"totalGst,omitempty"`

	// The aggregate total of any once off charges arising from electricity usage for the period covered by the invoice (exclusive of GST)
	TotalOnceOffCharges string `json:"totalOnceOffCharges"`

	// The aggregate total of any once off discounts or credits arising from electricity usage for the period covered by the invoice (exclusive of GST)
	TotalOnceOffDiscounts string `json:"totalOnceOffDiscounts"`

	// The aggregate total of usage charges for the period covered by the invoice (exclusive of GST)
	TotalUsageCharges string `json:"totalUsageCharges"`
}

// Type of charge. Assumed to be other if absent
type EnergyInvoiceGasUsageChargesOtherChargesType string

// EnergyInvoiceListResponse defines model for EnergyInvoiceListResponse.
type EnergyInvoiceListResponse struct {
	Data struct {
		// Array of invoices sorted by issue date in descending order
		Invoices []EnergyInvoice `json:"invoices"`
	} `json:"data"`
	Links LinksPaginated `json:"links"`
	Meta  MetaPaginated  `json:"meta"`
}

// EnergyPaymentSchedule defines model for EnergyPaymentSchedule.
type EnergyPaymentSchedule struct {
	// Optional payment amount indicating that a constant payment amount is scheduled to be paid (used in bill smooting scenarios)
	Amount *string `json:"amount,omitempty"`

	// Represents a regular credit card payment schedule. Mandatory if paymentScheduleUType is set to cardDebit
	CardDebit *struct {
		// The mechanism by which the payment amount is calculated.  Explanation of values are as follows:<br/><ul><li>**STATIC** - Indicates a consistent, static amount, per payment</li><li>**BALANCE** - Indicates that the outstanding balance for the account is paid per period</li><li>**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm</li></ul>
		CalculationType EnergyPaymentScheduleCardDebitCalculationType `json:"calculationType"`

		// The type of credit card held on file
		CardScheme EnergyPaymentScheduleCardDebitCardScheme `json:"cardScheme"`

		// The frequency that payments will occur.  Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
		PaymentFrequency string `json:"paymentFrequency"`
	} `json:"cardDebit,omitempty"`

	// Represents a regular payment from a digital wallet. Mandatory if paymentScheduleUType is set to digitalWallet
	DigitalWallet *struct {
		// The mechanism by which the payment amount is calculated.  Explanation of values are as follows:<br/><ul><li>**STATIC** - Indicates a consistent, static amount, per payment</li><li>**BALANCE** - Indicates that the outstanding balance for the account is paid per period</li><li>**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm</li></ul>
		CalculationType EnergyPaymentScheduleDigitalWalletCalculationType `json:"calculationType"`

		// The identifier of the digital wallet (dependent on type)
		Identifier string `json:"identifier"`

		// The name assigned to the digital wallet by the owner of the wallet, else the display name provided by the digital wallet provider
		Name string `json:"name"`

		// The frequency that payments will occur.  Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
		PaymentFrequency string `json:"paymentFrequency"`

		// The provider of the digital wallet
		Provider EnergyPaymentScheduleDigitalWalletProvider `json:"provider"`

		// The type of the digital wallet identifier
		Type EnergyPaymentScheduleDigitalWalletType `json:"type"`
	} `json:"digitalWallet,omitempty"`

	// Represents a regular direct debit from a specified bank account. Mandatory if paymentScheduleUType is set to directDebit
	DirectDebit *struct {
		// The unmasked account number for the account to be debited. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces.  Is required if isTokenised is absent or false
		AccountNumber *string `json:"accountNumber,omitempty"`

		// The unmasked BSB for the account to be debited. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces.  Is required if isTokenised is absent or false
		Bsb *string `json:"bsb,omitempty"`

		// The mechanism by which the payment amount is calculated.  Explanation of values are as follows:<br/><ul><li>**STATIC** - Indicates a consistent, static amount, per payment</li><li>**BALANCE** - Indicates that the outstanding balance for the account is paid per period</li><li>**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm</li></ul>
		CalculationType EnergyPaymentScheduleDirectDebitCalculationType `json:"calculationType"`

		// Flag indicating that the account details are tokenised and cannot be shared.  False if absent
		IsTokenised *bool `json:"isTokenised,omitempty"`

		// The frequency that payments will occur.  Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
		PaymentFrequency string `json:"paymentFrequency"`
	} `json:"directDebit,omitempty"`

	// Represents a manual payment schedule where the customer pays in response to a delivered statement. Mandatory if paymentScheduleUType is set to manualPayment
	ManualPayment *struct {
		// The frequency with which a bill will be issued.  Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
		BillFrequency string `json:"billFrequency"`
	} `json:"manualPayment,omitempty"`

	// The type of object present in this response
	PaymentScheduleUType EnergyPaymentSchedulePaymentScheduleUType `json:"paymentScheduleUType"`
}

// The mechanism by which the payment amount is calculated.  Explanation of values are as follows:<br/><ul><li>**STATIC** - Indicates a consistent, static amount, per payment</li><li>**BALANCE** - Indicates that the outstanding balance for the account is paid per period</li><li>**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm</li></ul>
type EnergyPaymentScheduleCardDebitCalculationType string

// The type of credit card held on file
type EnergyPaymentScheduleCardDebitCardScheme string

// The mechanism by which the payment amount is calculated.  Explanation of values are as follows:<br/><ul><li>**STATIC** - Indicates a consistent, static amount, per payment</li><li>**BALANCE** - Indicates that the outstanding balance for the account is paid per period</li><li>**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm</li></ul>
type EnergyPaymentScheduleDigitalWalletCalculationType string

// The provider of the digital wallet
type EnergyPaymentScheduleDigitalWalletProvider string

// The type of the digital wallet identifier
type EnergyPaymentScheduleDigitalWalletType string

// The mechanism by which the payment amount is calculated.  Explanation of values are as follows:<br/><ul><li>**STATIC** - Indicates a consistent, static amount, per payment</li><li>**BALANCE** - Indicates that the outstanding balance for the account is paid per period</li><li>**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm</li></ul>
type EnergyPaymentScheduleDirectDebitCalculationType string

// The type of object present in this response
type EnergyPaymentSchedulePaymentScheduleUType string

// EnergyPaymentScheduleResponse defines model for EnergyPaymentScheduleResponse.
type EnergyPaymentScheduleResponse struct {
	Data struct {
		// Array may be empty if no payment schedule exist
		PaymentSchedules []EnergyPaymentSchedule `json:"paymentSchedules"`
	} `json:"data"`
	Links Links `json:"links"`
	Meta  Meta  `json:"meta"`
}

// EnergyPlan defines model for EnergyPlan.
type EnergyPlan struct {
	// Object that contains links to additional information on specific topics
	AdditionalInformation *struct {
		// A link to detail on bundles that this plan can be a part of
		BundleUri *string `json:"bundleUri,omitempty"`

		// A link to detail on eligibility criteria for the plan
		EligibilityUri *string `json:"eligibilityUri,omitempty"`

		// A link to a general overview of the plan
		OverviewUri *string `json:"overviewUri,omitempty"`

		// A link to detail on pricing for the plan
		PricingUri *string `json:"pricingUri,omitempty"`

		// A link to terms and conditions for the plan
		TermsUri *string `json:"termsUri,omitempty"`
	} `json:"additionalInformation,omitempty"`

	// A link to an application web page where this plan can be applied for
	ApplicationUri *string `json:"applicationUri,omitempty"`

	// The ID of the brand under which this plan is offered
	Brand string `json:"brand"`

	// The display name of the brand under which this plan is offered
	BrandName string `json:"brandName"`

	// The type of customer that the plan is offered to.  If absent then the plan is available to all customers
	CustomerType *EnergyPlanCustomerType `json:"customerType,omitempty"`

	// A description of the plan
	Description *string `json:"description,omitempty"`

	// The display name of the plan
	DisplayName *string `json:"displayName,omitempty"`

	// The date and time from which this plan is effective (ie. is available for origination). Used to enable the articulation of products to the regime before they are available for customers to originate
	EffectiveFrom *string `json:"effectiveFrom,omitempty"`

	// The date and time at which this plan will be retired and will no longer be offered. Used to enable the managed deprecation of plans
	EffectiveTo *string `json:"effectiveTo,omitempty"`

	// The fuel types covered by the plan
	FuelType EnergyPlanFuelType `json:"fuelType"`

	// Describes the geographical area that the plan is available for.  If absent then it is assumed the plan is not geographically limited
	Geography *struct {
		// Array of distributors for the plan. Must have at least one entry
		Distributors []string `json:"distributors"`

		// Array of valid Australian post codes that are specifically excluded from the plan.  Each element is a single four digit postcode (e.g. 3000) or a range of postcodes defined by two four digit postcodes and a hyphen (e.g. 3000-3999)
		ExcludedPostcodes *[]string `json:"excludedPostcodes,omitempty"`

		// Array of valid Australian post codes that are included from the plan.  If absent defaults to all non-excluded post codes.  Each element is a single four digit postcode (e.g. 3000) or a range of postcodes defined by two four digit postcodes and a hyphen (e.g. 3000-3999)
		IncludedPostcodes *[]string `json:"includedPostcodes,omitempty"`
	} `json:"geography,omitempty"`

	// The last date and time that the information for this plan was changed (or the creation date for the plan if it has never been altered)
	LastUpdated string `json:"lastUpdated"`

	// The ID of the specific plan
	PlanId string `json:"planId"`

	// The type of the plan
	Type EnergyPlanType `json:"type"`
}

// The type of customer that the plan is offered to.  If absent then the plan is available to all customers
type EnergyPlanCustomerType string

// The fuel types covered by the plan
type EnergyPlanFuelType string

// The type of the plan
type EnergyPlanType string

// EnergyPlanContract defines model for EnergyPlanContract.
type EnergyPlanContract struct {
	// Free text field containing additional information of the fees for this contract
	AdditionalFeeInformation *string `json:"additionalFeeInformation,omitempty"`

	// Required if pricing model is SINGLE_RATE_CONT_LOAD or TIME_OF_USE_CONT_LOAD or FLEXIBLE_CONT_LOAD
	ControlledLoad *EnergyPlanControlledLoad `json:"controlledLoad,omitempty"`

	// Optional list of discounts available for the contract
	Discounts *EnergyPlanDiscounts `json:"discounts,omitempty"`

	// Eligibility restrictions or requirements
	Eligibility *EnergyPlanEligibility `json:"eligibility,omitempty"`

	// An array of fees applicable to the plan
	Fees *EnergyPlanFees `json:"fees,omitempty"`

	// Optional list of charges applicable to green power
	GreenPowerCharges *EnergyPlanGreenPowerCharges `json:"greenPowerCharges,omitempty"`

	// Optional list of incentives available for the contract
	Incentives *EnergyPlanIncentives `json:"incentives,omitempty"`

	// Describes intrinsic green power for the plan.  If present then the plan includes a percentage of green power in the base plan. Should not be present for gas contracts
	IntrinsicGreenPower *struct {
		// Percentage of green power intrinsically included in the plan
		GreenPercentage string `json:"greenPercentage"`
	} `json:"intrinsicGreenPower,omitempty"`

	// Flag indicating whether prices are fixed or variable
	IsFixed bool `json:"isFixed"`

	// Free text field that describes what will occur on or prior to expiry of the fixed contract term or benefit period
	OnExpiryDescription *string `json:"onExpiryDescription,omitempty"`

	// Payment options for this contract
	PaymentOption []EnergyPlanContractPaymentOption `json:"paymentOption"`

	// The pricing model for the contract.  Contracts for gas must use SINGLE_RATE.  Note that the detail for the enumeration values are:<ul><li>**SINGLE_RATE** - all energy usage is charged at a single unit rate no matter when it is consumed. Multiple unit rates may exist that correspond to varying volumes of usage i.e. a block or step tariff (first 50kWh @ X cents, next 50kWh at Y cents etc.</li><li>**SINGLE_RATE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**TIME_OF_USE** - energy usage is charged at unit rates that vary dependent on time of day and day of week that the energy is consumed</li><li>**TIME_OF_USE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**FLEXIBLE** - energy usage is charged at unit rates that vary based on external factors</li><li>**FLEXIBLE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**QUOTA** - all energy usage is charged at a single fixed rate, up to a specified usage quota/allowance. All excess usage beyond the allowance is then charged at a single unit rate (may not be the best way to explain it but it is essentially a subscription or telco style product i.e. $50/month for up to 150kWh included usage</li></ul>
	PricingModel EnergyPlanContractPricingModel `json:"pricingModel"`

	// Array of feed in tariffs for solar power
	SolarFeedInTariff *EnergyPlanSolarFeedInTariff `json:"solarFeedInTariff,omitempty"`

	// Array of tariff periods
	TariffPeriod EnergyPlanTariffPeriod `json:"tariffPeriod"`

	// Required if pricingModel is set to TIME_OF_USE.  Defines the time zone to use for calculation of the time of use thresholds. Defaults to AEST if absent
	TimeZone *EnergyPlanContractTimeZone `json:"timeZone,omitempty"`

	// Free text description of price variation policy and conditions for the contract.  Mandatory if `isFixed` is false
	Variation *string `json:"variation,omitempty"`
}

// EnergyPlanContractPaymentOption defines model for EnergyPlanContract.PaymentOption.
type EnergyPlanContractPaymentOption string

// The pricing model for the contract.  Contracts for gas must use SINGLE_RATE.  Note that the detail for the enumeration values are:<ul><li>**SINGLE_RATE** - all energy usage is charged at a single unit rate no matter when it is consumed. Multiple unit rates may exist that correspond to varying volumes of usage i.e. a block or step tariff (first 50kWh @ X cents, next 50kWh at Y cents etc.</li><li>**SINGLE_RATE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**TIME_OF_USE** - energy usage is charged at unit rates that vary dependent on time of day and day of week that the energy is consumed</li><li>**TIME_OF_USE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**FLEXIBLE** - energy usage is charged at unit rates that vary based on external factors</li><li>**FLEXIBLE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**QUOTA** - all energy usage is charged at a single fixed rate, up to a specified usage quota/allowance. All excess usage beyond the allowance is then charged at a single unit rate (may not be the best way to explain it but it is essentially a subscription or telco style product i.e. $50/month for up to 150kWh included usage</li></ul>
type EnergyPlanContractPricingModel string

// Required if pricingModel is set to TIME_OF_USE.  Defines the time zone to use for calculation of the time of use thresholds. Defaults to AEST if absent
type EnergyPlanContractTimeZone string

// EnergyPlanContractFull defines model for EnergyPlanContractFull.
type EnergyPlanContractFull struct {
	// Free text field containing additional information of the fees for this contract
	AdditionalFeeInformation *string `json:"additionalFeeInformation,omitempty"`

	// Description of the benefit period.  Should only be present if termType has the value ONGOING
	BenefitPeriod *string `json:"benefitPeriod,omitempty"`

	// An array of the available billing schedules for this contract. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	BillFrequency []string `json:"billFrequency"`

	// Required if pricing model is SINGLE_RATE_CONT_LOAD or TIME_OF_USE_CONT_LOAD or FLEXIBLE_CONT_LOAD
	ControlledLoad *EnergyPlanControlledLoad `json:"controlledLoad,omitempty"`

	// Number of days in the cooling off period for the contract.  Mandatory for plans with type of MARKET
	CoolingOffDays *int `json:"coolingOffDays,omitempty"`

	// Optional list of discounts available for the contract
	Discounts *EnergyPlanDiscounts `json:"discounts,omitempty"`

	// Eligibility restrictions or requirements
	Eligibility *EnergyPlanEligibility `json:"eligibility,omitempty"`

	// An array of fees applicable to the plan
	Fees *EnergyPlanFees `json:"fees,omitempty"`

	// Optional list of charges applicable to green power
	GreenPowerCharges *EnergyPlanGreenPowerCharges `json:"greenPowerCharges,omitempty"`

	// Optional list of incentives available for the contract
	Incentives *EnergyPlanIncentives `json:"incentives,omitempty"`

	// Describes intrinsic green power for the plan.  If present then the plan includes a percentage of green power in the base plan. Should not be present for gas contracts
	IntrinsicGreenPower *struct {
		// Percentage of green power intrinsically included in the plan
		GreenPercentage string `json:"greenPercentage"`
	} `json:"intrinsicGreenPower,omitempty"`

	// Flag indicating whether prices are fixed or variable
	IsFixed bool `json:"isFixed"`

	// An array of the meter types that this contract is available for
	MeterTypes *[]string `json:"meterTypes,omitempty"`

	// Free text field that describes what will occur on or prior to expiry of the fixed contract term or benefit period
	OnExpiryDescription *string `json:"onExpiryDescription,omitempty"`

	// Payment options for this contract
	PaymentOption []EnergyPlanContractFullPaymentOption `json:"paymentOption"`

	// The pricing model for the contract.  Contracts for gas must use SINGLE_RATE.  Note that the detail for the enumeration values are:<ul><li>**SINGLE_RATE** - all energy usage is charged at a single unit rate no matter when it is consumed. Multiple unit rates may exist that correspond to varying volumes of usage i.e. a block or step tariff (first 50kWh @ X cents, next 50kWh at Y cents etc.</li><li>**SINGLE_RATE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**TIME_OF_USE** - energy usage is charged at unit rates that vary dependent on time of day and day of week that the energy is consumed</li><li>**TIME_OF_USE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**FLEXIBLE** - energy usage is charged at unit rates that vary based on external factors</li><li>**FLEXIBLE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**QUOTA** - all energy usage is charged at a single fixed rate, up to a specified usage quota/allowance. All excess usage beyond the allowance is then charged at a single unit rate (may not be the best way to explain it but it is essentially a subscription or telco style product i.e. $50/month for up to 150kWh included usage</li></ul>
	PricingModel EnergyPlanContractFullPricingModel `json:"pricingModel"`

	// Array of feed in tariffs for solar power
	SolarFeedInTariff *EnergyPlanSolarFeedInTariff `json:"solarFeedInTariff,omitempty"`

	// Array of tariff periods
	TariffPeriod EnergyPlanTariffPeriod `json:"tariffPeriod"`

	// The term for the contract.  If absent assumes no specified term
	TermType *EnergyPlanContractFullTermType `json:"termType,omitempty"`

	// Free text description of the terms for the contract
	Terms *string `json:"terms,omitempty"`

	// Required if pricingModel is set to TIME_OF_USE.  Defines the time zone to use for calculation of the time of use thresholds. Defaults to AEST if absent
	TimeZone *EnergyPlanContractFullTimeZone `json:"timeZone,omitempty"`

	// Free text description of price variation policy and conditions for the contract.  Mandatory if `isFixed` is false
	Variation *string `json:"variation,omitempty"`
}

// EnergyPlanContractFullPaymentOption defines model for EnergyPlanContractFull.PaymentOption.
type EnergyPlanContractFullPaymentOption string

// The pricing model for the contract.  Contracts for gas must use SINGLE_RATE.  Note that the detail for the enumeration values are:<ul><li>**SINGLE_RATE** - all energy usage is charged at a single unit rate no matter when it is consumed. Multiple unit rates may exist that correspond to varying volumes of usage i.e. a block or step tariff (first 50kWh @ X cents, next 50kWh at Y cents etc.</li><li>**SINGLE_RATE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**TIME_OF_USE** - energy usage is charged at unit rates that vary dependent on time of day and day of week that the energy is consumed</li><li>**TIME_OF_USE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**FLEXIBLE** - energy usage is charged at unit rates that vary based on external factors</li><li>**FLEXIBLE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**QUOTA** - all energy usage is charged at a single fixed rate, up to a specified usage quota/allowance. All excess usage beyond the allowance is then charged at a single unit rate (may not be the best way to explain it but it is essentially a subscription or telco style product i.e. $50/month for up to 150kWh included usage</li></ul>
type EnergyPlanContractFullPricingModel string

// The term for the contract.  If absent assumes no specified term
type EnergyPlanContractFullTermType string

// Required if pricingModel is set to TIME_OF_USE.  Defines the time zone to use for calculation of the time of use thresholds. Defaults to AEST if absent
type EnergyPlanContractFullTimeZone string

// Required if pricing model is SINGLE_RATE_CONT_LOAD or TIME_OF_USE_CONT_LOAD or FLEXIBLE_CONT_LOAD
type EnergyPlanControlledLoad = []struct {
	// A display name for the controlled load
	DisplayName string `json:"displayName"`

	// Optional end date of the application of the controlled load rate
	EndDate *string `json:"endDate,omitempty"`

	// Specifies the type of controlloed load rate
	RateBlockUType EnergyPlanControlledLoadRateBlockUType `json:"rateBlockUType"`

	// Object representing a single controlled load rate.  Required if rateBlockUType is singleRate
	SingleRate *struct {
		// The daily supply charge (exclusive of GST) for this controlled load tier
		DailySupplyCharge *string `json:"dailySupplyCharge,omitempty"`

		// Description of the controlled load rate
		Description *string `json:"description,omitempty"`

		// Display name of the controlled load rate
		DisplayName string `json:"displayName"`

		// Array of controlled load rates in order of usage volume
		Rates []struct {
			// The measurement unit of rate. Assumed to be KWH if absent
			MeasureUnit *EnergyPlanControlledLoadSingleRateRatesMeasureUnit `json:"measureUnit,omitempty"`

			// Unit price of usage per  measure unit (exclusive of GST)
			UnitPrice string `json:"unitPrice"`

			// Volume in kWh that this rate applies to.  Only applicable for stepped rates where different rates apply for different volumes of usage in a period
			Volume *float32 `json:"volume,omitempty"`
		} `json:"rates"`
	} `json:"singleRate,omitempty"`

	// Optional start date of the application of the controlled load rate
	StartDate *string `json:"startDate,omitempty"`

	// Array of objects representing time of use rates.  Required if rateBlockUType is timeOfUseRates
	TimeOfUseRates *[]struct {
		// The daily supply charge (exclusive of GST) for this controlled load tier
		DailySupplyCharge *string `json:"dailySupplyCharge,omitempty"`

		// Description of the controlled load rate
		Description *string `json:"description,omitempty"`

		// Display name of the controlled load rate
		DisplayName string `json:"displayName"`

		// Array of controlled load rates in order of usage volume
		Rates []struct {
			// The measurement unit of rate. Assumed to be KWH if absent
			MeasureUnit *EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnit `json:"measureUnit,omitempty"`

			// Unit price of usage per  measure unit (exclusive of GST)
			UnitPrice string `json:"unitPrice"`

			// Volume in kWh that this rate applies to.  Only applicable for stepped rates where different rates apply for different volumes of usage in a period
			Volume *float32 `json:"volume,omitempty"`
		} `json:"rates"`

		// Array of times of use.
		TimeOfUse []struct {
			// Display text providing more information on the contrlled load, for e.g. controlled load availability if specific day/time is not known. Required if startTime and endTime absent or if additionalInfoUri provided
			AdditionalInfo *string `json:"additionalInfo,omitempty"`

			// Optional link to additional information regarding the controlled load
			AdditionalInfoUri *string `json:"additionalInfoUri,omitempty"`

			// The days that the rate applies to
			Days *[]EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDays `json:"days,omitempty"`

			// The end of the time period per day for which the controlled load rate applies. Required if startTime provided
			EndTime *string `json:"endTime,omitempty"`

			// The beginning of the time period per day for which the controlled load rate applies. Required if endTime provided
			StartTime *string `json:"startTime,omitempty"`
		} `json:"timeOfUse"`

		// The type of usage that the rate applies to
		Type EnergyPlanControlledLoadTimeOfUseRatesType `json:"type"`
	} `json:"timeOfUseRates,omitempty"`
}

// Specifies the type of controlloed load rate
type EnergyPlanControlledLoadRateBlockUType string

// The measurement unit of rate. Assumed to be KWH if absent
type EnergyPlanControlledLoadSingleRateRatesMeasureUnit string

// The measurement unit of rate. Assumed to be KWH if absent
type EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnit string

// EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDays defines model for EnergyPlanControlledLoad.TimeOfUseRates.TimeOfUse.Days.
type EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDays string

// The type of usage that the rate applies to
type EnergyPlanControlledLoadTimeOfUseRatesType string

// EnergyPlanDetail defines model for EnergyPlanDetail.
type EnergyPlanDetail struct {
	// Object that contains links to additional information on specific topics
	AdditionalInformation *struct {
		// A link to detail on bundles that this plan can be a part of
		BundleUri *string `json:"bundleUri,omitempty"`

		// A link to detail on eligibility criteria for the plan
		EligibilityUri *string `json:"eligibilityUri,omitempty"`

		// A link to a general overview of the plan
		OverviewUri *string `json:"overviewUri,omitempty"`

		// A link to detail on pricing for the plan
		PricingUri *string `json:"pricingUri,omitempty"`

		// A link to terms and conditions for the plan
		TermsUri *string `json:"termsUri,omitempty"`
	} `json:"additionalInformation,omitempty"`

	// A link to an application web page where this plan can be applied for
	ApplicationUri *string `json:"applicationUri,omitempty"`

	// The ID of the brand under which this plan is offered
	Brand string `json:"brand"`

	// The display name of the brand under which this plan is offered
	BrandName string `json:"brandName"`

	// The type of customer that the plan is offered to.  If absent then the plan is available to all customers
	CustomerType *EnergyPlanDetailCustomerType `json:"customerType,omitempty"`

	// A description of the plan
	Description *string `json:"description,omitempty"`

	// The display name of the plan
	DisplayName *string `json:"displayName,omitempty"`

	// The date and time from which this plan is effective (ie. is available for origination). Used to enable the articulation of products to the regime before they are available for customers to originate
	EffectiveFrom *string `json:"effectiveFrom,omitempty"`

	// The date and time at which this plan will be retired and will no longer be offered. Used to enable the managed deprecation of plans
	EffectiveTo         *string                 `json:"effectiveTo,omitempty"`
	ElectricityContract *EnergyPlanContractFull `json:"electricityContract,omitempty"`

	// The fuel types covered by the plan
	FuelType    EnergyPlanDetailFuelType `json:"fuelType"`
	GasContract *EnergyPlanContractFull  `json:"gasContract,omitempty"`

	// Describes the geographical area that the plan is available for.  If absent then it is assumed the plan is not geographically limited
	Geography *struct {
		// Array of distributors for the plan. Must have at least one entry
		Distributors []string `json:"distributors"`

		// Array of valid Australian post codes that are specifically excluded from the plan.  Each element is a single four digit postcode (e.g. 3000) or a range of postcodes defined by two four digit postcodes and a hyphen (e.g. 3000-3999)
		ExcludedPostcodes *[]string `json:"excludedPostcodes,omitempty"`

		// Array of valid Australian post codes that are included from the plan.  If absent defaults to all non-excluded post codes.  Each element is a single four digit postcode (e.g. 3000) or a range of postcodes defined by two four digit postcodes and a hyphen (e.g. 3000-3999)
		IncludedPostcodes *[]string `json:"includedPostcodes,omitempty"`
	} `json:"geography,omitempty"`

	// The last date and time that the information for this plan was changed (or the creation date for the plan if it has never been altered)
	LastUpdated string `json:"lastUpdated"`

	// Charges for metering included in the plan
	MeteringCharges *[]struct {
		// Description of the charge
		Description *string `json:"description,omitempty"`

		// Display name of the charge
		DisplayName string `json:"displayName"`

		// The upper limit of the charge if the charge could occur in a range
		MaximumValue *string `json:"maximumValue,omitempty"`

		// Minimum value of the charge if the charge is a range or the absolute value of the charge if no range is specified
		MinimumValue string `json:"minimumValue"`

		// The charges that occur on a schedule indicates the frequency. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
		Period *string `json:"period,omitempty"`
	} `json:"meteringCharges,omitempty"`

	// The ID of the specific plan
	PlanId string `json:"planId"`

	// The type of the plan
	Type EnergyPlanDetailType `json:"type"`
}

// The type of customer that the plan is offered to.  If absent then the plan is available to all customers
type EnergyPlanDetailCustomerType string

// The fuel types covered by the plan
type EnergyPlanDetailFuelType string

// The type of the plan
type EnergyPlanDetailType string

// Optional list of discounts available for the contract
type EnergyPlanDiscounts = []struct {
	// The type of the discount.  Mandatory if the discount type is CONDITIONAL
	Category *EnergyPlanDiscountsCategory `json:"category,omitempty"`

	// The description of the discount
	Description *string `json:"description,omitempty"`

	// The display name of the discount
	DisplayName string `json:"displayName"`

	// Optional end date for the discount after which the discount is no longer available
	EndDate *string `json:"endDate,omitempty"`

	// Required if methodUType is fixedAmount
	FixedAmount *struct {
		// The amount of the discount
		Amount string `json:"amount"`
	} `json:"fixedAmount,omitempty"`

	// The method of calculation of the discount
	MethodUType EnergyPlanDiscountsMethodUType `json:"methodUType"`

	// Required if methodUType is percentOfBill
	PercentOfBill *struct {
		// The rate of the discount applied to the bill amount
		Rate string `json:"rate"`
	} `json:"percentOfBill,omitempty"`

	// Required if methodUType is percentOfUse
	PercentOfUse *struct {
		// The rate of the discount applied to the usageamount
		Rate string `json:"rate"`
	} `json:"percentOfUse,omitempty"`

	// Required if methodUType is percentOverThreshold
	PercentOverThreshold *struct {
		// The rate of the discount over the usage amount
		Rate string `json:"rate"`

		// The usage amount threshold above which the discount applies
		UsageAmount string `json:"usageAmount"`
	} `json:"percentOverThreshold,omitempty"`

	// The type of the discount
	Type EnergyPlanDiscountsType `json:"type"`
}

// The type of the discount.  Mandatory if the discount type is CONDITIONAL
type EnergyPlanDiscountsCategory string

// The method of calculation of the discount
type EnergyPlanDiscountsMethodUType string

// The type of the discount
type EnergyPlanDiscountsType string

// Eligibility restrictions or requirements
type EnergyPlanEligibility = []struct {
	// A description of the eligibility restriction
	Description *string `json:"description,omitempty"`

	// Information of the eligibility restriction specific to the type of the restriction
	Information string `json:"information"`

	// The type of the eligibility restriction.<br/>The CONTINGENT_PLAN value indicates that the plan is contingent on the customer taking up an alternate fuel plan from the same retailer (for instance, if the fuelType is ELECTRICITY then a GAS plan from the same retailer must be taken up)
	Type EnergyPlanEligibilityType `json:"type"`
}

// The type of the eligibility restriction.<br/>The CONTINGENT_PLAN value indicates that the plan is contingent on the customer taking up an alternate fuel plan from the same retailer (for instance, if the fuelType is ELECTRICITY then a GAS plan from the same retailer must be taken up)
type EnergyPlanEligibilityType string

// An array of fees applicable to the plan
type EnergyPlanFees = []struct {
	// The fee amount. Required if term is not PERCENT_OF_BILL
	Amount *string `json:"amount,omitempty"`

	// A description of the fee
	Description *string `json:"description,omitempty"`

	// The fee rate. Required if term is PERCENT_OF_BILL
	Rate *string `json:"rate,omitempty"`

	// The term of the fee
	Term EnergyPlanFeesTerm `json:"term"`

	// The type of the fee
	Type EnergyPlanFeesType `json:"type"`
}

// The term of the fee
type EnergyPlanFeesTerm string

// The type of the fee
type EnergyPlanFeesType string

// Optional list of charges applicable to green power
type EnergyPlanGreenPowerCharges = []struct {
	// The description of the charge
	Description *string `json:"description,omitempty"`

	// The display name of the charge
	DisplayName string `json:"displayName"`

	// The applicable green power scheme
	Scheme EnergyPlanGreenPowerChargesScheme `json:"scheme"`

	// Array of charge tiers based on the percentage of green power used for the period implied by the type.  Array is in order of increasing percentage of green power
	Tiers []struct {
		// The amount of the charge if the type implies the application of a fixed amount
		Amount *string `json:"amount,omitempty"`

		// The upper percentage of green power used applicable for this tier
		PercentGreen string `json:"percentGreen"`

		// The rate of the charge if the type implies the application of a rate
		Rate *string `json:"rate,omitempty"`
	} `json:"tiers"`

	// The type of charge
	Type EnergyPlanGreenPowerChargesType `json:"type"`
}

// The applicable green power scheme
type EnergyPlanGreenPowerChargesScheme string

// The type of charge
type EnergyPlanGreenPowerChargesType string

// Optional list of incentives available for the contract
type EnergyPlanIncentives = []struct {
	// The type of the incentive
	Category EnergyPlanIncentivesCategory `json:"category"`

	// The description of the incentive
	Description string `json:"description"`

	// The display name of the incentive
	DisplayName string `json:"displayName"`

	// A display message outlining an eligibility criteria that may apply
	Eligibility *string `json:"eligibility,omitempty"`
}

// The type of the incentive
type EnergyPlanIncentivesCategory string

// EnergyPlanListResponse defines model for EnergyPlanListResponse.
type EnergyPlanListResponse struct {
	Data struct {
		// Array of plans
		Plans []EnergyPlan `json:"plans"`
	} `json:"data"`
	Links LinksPaginated `json:"links"`
	Meta  MetaPaginated  `json:"meta"`
}

// EnergyPlanResponse defines model for EnergyPlanResponse.
type EnergyPlanResponse struct {
	Data  EnergyPlanDetail `json:"data"`
	Links Links            `json:"links"`
	Meta  *Meta            `json:"meta,omitempty"`
}

// Array of feed in tariffs for solar power
type EnergyPlanSolarFeedInTariff = []struct {
	// A description of the tariff
	Description *string `json:"description,omitempty"`

	// The name of the tariff
	DisplayName string `json:"displayName"`

	// The type of the payer
	PayerType EnergyPlanSolarFeedInTariffPayerType `json:"payerType"`

	// The applicable scheme
	Scheme EnergyPlanSolarFeedInTariffScheme `json:"scheme"`

	// Represents a constant tariff.  Mandatory if tariffUType is set to singleTariff
	SingleTariff *struct {
		// The tariff amount
		Amount string `json:"amount"`
	} `json:"singleTariff,omitempty"`

	// The type of the payer
	TariffUType EnergyPlanSolarFeedInTariffTariffUType `json:"tariffUType"`

	// Represents a tariff based on time.  Mandatory if tariffUType is set to timeVaryingTariffs
	TimeVaryingTariffs *struct {
		// The tariff amount
		Amount string `json:"amount"`

		// Array of time periods for which this tariff is applicable
		TimeVariations []struct {
			// The days that the tariff applies to. At least one entry required
			Days []EnergyPlanSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays `json:"days"`

			// The end of the time period per day for which the tariff applies.  If absent assumes end of day (ie. one second before midnight)
			EndTime *string `json:"endTime,omitempty"`

			// The beginning of the time period per day for which the tariff applies.  If absent assumes start of day (ie. midnight)
			StartTime *string `json:"startTime,omitempty"`
		} `json:"timeVariations"`

		// The type of the charging time period. If absent applies to all periods
		Type *EnergyPlanSolarFeedInTariffTimeVaryingTariffsType `json:"type,omitempty"`
	} `json:"timeVaryingTariffs,omitempty"`
}

// The type of the payer
type EnergyPlanSolarFeedInTariffPayerType string

// The applicable scheme
type EnergyPlanSolarFeedInTariffScheme string

// The type of the payer
type EnergyPlanSolarFeedInTariffTariffUType string

// EnergyPlanSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays defines model for EnergyPlanSolarFeedInTariff.TimeVaryingTariffs.TimeVariations.Days.
type EnergyPlanSolarFeedInTariffTimeVaryingTariffsTimeVariationsDays string

// The type of the charging time period. If absent applies to all periods
type EnergyPlanSolarFeedInTariffTimeVaryingTariffsType string

// Array of tariff periods
type EnergyPlanTariffPeriod = []struct {
	// The amount of access charge for the tariff period, in dollars per day exclusive of GST.
	DailySupplyCharges *string `json:"dailySupplyCharges,omitempty"`

	// Array of demand charges.  Required if rateBlockUType is demandCharges
	DemandCharges *[]struct {
		// The charge amount per  measure unit exclusive of GST
		Amount string `json:"amount"`

		// Charge period for the demand tariff
		ChargePeriod EnergyPlanTariffPeriodDemandChargesChargePeriod `json:"chargePeriod"`

		// The days that the demand tariff applies to
		Days *[]EnergyPlanTariffPeriodDemandChargesDays `json:"days,omitempty"`

		// Description of the charge
		Description *string `json:"description,omitempty"`

		// Display name of the charge
		DisplayName string `json:"displayName"`

		// End of the period
		EndTime string `json:"endTime"`

		// Maximum demand for this demand tariff in kW.  If present, must be higher than the value of the minDemand field
		MaxDemand *string `json:"maxDemand,omitempty"`

		// The measurement unit of charge amount. Assumed to be KWH if absent
		MeasureUnit *EnergyPlanTariffPeriodDemandChargesMeasureUnit `json:"measureUnit,omitempty"`

		// Application period for the demand tariff
		MeasurementPeriod EnergyPlanTariffPeriodDemandChargesMeasurementPeriod `json:"measurementPeriod"`

		// Minimum demand for this demand tariff in kW.  If absent then 0 is assumed
		MinDemand *string `json:"minDemand,omitempty"`

		// Start of the period
		StartTime string `json:"startTime"`
	} `json:"demandCharges,omitempty"`

	// The name of the tariff period
	DisplayName string `json:"displayName"`

	// The end date of the tariff period in a calendar year.  Formatted in mm-dd format
	EndDate string `json:"endDate"`

	// Specifies the type of rate applicable to this tariff period
	RateBlockUType EnergyPlanTariffPeriodRateBlockUType `json:"rateBlockUType"`

	// Object representing a single rate.  Required if rateBlockUType is singleRate
	SingleRate *struct {
		// Description of the rate
		Description *string `json:"description,omitempty"`

		// Display name of the rate
		DisplayName string `json:"displayName"`

		// The block rate (unit price) for any usage above the included fixed usage, in dollars per kWh inclusive of GST.  Only required if pricingModel field is QUOTA
		GeneralUnitPrice *string `json:"generalUnitPrice,omitempty"`

		// Usage period for which the block rate applies. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
		Period *string `json:"period,omitempty"`

		// Array of controlled load rates in order of usage volume
		Rates []struct {
			// The measurement unit of rate. Assumed to be KWH if absent
			MeasureUnit *EnergyPlanTariffPeriodSingleRateRatesMeasureUnit `json:"measureUnit,omitempty"`

			// Unit price of usage per measure unit (exclusive of GST)
			UnitPrice string `json:"unitPrice"`

			// Volume in kWh that this rate applies to.  Only applicable for stepped rates where different rates apply for different volumes of usage in a period
			Volume *float32 `json:"volume,omitempty"`
		} `json:"rates"`
	} `json:"singleRate,omitempty"`

	// The start date of the tariff period in a calendar year.  Formatted in mm-dd format
	StartDate string `json:"startDate"`

	// Array of objects representing time of use rates.  Required if rateBlockUType is timeOfUseRates
	TimeOfUseRates *[]struct {
		// Description of the rate
		Description *string `json:"description,omitempty"`

		// Display name of the rate
		DisplayName string `json:"displayName"`

		// Array of controlled load rates in order of usage volume
		Rates []struct {
			// The measurement unit of rate. Assumed to be KWH if absent
			MeasureUnit *EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnit `json:"measureUnit,omitempty"`

			// Unit price of usage per  measure unit (exclusive of GST)
			UnitPrice string `json:"unitPrice"`

			// Volume in kWh that this rate applies to.  Only applicable for stepped rates where different rates apply for different volumes of usage in a period
			Volume *float32 `json:"volume,omitempty"`
		} `json:"rates"`

		// Array of times of use
		TimeOfUse []struct {
			// The days that the rate applies to
			Days []EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDays `json:"days"`

			// End of the period
			EndTime string `json:"endTime"`

			// Start of the period
			StartTime string `json:"startTime"`
		} `json:"timeOfUse"`

		// The type of usage that the rate applies to
		Type EnergyPlanTariffPeriodTimeOfUseRatesType `json:"type"`
	} `json:"timeOfUseRates,omitempty"`

	// Specifies the charge specific time zone for calculation of the time of use thresholds. If absent, timezone value in EnergyPlanContract is assumed.
	TimeZone *EnergyPlanTariffPeriodTimeZone `json:"timeZone,omitempty"`

	// Type of charge. Assumed to be other if absent
	Type *EnergyPlanTariffPeriodType `json:"type,omitempty"`
}

// Charge period for the demand tariff
type EnergyPlanTariffPeriodDemandChargesChargePeriod string

// EnergyPlanTariffPeriodDemandChargesDays defines model for EnergyPlanTariffPeriod.DemandCharges.Days.
type EnergyPlanTariffPeriodDemandChargesDays string

// The measurement unit of charge amount. Assumed to be KWH if absent
type EnergyPlanTariffPeriodDemandChargesMeasureUnit string

// Application period for the demand tariff
type EnergyPlanTariffPeriodDemandChargesMeasurementPeriod string

// Specifies the type of rate applicable to this tariff period
type EnergyPlanTariffPeriodRateBlockUType string

// The measurement unit of rate. Assumed to be KWH if absent
type EnergyPlanTariffPeriodSingleRateRatesMeasureUnit string

// The measurement unit of rate. Assumed to be KWH if absent
type EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnit string

// EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDays defines model for EnergyPlanTariffPeriod.TimeOfUseRates.TimeOfUse.Days.
type EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDays string

// The type of usage that the rate applies to
type EnergyPlanTariffPeriodTimeOfUseRatesType string

// Specifies the charge specific time zone for calculation of the time of use thresholds. If absent, timezone value in EnergyPlanContract is assumed.
type EnergyPlanTariffPeriodTimeZone string

// Type of charge. Assumed to be other if absent
type EnergyPlanTariffPeriodType string

// EnergyServicePoint defines model for EnergyServicePoint.
type EnergyServicePoint struct {
	ConsumerProfile *struct {
		// A code that defines the consumer class as defined in the National Energy Retail Regulations, or in overriding Jurisdictional instruments
		Classification *EnergyServicePointConsumerProfileClassification `json:"classification,omitempty"`

		// A code that defines the consumption threshold as defined in the National Energy Retail Regulations, or in overriding Jurisdictional instruments. Note the details of enumeration values below: <ul><li>**LOW** - Consumption is less than the lower consumption threshold as defined in the National Energy Retail Regulations</li><li>**MEDIUM** - Consumption is equal to or greater than the lower consumption threshold, but less than the upper consumption threshold, as defined in the National Energy Retail Regulations</li><li>**HIGH** - Consumption is equal to or greater than the upper consumption threshold as defined in the National Energy Retail Regulations</li></ul>
		Threshold *interface{} `json:"threshold,omitempty"`
	} `json:"consumerProfile,omitempty"`

	// This flag determines whether the energy at this connection point is to be treated as consumer load or as a generating unit(this may include generator auxiliary loads). If absent defaults to false. <br>**Note:** Only applicable for scheduled or semischeduled generators, does not indicate on site generation by consumer
	IsGenerator *bool `json:"isGenerator,omitempty"`

	// Jurisdiction code to which the service point belongs.This code defines the jurisdictional rules which apply to the service point. Note the details of enumeration values below:<ul><li>**ALL** - All Jurisdictions</li><li>**ACT** - Australian Capital Territory</li><li>**NEM** - National Electricity Market</li><li>**NSW** - New South Wales</li><li>**QLD** - Queensland</li><li>**SA** - South Australia</li><li>**TAS** - Tasmania</li><li>**VIC** - Victoria</li></ul>
	JurisdictionCode EnergyServicePointJurisdictionCode `json:"jurisdictionCode"`

	// The date and time that the information for this service point was modified
	LastUpdateDateTime string `json:"lastUpdateDateTime"`

	// The independent ID of the service point, known in the industry as the NMI
	NationalMeteringId string `json:"nationalMeteringId"`

	// The classification of the service point as defined in MSATS procedures
	ServicePointClassification EnergyServicePointServicePointClassification `json:"servicePointClassification"`

	// Tokenised ID of the service point to be used for referring to the service point in the CDR API suite. To be created in accordance with CDR ID permanence requirements
	ServicePointId string `json:"servicePointId"`

	// Code used to indicate the status of the service point. Note the details for the enumeration values below:<ul><li>**ACTIVE** - An active, energised, service point</li><li>**DE_ENERGISED** - The service point exists but is deenergised</li><li>**EXTINCT** - The service point has been permanently decommissioned</li><li>**GREENFIELD** - Applies to a service point that has never been energised</li><li>**OFF_MARKET** - Applies when the service point is no longer settled in the NEM</li></ul>
	ServicePointStatus EnergyServicePointServicePointStatus `json:"servicePointStatus"`

	// The start date from which this service point first became valid
	ValidFromDate string `json:"validFromDate"`
}

// A code that defines the consumer class as defined in the National Energy Retail Regulations, or in overriding Jurisdictional instruments
type EnergyServicePointConsumerProfileClassification string

// Jurisdiction code to which the service point belongs.This code defines the jurisdictional rules which apply to the service point. Note the details of enumeration values below:<ul><li>**ALL** - All Jurisdictions</li><li>**ACT** - Australian Capital Territory</li><li>**NEM** - National Electricity Market</li><li>**NSW** - New South Wales</li><li>**QLD** - Queensland</li><li>**SA** - South Australia</li><li>**TAS** - Tasmania</li><li>**VIC** - Victoria</li></ul>
type EnergyServicePointJurisdictionCode string

// The classification of the service point as defined in MSATS procedures
type EnergyServicePointServicePointClassification string

// Code used to indicate the status of the service point. Note the details for the enumeration values below:<ul><li>**ACTIVE** - An active, energised, service point</li><li>**DE_ENERGISED** - The service point exists but is deenergised</li><li>**EXTINCT** - The service point has been permanently decommissioned</li><li>**GREENFIELD** - Applies to a service point that has never been energised</li><li>**OFF_MARKET** - Applies when the service point is no longer settled in the NEM</li></ul>
type EnergyServicePointServicePointStatus string

// EnergyServicePointDetail defines model for EnergyServicePointDetail.
type EnergyServicePointDetail struct {
	ConsumerProfile *struct {
		// A code that defines the consumer class as defined in the National Energy Retail Regulations, or in overriding Jurisdictional instruments
		Classification *EnergyServicePointDetailConsumerProfileClassification `json:"classification,omitempty"`

		// A code that defines the consumption threshold as defined in the National Energy Retail Regulations, or in overriding Jurisdictional instruments. Note the details of enumeration values below: <ul><li>**LOW** - Consumption is less than the lower consumption threshold as defined in the National Energy Retail Regulations</li><li>**MEDIUM** - Consumption is equal to or greater than the lower consumption threshold, but less than the upper consumption threshold, as defined in the National Energy Retail Regulations</li><li>**HIGH** - Consumption is equal to or greater than the upper consumption threshold as defined in the National Energy Retail Regulations</li></ul>
		Threshold *interface{} `json:"threshold,omitempty"`
	} `json:"consumerProfile,omitempty"`
	DistributionLossFactor struct {
		// A code used to identify data loss factor for the service point values.  Refer to AEMO distribution loss factor documents for each financial year to interpret
		Code string `json:"code"`

		// Description of the data loss factor code and value
		Description string `json:"description"`

		// The value associated with the loss factor code
		LossValue string `json:"lossValue"`
	} `json:"distributionLossFactor"`

	// This flag determines whether the energy at this connection point is to be treated as consumer load or as a generating unit(this may include generator auxiliary loads). If absent defaults to false. <br>**Note:** Only applicable for scheduled or semischeduled generators, does not indicate on site generation by consumer
	IsGenerator *bool `json:"isGenerator,omitempty"`

	// Jurisdiction code to which the service point belongs.This code defines the jurisdictional rules which apply to the service point. Note the details of enumeration values below:<ul><li>**ALL** - All Jurisdictions</li><li>**ACT** - Australian Capital Territory</li><li>**NEM** - National Electricity Market</li><li>**NSW** - New South Wales</li><li>**QLD** - Queensland</li><li>**SA** - South Australia</li><li>**TAS** - Tasmania</li><li>**VIC** - Victoria</li></ul>
	JurisdictionCode EnergyServicePointDetailJurisdictionCode `json:"jurisdictionCode"`

	// The date and time that the information for this service point was modified
	LastUpdateDateTime string                `json:"lastUpdateDateTime"`
	Location           CommonPhysicalAddress `json:"location"`

	// The meters associated with the service point. This may be empty where there are no meters physically installed at the service point
	Meters *[]struct {
		// The meter ID uniquely identifies a meter for a given service point.  It is unique in the context of the service point.  It is not globally unique
		MeterId string `json:"meterId"`

		// Usage data registers available from the meter. This may be empty where there are no meters physically installed at the service point
		Registers *[]struct {
			// The energy delivered through a connection point or metering point over an extended period normalised to a 'per day' basis (kWh). This value is calculated annually.
			AveragedDailyLoad *float32 `json:"averagedDailyLoad,omitempty"`

			// Actual/Subtractive Indicator. Note the details of enumeration values below: <ul><li>**ACTUAL** implies volume of energy actually metered between two dates</li><li>**CUMULATIVE** indicates a meter reading for a specific date. A second Meter Reading is required to determine the consumption between those two Meter Reading dates</li></ul>
			ConsumptionType *EnergyServicePointDetailMetersRegistersConsumptionType `json:"consumptionType,omitempty"`

			// Indicates whether the energy recorded by this register is created under a Controlled Load regime
			ControlledLoad *bool `json:"controlledLoad,omitempty"`

			// Multiplier required to take a register value and turn it into a value representing billable energy
			Multiplier *float32 `json:"multiplier,omitempty"`

			// The Network Tariff Code is a free text field containing a code supplied and published by the local network service provider
			NetworkTariffCode *string `json:"networkTariffCode,omitempty"`

			// Indicates the consumption type of register
			RegisterConsumptionType EnergyServicePointDetailMetersRegistersRegisterConsumptionType `json:"registerConsumptionType"`

			// Unique identifier of the register within this service point.  Is not globally unique
			RegisterId string `json:"registerId"`

			// Register suffix of the meter register where the meter reads are obtained
			RegisterSuffix *string `json:"registerSuffix,omitempty"`

			// Code to identify the time validity of register contents
			TimeOfDay *EnergyServicePointDetailMetersRegistersTimeOfDay `json:"timeOfDay,omitempty"`

			// The unit of measure for data held in this register
			UnitOfMeasure *string `json:"unitOfMeasure,omitempty"`
		} `json:"registers,omitempty"`

		// Technical characteristics of the meter
		Specifications struct {
			// The metering Installation type code indicates whether the metering installation has to be manually read. Note the details of enumeration values below: <ul><li>**BASIC** - Accumulation Meter  Type 6</li><li>**COMMS1** - Interval Meter with communications  Type 1</li><li>**COMMS2** - Interval Meter with communications  Type 2</li><li>**COMMS3** - Interval Meter with communications  Type 3</li><li>**COMMS4** - Interval Meter with communications  Type 4</li><li>**COMMS4C** - CT connected metering installation that meets the minimum services specifications</li><li>**COMMS4D** - Whole current metering installation that meets the minimum services specifications</li><li>**MRAM** - Small customer metering installation  Type 4A</li><li>**MRIM** - Manually Read Interval Meter  Type 5</li><li>**UMCP** - Unmetered Supply  Type 7</li><li>**VICAMI** - A relevant metering installation as defined in clause 9.9C of the NER</li><li>**NCONUML** - Non-contestable unmeter load - Introduced as part of Global Settlement</li></ul>
			InstallationType EnergyServicePointDetailMetersSpecificationsInstallationType `json:"installationType"`

			// Free text field to identify the manufacturer of the installed meter
			Manufacturer *string `json:"manufacturer,omitempty"`

			// Free text field to identify the meter manufacturers designation for the meter model
			Model *string `json:"model,omitempty"`

			// This date is the next scheduled meter read date (NSRD) if a manual Meter Reading is required
			NextScheduledReadDate *string `json:"nextScheduledReadDate,omitempty"`

			// Code to denote the method and frequency of Meter Reading. The value is formatted as follows: <ul><li>First Character = Remote (R) or Manual (M)</li><li>Second Character = Mode: T = telephone W = wireless P = powerline I = infra-red G = galvanic V = visual </li><li>Third Character = Frequency of Scheduled Meter Readings: 1 = Twelve times per year 2 = Six times per year 3 = Four times per year D = Daily or weekly</li><li>Optional Fourth Character = to identify what interval length the meter is capable of reading. This includes five, 15 and 30 minute granularity as the following: A  5 minute B  15 minute C  30 minute D  Cannot convert to 5 minute (i.e. due to metering installation de-energised) M - Manually Read Accumulation Meter</li></ul> For example, <ul><li>MV3 = Manual, Visual, Quarterly</li> <li>MV3M = Manual, Visual, Quarterly, Manually Read Accumulation Meter</li> <li>RWDC = Remote, Wireless, Daily, 30 minutes interval</li></ul>
			ReadType *string `json:"readType,omitempty"`

			// A code to denote the status of the meter. Note the details of enumeration values below: <ul><li>**CURRENT** -Applies when a meter is current and not disconnected</li><li>**DISCONNECTED** - Applies when a meter is present but has been remotely disconnected</li></ul>
			Status EnergyServicePointDetailMetersSpecificationsStatus `json:"status"`
		} `json:"specifications"`
	} `json:"meters,omitempty"`

	// The independent ID of the service point, known in the industry as the NMI
	NationalMeteringId  string `json:"nationalMeteringId"`
	RelatedParticipants []struct {
		// The name of the party/orginsation related to this service point
		Party string `json:"party"`

		// The role performed by this participant in relation to the service point. Note the details of enumeration values below: <ul><li>**FRMP** - Financially Responsible Market Participant</li><li>**LNSP** - Local Network Service Provider or Embedded Network Manager for child connection points</li><li>**DRSP** - wholesale Demand Response and/or market ancillary Service Provider and note that where it is not relevant for a NMI it will not be included</li></ul>
		Role EnergyServicePointDetailRelatedParticipantsRole `json:"role"`
	} `json:"relatedParticipants"`

	// The classification of the service point as defined in MSATS procedures
	ServicePointClassification EnergyServicePointDetailServicePointClassification `json:"servicePointClassification"`

	// The tokenised ID of the service point for use in the CDR APIs.  Created according to the CDR rules for ID permanence
	ServicePointId string `json:"servicePointId"`

	// Code used to indicate the status of the service point. Note the details for the enumeration values below:<ul><li>**ACTIVE** - An active, energised, service point</li><li>**DE_ENERGISED** - The service point exists but is deenergised</li><li>**EXTINCT** - The service point has been permanently decommissioned</li><li>**GREENFIELD** - Applies to a service point that has never been energised</li><li>**OFF_MARKET** - Applies when the service point is no longer settled in the NEM</li></ul>
	ServicePointStatus EnergyServicePointDetailServicePointStatus `json:"servicePointStatus"`

	// The start date from which this service point first became valid
	ValidFromDate string `json:"validFromDate"`
}

// A code that defines the consumer class as defined in the National Energy Retail Regulations, or in overriding Jurisdictional instruments
type EnergyServicePointDetailConsumerProfileClassification string

// Jurisdiction code to which the service point belongs.This code defines the jurisdictional rules which apply to the service point. Note the details of enumeration values below:<ul><li>**ALL** - All Jurisdictions</li><li>**ACT** - Australian Capital Territory</li><li>**NEM** - National Electricity Market</li><li>**NSW** - New South Wales</li><li>**QLD** - Queensland</li><li>**SA** - South Australia</li><li>**TAS** - Tasmania</li><li>**VIC** - Victoria</li></ul>
type EnergyServicePointDetailJurisdictionCode string

// Actual/Subtractive Indicator. Note the details of enumeration values below: <ul><li>**ACTUAL** implies volume of energy actually metered between two dates</li><li>**CUMULATIVE** indicates a meter reading for a specific date. A second Meter Reading is required to determine the consumption between those two Meter Reading dates</li></ul>
type EnergyServicePointDetailMetersRegistersConsumptionType string

// Indicates the consumption type of register
type EnergyServicePointDetailMetersRegistersRegisterConsumptionType string

// Code to identify the time validity of register contents
type EnergyServicePointDetailMetersRegistersTimeOfDay string

// The metering Installation type code indicates whether the metering installation has to be manually read. Note the details of enumeration values below: <ul><li>**BASIC** - Accumulation Meter  Type 6</li><li>**COMMS1** - Interval Meter with communications  Type 1</li><li>**COMMS2** - Interval Meter with communications  Type 2</li><li>**COMMS3** - Interval Meter with communications  Type 3</li><li>**COMMS4** - Interval Meter with communications  Type 4</li><li>**COMMS4C** - CT connected metering installation that meets the minimum services specifications</li><li>**COMMS4D** - Whole current metering installation that meets the minimum services specifications</li><li>**MRAM** - Small customer metering installation  Type 4A</li><li>**MRIM** - Manually Read Interval Meter  Type 5</li><li>**UMCP** - Unmetered Supply  Type 7</li><li>**VICAMI** - A relevant metering installation as defined in clause 9.9C of the NER</li><li>**NCONUML** - Non-contestable unmeter load - Introduced as part of Global Settlement</li></ul>
type EnergyServicePointDetailMetersSpecificationsInstallationType string

// A code to denote the status of the meter. Note the details of enumeration values below: <ul><li>**CURRENT** -Applies when a meter is current and not disconnected</li><li>**DISCONNECTED** - Applies when a meter is present but has been remotely disconnected</li></ul>
type EnergyServicePointDetailMetersSpecificationsStatus string

// The role performed by this participant in relation to the service point. Note the details of enumeration values below: <ul><li>**FRMP** - Financially Responsible Market Participant</li><li>**LNSP** - Local Network Service Provider or Embedded Network Manager for child connection points</li><li>**DRSP** - wholesale Demand Response and/or market ancillary Service Provider and note that where it is not relevant for a NMI it will not be included</li></ul>
type EnergyServicePointDetailRelatedParticipantsRole string

// The classification of the service point as defined in MSATS procedures
type EnergyServicePointDetailServicePointClassification string

// Code used to indicate the status of the service point. Note the details for the enumeration values below:<ul><li>**ACTIVE** - An active, energised, service point</li><li>**DE_ENERGISED** - The service point exists but is deenergised</li><li>**EXTINCT** - The service point has been permanently decommissioned</li><li>**GREENFIELD** - Applies to a service point that has never been energised</li><li>**OFF_MARKET** - Applies when the service point is no longer settled in the NEM</li></ul>
type EnergyServicePointDetailServicePointStatus string

// EnergyServicePointDetailResponse defines model for EnergyServicePointDetailResponse.
type EnergyServicePointDetailResponse struct {
	Data  EnergyServicePointDetail `json:"data"`
	Links Links                    `json:"links"`
	Meta  *Meta                    `json:"meta,omitempty"`
}

// EnergyServicePointListResponse defines model for EnergyServicePointListResponse.
type EnergyServicePointListResponse struct {
	Data struct {
		ServicePoints []EnergyServicePoint `json:"servicePoints"`
	} `json:"data"`
	Links LinksPaginated `json:"links"`
	Meta  MetaPaginated  `json:"meta"`
}

// EnergyUsageListResponse defines model for EnergyUsageListResponse.
type EnergyUsageListResponse struct {
	Data struct {
		// Array of meter reads sorted by NMI in ascending order followed by readStartDate in descending order
		Reads []EnergyUsageRead `json:"reads"`
	} `json:"data"`
	Links LinksPaginated `json:"links"`
	Meta  MetaPaginated  `json:"meta"`
}

// EnergyUsageRead defines model for EnergyUsageRead.
type EnergyUsageRead struct {
	// Mandatory if readUType is set to basicRead
	BasicRead *struct {
		// The quality of the read taken.  If absent then assumed to be ACTUAL
		Quality *EnergyUsageReadBasicReadQuality `json:"quality,omitempty"`

		// Meter read value.  If positive then it means consumption, if negative it means export
		Value float32 `json:"value"`
	} `json:"basicRead,omitempty"`

	// Indicates whether the energy recorded by this register is created under a Controlled Load regime
	ControlledLoad *bool `json:"controlledLoad,omitempty"`

	// Mandatory if readUType is set to intervalRead
	IntervalRead *struct {
		// The aggregate sum of the interval read values. If positive then it means net consumption, if negative it means net export
		AggregateValue float32 `json:"aggregateValue"`

		// Array of Interval read values. If positive then it means consumption, if negative it means export. Required when interval-reads query parameter equals FULL or  MIN_30.<br>Each read value indicates the read for the interval specified by readIntervalLength beginning at midnight of readStartDate (for example 00:00 to 00:30 would be the first reading in a 30 minute Interval)
		IntervalReads *[]float32 `json:"intervalReads,omitempty"`

		// Read interval length in minutes. Required when interval-reads query parameter equals FULL or MIN_30
		ReadIntervalLength *int `json:"readIntervalLength,omitempty"`

		//  Specifies quality of reads that are not ACTUAL.  For read indices that are not specified, quality is assumed to be ACTUAL. If not present, all quality of all reads are assumed to be actual. Required when interval-reads query parameter equals FULL or MIN_30
		ReadQualities *struct {
			// End interval for read quality flag
			EndInterval int `json:"endInterval"`

			// The quality of the read taken
			Quality EnergyUsageReadIntervalReadReadQualitiesQuality `json:"quality"`

			// Start interval for read quality flag. First read begins at 1
			StartInterval int `json:"startInterval"`
		} `json:"readQualities,omitempty"`
	} `json:"intervalRead,omitempty"`

	// Meter id/serial number as it appears in customers bill. ID permanence rules do not apply.
	MeterId *string `json:"meterId,omitempty"`

	// Date when the meter reads end in AEST.  If absent then assumed to be equal to readStartDate.  In this case the entry represents data for a single date specified by readStartDate.
	ReadEndDate *string `json:"readEndDate,omitempty"`

	// Date when the meter reads start in AEST and assumed to start from 12:00 am AEST.
	ReadStartDate string `json:"readStartDate"`

	// Specify the type of the meter read data
	ReadUType EnergyUsageReadReadUType `json:"readUType"`

	// Register ID of the meter register where the meter reads are obtained
	RegisterId *string `json:"registerId,omitempty"`

	// Register suffix of the meter register where the meter reads are obtained
	RegisterSuffix string `json:"registerSuffix"`

	// Tokenised ID of the service point to be used for referring to the service point in the CDR API suite.  To be created in accordance with CDR ID permanence requirements
	ServicePointId string `json:"servicePointId"`

	// Unit of measure of the meter reads. Refer to Appendix B of <a href='https://www.aemo.com.au/-/media/files/stakeholder_consultation/consultations/nem-consultations/2019/5ms-metering-package-2/final-determination/mdff-specification-nem12-nem13-v21-final-determination-clean.pdf?la=en&hash=03FCBA0D60E091DE00F2361AE76206EA'>MDFF Specification NEM12 NEM13 v2.1</a> for a list of possible values.
	UnitOfMeasure *string `json:"unitOfMeasure,omitempty"`
}

// The quality of the read taken.  If absent then assumed to be ACTUAL
type EnergyUsageReadBasicReadQuality string

// The quality of the read taken
type EnergyUsageReadIntervalReadReadQualitiesQuality string

// Specify the type of the meter read data
type EnergyUsageReadReadUType string

// ErrorListResponse defines model for ErrorListResponse.
type ErrorListResponse struct {
	Errors []struct {
		// The code of the error encountered. Where the error is specific to the respondent, an application-specific error code, expressed as a string value. If the error is application-specific, the URN code that the specific error extends must be provided in the meta object. Otherwise, the value is the error code URN.
		Code string `json:"code"`

		// A human-readable explanation specific to this occurrence of the problem.
		Detail string `json:"detail"`

		// Additional data for customised error codes
		Meta *struct {
			// The CDR error code URN which the application-specific error code extends. Mandatory if the error `code` is an application-specific error rather than a standardised error code.
			Urn *string `json:"urn,omitempty"`
		} `json:"meta,omitempty"`

		// A short, human-readable summary of the problem that MUST NOT change from occurrence to occurrence of the problem represented by the error code.
		Title string `json:"title"`
	} `json:"errors"`
}

// Links defines model for Links.
type Links struct {
	// Fully qualified link that generated the current response document
	Self string `json:"self"`
}

// LinksPaginated defines model for LinksPaginated.
type LinksPaginated struct {
	// URI to the first page of this set. Mandatory if this response is not the first page
	First *string `json:"first,omitempty"`

	// URI to the last page of this set. Mandatory if this response is not the last page
	Last *string `json:"last,omitempty"`

	// URI to the next page of this set. Mandatory if this response is not the last page
	Next *string `json:"next,omitempty"`

	// URI to the previous page of this set. Mandatory if this response is not the first page
	Prev *string `json:"prev,omitempty"`

	// Fully qualified link that generated the current response document
	Self string `json:"self"`
}

// Meta defines model for Meta.
type Meta = map[string]interface{}

// MetaPaginated defines model for MetaPaginated.
type MetaPaginated struct {
	// The total number of pages in the full set. See [pagination](#pagination).
	TotalPages int `json:"totalPages"`

	// The total number of records in the full set. See [pagination](#pagination).
	TotalRecords int `json:"totalRecords"`
}

// AccountId defines model for accountId.
type AccountId = string

// IntervalReads defines model for interval-reads.
type IntervalReads string

// NewestDate defines model for newest-date.
type NewestDate = string

// NewestTime defines model for newest-time.
type NewestTime = string

// OldestDate defines model for oldest-date.
type OldestDate = string

// OldestTime defines model for oldest-time.
type OldestTime = string

// OpenStatus defines model for open-status.
type OpenStatus string

// Page defines model for page.
type Page = int

// PageSize defines model for page-size.
type PageSize = int

// ServicePointId defines model for servicePointId.
type ServicePointId = string

// XCdsClientHeaders defines model for x-cds-client-headers.
type XCdsClientHeaders = string

// XFapiAuthDate defines model for x-fapi-auth-date.
type XFapiAuthDate = string

// XFapiCustomerIpAddress defines model for x-fapi-customer-ip-address.
type XFapiCustomerIpAddress = string

// XFapiInteractionId defines model for x-fapi-interaction-id.
type XFapiInteractionId = string

// XMinV defines model for x-min-v.
type XMinV = string

// XV defines model for x-v.
type XV = string

// AccountConcessionsDetail defines model for accountConcessionsDetail.
type AccountConcessionsDetail = EnergyConcessionsResponse

// AccountDetailV2 defines model for accountDetailV2.
type AccountDetailV2 = EnergyAccountDetailResponseV2

// AccountListV2 defines model for accountListV2.
type AccountListV2 = EnergyAccountListResponseV2

// AccountPaymentScheduleDetail defines model for accountPaymentScheduleDetail.
type AccountPaymentScheduleDetail = EnergyPaymentScheduleResponse

// BalanceDetail defines model for balanceDetail.
type BalanceDetail = EnergyBalanceResponse

// BalanceList defines model for balanceList.
type BalanceList = EnergyBalanceListResponse

// BillingList defines model for billingList.
type BillingList = EnergyBillingListResponse

// DerDetail defines model for derDetail.
type DerDetail = EnergyDerDetailResponse

// DerList defines model for derList.
type DerList = EnergyDerListResponse

// InvoiceList defines model for invoiceList.
type InvoiceList = EnergyInvoiceListResponse

// PlanDetail defines model for planDetail.
type PlanDetail = EnergyPlanResponse

// PlanList defines model for planList.
type PlanList = EnergyPlanListResponse

// ServicePointDetail defines model for servicePointDetail.
type ServicePointDetail = EnergyServicePointDetailResponse

// ServicePointList defines model for servicePointList.
type ServicePointList = EnergyServicePointListResponse

// UsageList defines model for usageList.
type UsageList = EnergyUsageListResponse

// AccountIdList defines model for accountIdList.
type AccountIdList struct {
	Data struct {
		// Array of specific accountIds to obtain data for
		AccountIds []string `json:"accountIds"`
	} `json:"data"`
	Meta Meta `json:"meta"`
}

// ServicePointIdList defines model for servicePointIdList.
type ServicePointIdList struct {
	Data struct {
		// Array of specific servicePointIds to obtain data for
		ServicePointIds []string `json:"servicePointIds"`
	} `json:"data"`
	Meta Meta `json:"meta"`
}

// ListAccountsParams defines parameters for ListAccounts.
type ListAccountsParams struct {
	// Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed
	OpenStatus *ListAccountsParamsOpenStatus `form:"open-status,omitempty" json:"open-status,omitempty"`

	// Page of results to request (standard pagination)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Page size to request.  Default is 25 (standard pagination)
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV XV `json:"x-v"`

	// Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *XMinV `json:"x-min-v,omitempty"`

	// An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *XFapiInteractionId `json:"x-fapi-interaction-id,omitempty"`

	// The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *XFapiCustomerIpAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *XCdsClientHeaders `json:"x-cds-client-headers,omitempty"`
}

// ListAccountsParamsOpenStatus defines parameters for ListAccounts.
type ListAccountsParamsOpenStatus string

// ListBalancesBulkParams defines parameters for ListBalancesBulk.
type ListBalancesBulkParams struct {
	// Page of results to request (standard pagination)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Page size to request.  Default is 25 (standard pagination)
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV XV `json:"x-v"`

	// Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *XMinV `json:"x-min-v,omitempty"`

	// An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *XFapiInteractionId `json:"x-fapi-interaction-id,omitempty"`

	// The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *XFapiCustomerIpAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *XCdsClientHeaders `json:"x-cds-client-headers,omitempty"`
}

// ListBalancesForAccountsParams defines parameters for ListBalancesForAccounts.
type ListBalancesForAccountsParams struct {
	// Page of results to request (standard pagination)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Page size to request.  Default is 25 (standard pagination)
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV XV `json:"x-v"`

	// Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *XMinV `json:"x-min-v,omitempty"`

	// An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *XFapiInteractionId `json:"x-fapi-interaction-id,omitempty"`

	// The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *XFapiCustomerIpAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *XCdsClientHeaders `json:"x-cds-client-headers,omitempty"`
}

// ListBillingBulkParams defines parameters for ListBillingBulk.
type ListBillingBulkParams struct {
	// Constrain the request to records with effective time at or before this date/time.  If absent defaults to current date/time.  Format is aligned to DateTimeString common type
	NewestTime *NewestTime `form:"newest-time,omitempty" json:"newest-time,omitempty"`

	// Constrain the request to records with effective time at or after this date/time. If absent defaults to newest-time minus 12 months.  Format is aligned to DateTimeString common type
	OldestTime *OldestTime `form:"oldest-time,omitempty" json:"oldest-time,omitempty"`

	// Page of results to request (standard pagination)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Page size to request.  Default is 25 (standard pagination)
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV XV `json:"x-v"`

	// Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *XMinV `json:"x-min-v,omitempty"`

	// An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *XFapiInteractionId `json:"x-fapi-interaction-id,omitempty"`

	// The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *XFapiCustomerIpAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *XCdsClientHeaders `json:"x-cds-client-headers,omitempty"`
}

// ListBillingForAccountsParams defines parameters for ListBillingForAccounts.
type ListBillingForAccountsParams struct {
	// Constrain the request to records with effective time at or before this date/time.  If absent defaults to current date/time.  Format is aligned to DateTimeString common type
	NewestTime *NewestTime `form:"newest-time,omitempty" json:"newest-time,omitempty"`

	// Constrain the request to records with effective time at or after this date/time. If absent defaults to newest-time minus 12 months.  Format is aligned to DateTimeString common type
	OldestTime *OldestTime `form:"oldest-time,omitempty" json:"oldest-time,omitempty"`

	// Page of results to request (standard pagination)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Page size to request.  Default is 25 (standard pagination)
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV XV `json:"x-v"`

	// Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *XMinV `json:"x-min-v,omitempty"`

	// An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *XFapiInteractionId `json:"x-fapi-interaction-id,omitempty"`

	// The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *XFapiCustomerIpAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *XCdsClientHeaders `json:"x-cds-client-headers,omitempty"`
}

// ListInvoicesBulkParams defines parameters for ListInvoicesBulk.
type ListInvoicesBulkParams struct {
	// Constrain the request to records with effective date at or before this date.  If absent defaults to current date.  Format is aligned to DateString common type
	NewestDate *NewestDate `form:"newest-date,omitempty" json:"newest-date,omitempty"`

	// Constrain the request to records with effective date at or after this date. If absent defaults to newest-date minus 24 months.  Format is aligned to DateString common type
	OldestDate *OldestDate `form:"oldest-date,omitempty" json:"oldest-date,omitempty"`

	// Page of results to request (standard pagination)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Page size to request.  Default is 25 (standard pagination)
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV XV `json:"x-v"`

	// Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *XMinV `json:"x-min-v,omitempty"`

	// An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *XFapiInteractionId `json:"x-fapi-interaction-id,omitempty"`

	// The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *XFapiCustomerIpAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *XCdsClientHeaders `json:"x-cds-client-headers,omitempty"`
}

// ListInvoicesForAccountsParams defines parameters for ListInvoicesForAccounts.
type ListInvoicesForAccountsParams struct {
	// Constrain the request to records with effective date at or before this date.  If absent defaults to current date.  Format is aligned to DateString common type
	NewestDate *NewestDate `form:"newest-date,omitempty" json:"newest-date,omitempty"`

	// Constrain the request to records with effective date at or after this date. If absent defaults to newest-date minus 24 months.  Format is aligned to DateString common type
	OldestDate *OldestDate `form:"oldest-date,omitempty" json:"oldest-date,omitempty"`

	// Page of results to request (standard pagination)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Page size to request.  Default is 25 (standard pagination)
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV XV `json:"x-v"`

	// Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *XMinV `json:"x-min-v,omitempty"`

	// An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *XFapiInteractionId `json:"x-fapi-interaction-id,omitempty"`

	// The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *XFapiCustomerIpAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *XCdsClientHeaders `json:"x-cds-client-headers,omitempty"`
}

// GetAccountParams defines parameters for GetAccount.
type GetAccountParams struct {
	// Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed
	OpenStatus *GetAccountParamsOpenStatus `form:"open-status,omitempty" json:"open-status,omitempty"`

	// Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV XV `json:"x-v"`

	// Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *XMinV `json:"x-min-v,omitempty"`

	// An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *XFapiInteractionId `json:"x-fapi-interaction-id,omitempty"`

	// The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *XFapiCustomerIpAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *XCdsClientHeaders `json:"x-cds-client-headers,omitempty"`
}

// GetAccountParamsOpenStatus defines parameters for GetAccount.
type GetAccountParamsOpenStatus string

// GetBalanceForAccountParams defines parameters for GetBalanceForAccount.
type GetBalanceForAccountParams struct {
	// Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV XV `json:"x-v"`

	// Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *XMinV `json:"x-min-v,omitempty"`

	// An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *XFapiInteractionId `json:"x-fapi-interaction-id,omitempty"`

	// The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *XFapiCustomerIpAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *XCdsClientHeaders `json:"x-cds-client-headers,omitempty"`
}

// GetBillingForAccountParams defines parameters for GetBillingForAccount.
type GetBillingForAccountParams struct {
	// Constrain the request to records with effective time at or before this date/time.  If absent defaults to current date/time.  Format is aligned to DateTimeString common type
	NewestTime *NewestTime `form:"newest-time,omitempty" json:"newest-time,omitempty"`

	// Constrain the request to records with effective time at or after this date/time. If absent defaults to newest-time minus 12 months.  Format is aligned to DateTimeString common type
	OldestTime *OldestTime `form:"oldest-time,omitempty" json:"oldest-time,omitempty"`

	// Page of results to request (standard pagination)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Page size to request.  Default is 25 (standard pagination)
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV XV `json:"x-v"`

	// Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *XMinV `json:"x-min-v,omitempty"`

	// An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *XFapiInteractionId `json:"x-fapi-interaction-id,omitempty"`

	// The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *XFapiCustomerIpAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *XCdsClientHeaders `json:"x-cds-client-headers,omitempty"`
}

// GetConcessionsParams defines parameters for GetConcessions.
type GetConcessionsParams struct {
	// Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV XV `json:"x-v"`

	// Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *XMinV `json:"x-min-v,omitempty"`

	// An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *XFapiInteractionId `json:"x-fapi-interaction-id,omitempty"`

	// The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *XFapiCustomerIpAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *XCdsClientHeaders `json:"x-cds-client-headers,omitempty"`
}

// GetInvoicesForAccountParams defines parameters for GetInvoicesForAccount.
type GetInvoicesForAccountParams struct {
	// Constrain the request to records with effective date at or before this date.  If absent defaults to current date.  Format is aligned to DateString common type
	NewestDate *NewestDate `form:"newest-date,omitempty" json:"newest-date,omitempty"`

	// Constrain the request to records with effective date at or after this date. If absent defaults to newest-date minus 24 months.  Format is aligned to DateString common type
	OldestDate *OldestDate `form:"oldest-date,omitempty" json:"oldest-date,omitempty"`

	// Page of results to request (standard pagination)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Page size to request.  Default is 25 (standard pagination)
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV XV `json:"x-v"`

	// Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *XMinV `json:"x-min-v,omitempty"`

	// An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *XFapiInteractionId `json:"x-fapi-interaction-id,omitempty"`

	// The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *XFapiCustomerIpAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *XCdsClientHeaders `json:"x-cds-client-headers,omitempty"`
}

// GetPaymentScheduleParams defines parameters for GetPaymentSchedule.
type GetPaymentScheduleParams struct {
	// Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV XV `json:"x-v"`

	// Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *XMinV `json:"x-min-v,omitempty"`

	// An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *XFapiInteractionId `json:"x-fapi-interaction-id,omitempty"`

	// The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *XFapiCustomerIpAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *XCdsClientHeaders `json:"x-cds-client-headers,omitempty"`
}

// ListServicePointsParams defines parameters for ListServicePoints.
type ListServicePointsParams struct {
	// Page of results to request (standard pagination)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Page size to request.  Default is 25 (standard pagination)
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV XV `json:"x-v"`

	// Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *XMinV `json:"x-min-v,omitempty"`

	// An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *XFapiInteractionId `json:"x-fapi-interaction-id,omitempty"`

	// The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *XFapiCustomerIpAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *XCdsClientHeaders `json:"x-cds-client-headers,omitempty"`
}

// ListDERBulkParams defines parameters for ListDERBulk.
type ListDERBulkParams struct {
	// Page of results to request (standard pagination)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Page size to request.  Default is 25 (standard pagination)
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV XV `json:"x-v"`

	// Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *XMinV `json:"x-min-v,omitempty"`

	// An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *XFapiInteractionId `json:"x-fapi-interaction-id,omitempty"`

	// The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *XFapiCustomerIpAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *XCdsClientHeaders `json:"x-cds-client-headers,omitempty"`
}

// ListDERForServicePointsParams defines parameters for ListDERForServicePoints.
type ListDERForServicePointsParams struct {
	// Page of results to request (standard pagination)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Page size to request.  Default is 25 (standard pagination)
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV XV `json:"x-v"`

	// Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *XMinV `json:"x-min-v,omitempty"`

	// An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *XFapiInteractionId `json:"x-fapi-interaction-id,omitempty"`

	// The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *XFapiCustomerIpAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *XCdsClientHeaders `json:"x-cds-client-headers,omitempty"`
}

// ListUsageBulkParams defines parameters for ListUsageBulk.
type ListUsageBulkParams struct {
	// Type of interval reads. Any one of the valid values for this field can be supplied. If absent defaults to NONE
	IntervalReads *ListUsageBulkParamsIntervalReads `form:"interval-reads,omitempty" json:"interval-reads,omitempty"`

	// Constrain the request to records with effective date at or after this date. If absent defaults to newest-date minus 24 months.  Format is aligned to DateString common type
	OldestDate *OldestDate `form:"oldest-date,omitempty" json:"oldest-date,omitempty"`

	// Constrain the request to records with effective date at or before this date.  If absent defaults to current date.  Format is aligned to DateString common type
	NewestDate *NewestDate `form:"newest-date,omitempty" json:"newest-date,omitempty"`

	// Page of results to request (standard pagination)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Page size to request.  Default is 25 (standard pagination)
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV XV `json:"x-v"`

	// Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *XMinV `json:"x-min-v,omitempty"`

	// An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *XFapiInteractionId `json:"x-fapi-interaction-id,omitempty"`

	// The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *XFapiCustomerIpAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *XCdsClientHeaders `json:"x-cds-client-headers,omitempty"`
}

// ListUsageBulkParamsIntervalReads defines parameters for ListUsageBulk.
type ListUsageBulkParamsIntervalReads string

// ListUsageForServicePointsParams defines parameters for ListUsageForServicePoints.
type ListUsageForServicePointsParams struct {
	// Constrain the request to records with effective date at or after this date. If absent defaults to newest-date minus 24 months.  Format is aligned to DateString common type
	OldestDate *OldestDate `form:"oldest-date,omitempty" json:"oldest-date,omitempty"`

	// Constrain the request to records with effective date at or before this date.  If absent defaults to current date.  Format is aligned to DateString common type
	NewestDate *NewestDate `form:"newest-date,omitempty" json:"newest-date,omitempty"`

	// Type of interval reads. Any one of the valid values for this field can be supplied. If absent defaults to NONE
	IntervalReads *ListUsageForServicePointsParamsIntervalReads `form:"interval-reads,omitempty" json:"interval-reads,omitempty"`

	// Page of results to request (standard pagination)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Page size to request.  Default is 25 (standard pagination)
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV XV `json:"x-v"`

	// Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *XMinV `json:"x-min-v,omitempty"`

	// An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *XFapiInteractionId `json:"x-fapi-interaction-id,omitempty"`

	// The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *XFapiCustomerIpAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *XCdsClientHeaders `json:"x-cds-client-headers,omitempty"`
}

// ListUsageForServicePointsParamsIntervalReads defines parameters for ListUsageForServicePoints.
type ListUsageForServicePointsParamsIntervalReads string

// GetServicePointParams defines parameters for GetServicePoint.
type GetServicePointParams struct {
	// Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV XV `json:"x-v"`

	// Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *XMinV `json:"x-min-v,omitempty"`

	// An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *XFapiInteractionId `json:"x-fapi-interaction-id,omitempty"`

	// The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *XFapiCustomerIpAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *XCdsClientHeaders `json:"x-cds-client-headers,omitempty"`
}

// GetDERForServicePointParams defines parameters for GetDERForServicePoint.
type GetDERForServicePointParams struct {
	// Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV XV `json:"x-v"`

	// Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *XMinV `json:"x-min-v,omitempty"`

	// An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *XFapiInteractionId `json:"x-fapi-interaction-id,omitempty"`

	// The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *XFapiCustomerIpAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *XCdsClientHeaders `json:"x-cds-client-headers,omitempty"`
}

// GetUsageForServicePointParams defines parameters for GetUsageForServicePoint.
type GetUsageForServicePointParams struct {
	// Constrain the request to records with effective date at or after this date. If absent defaults to newest-date minus 24 months.  Format is aligned to DateString common type
	OldestDate *OldestDate `form:"oldest-date,omitempty" json:"oldest-date,omitempty"`

	// Constrain the request to records with effective date at or before this date.  If absent defaults to current date.  Format is aligned to DateString common type
	NewestDate *NewestDate `form:"newest-date,omitempty" json:"newest-date,omitempty"`

	// Type of interval reads. Any one of the valid values for this field can be supplied. If absent defaults to NONE
	IntervalReads *GetUsageForServicePointParamsIntervalReads `form:"interval-reads,omitempty" json:"interval-reads,omitempty"`

	// Page of results to request (standard pagination)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Page size to request.  Default is 25 (standard pagination)
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV XV `json:"x-v"`

	// Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *XMinV `json:"x-min-v,omitempty"`

	// An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *XFapiInteractionId `json:"x-fapi-interaction-id,omitempty"`

	// The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *XFapiCustomerIpAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *XCdsClientHeaders `json:"x-cds-client-headers,omitempty"`
}

// GetUsageForServicePointParamsIntervalReads defines parameters for GetUsageForServicePoint.
type GetUsageForServicePointParamsIntervalReads string

// ListPlansParams defines parameters for ListPlans.
type ListPlansParams struct {
	// Used to filter results on the type field.  Any one of the valid values for this field can be supplied plus 'ALL'.  If absent defaults to 'ALL'
	Type *ListPlansParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Used to filter results on the fuelType field.  Any one of the valid values for this field can be supplied plus 'ALL'.  If absent defaults to 'ALL'
	FuelType *ListPlansParamsFuelType `form:"fuelType,omitempty" json:"fuelType,omitempty"`

	// Allows for the filtering of plans based on whether the current time is within the period of time defined as effective by the effectiveFrom and effectiveTo fields. Valid values are CURRENT, FUTURE and ALL. If absent defaults to 'CURRENT'
	Effective *ListPlansParamsEffective `form:"effective,omitempty" json:"effective,omitempty"`

	// Only include plans that have been updated after the specified date and time.  If absent defaults to include all plans
	UpdatedSince *string `form:"updated-since,omitempty" json:"updated-since,omitempty"`

	// Used to filter results on the brand field.  If absent defaults to include all plans
	Brand *string `form:"brand,omitempty" json:"brand,omitempty"`

	// Page of results to request (standard pagination)
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Page size to request.  Default is 25 (standard pagination)
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV XV `json:"x-v"`

	// Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *XMinV `json:"x-min-v,omitempty"`
}

// ListPlansParamsType defines parameters for ListPlans.
type ListPlansParamsType string

// ListPlansParamsFuelType defines parameters for ListPlans.
type ListPlansParamsFuelType string

// ListPlansParamsEffective defines parameters for ListPlans.
type ListPlansParamsEffective string

// GetPlanParams defines parameters for GetPlan.
type GetPlanParams struct {
	// Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV XV `json:"x-v"`

	// Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *XMinV `json:"x-min-v,omitempty"`
}

// ListBalancesForAccountsJSONRequestBody defines body for ListBalancesForAccounts for application/json ContentType.
type ListBalancesForAccountsJSONRequestBody AccountIdList

// ListBillingForAccountsJSONRequestBody defines body for ListBillingForAccounts for application/json ContentType.
type ListBillingForAccountsJSONRequestBody AccountIdList

// ListInvoicesForAccountsJSONRequestBody defines body for ListInvoicesForAccounts for application/json ContentType.
type ListInvoicesForAccountsJSONRequestBody AccountIdList

// ListDERForServicePointsJSONRequestBody defines body for ListDERForServicePoints for application/json ContentType.
type ListDERForServicePointsJSONRequestBody ServicePointIdList

// ListUsageForServicePointsJSONRequestBody defines body for ListUsageForServicePoints for application/json ContentType.
type ListUsageForServicePointsJSONRequestBody ServicePointIdList

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListAccounts request
	ListAccounts(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBalancesBulk request
	ListBalancesBulk(ctx context.Context, params *ListBalancesBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBalancesForAccounts request with any body
	ListBalancesForAccountsWithBody(ctx context.Context, params *ListBalancesForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListBalancesForAccounts(ctx context.Context, params *ListBalancesForAccountsParams, body ListBalancesForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBillingBulk request
	ListBillingBulk(ctx context.Context, params *ListBillingBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBillingForAccounts request with any body
	ListBillingForAccountsWithBody(ctx context.Context, params *ListBillingForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListBillingForAccounts(ctx context.Context, params *ListBillingForAccountsParams, body ListBillingForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInvoicesBulk request
	ListInvoicesBulk(ctx context.Context, params *ListInvoicesBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInvoicesForAccounts request with any body
	ListInvoicesForAccountsWithBody(ctx context.Context, params *ListInvoicesForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListInvoicesForAccounts(ctx context.Context, params *ListInvoicesForAccountsParams, body ListInvoicesForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccount request
	GetAccount(ctx context.Context, accountId AccountId, params *GetAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBalanceForAccount request
	GetBalanceForAccount(ctx context.Context, accountId AccountId, params *GetBalanceForAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBillingForAccount request
	GetBillingForAccount(ctx context.Context, accountId AccountId, params *GetBillingForAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConcessions request
	GetConcessions(ctx context.Context, accountId AccountId, params *GetConcessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvoicesForAccount request
	GetInvoicesForAccount(ctx context.Context, accountId AccountId, params *GetInvoicesForAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPaymentSchedule request
	GetPaymentSchedule(ctx context.Context, accountId AccountId, params *GetPaymentScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListServicePoints request
	ListServicePoints(ctx context.Context, params *ListServicePointsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDERBulk request
	ListDERBulk(ctx context.Context, params *ListDERBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDERForServicePoints request with any body
	ListDERForServicePointsWithBody(ctx context.Context, params *ListDERForServicePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListDERForServicePoints(ctx context.Context, params *ListDERForServicePointsParams, body ListDERForServicePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsageBulk request
	ListUsageBulk(ctx context.Context, params *ListUsageBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsageForServicePoints request with any body
	ListUsageForServicePointsWithBody(ctx context.Context, params *ListUsageForServicePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListUsageForServicePoints(ctx context.Context, params *ListUsageForServicePointsParams, body ListUsageForServicePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServicePoint request
	GetServicePoint(ctx context.Context, servicePointId ServicePointId, params *GetServicePointParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDERForServicePoint request
	GetDERForServicePoint(ctx context.Context, servicePointId ServicePointId, params *GetDERForServicePointParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsageForServicePoint request
	GetUsageForServicePoint(ctx context.Context, servicePointId ServicePointId, params *GetUsageForServicePointParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPlans request
	ListPlans(ctx context.Context, params *ListPlansParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlan request
	GetPlan(ctx context.Context, planId string, params *GetPlanParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListAccounts(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBalancesBulk(ctx context.Context, params *ListBalancesBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBalancesBulkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBalancesForAccountsWithBody(ctx context.Context, params *ListBalancesForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBalancesForAccountsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBalancesForAccounts(ctx context.Context, params *ListBalancesForAccountsParams, body ListBalancesForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBalancesForAccountsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBillingBulk(ctx context.Context, params *ListBillingBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBillingBulkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBillingForAccountsWithBody(ctx context.Context, params *ListBillingForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBillingForAccountsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBillingForAccounts(ctx context.Context, params *ListBillingForAccountsParams, body ListBillingForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBillingForAccountsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInvoicesBulk(ctx context.Context, params *ListInvoicesBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInvoicesBulkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInvoicesForAccountsWithBody(ctx context.Context, params *ListInvoicesForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInvoicesForAccountsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInvoicesForAccounts(ctx context.Context, params *ListInvoicesForAccountsParams, body ListInvoicesForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInvoicesForAccountsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccount(ctx context.Context, accountId AccountId, params *GetAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBalanceForAccount(ctx context.Context, accountId AccountId, params *GetBalanceForAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBalanceForAccountRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBillingForAccount(ctx context.Context, accountId AccountId, params *GetBillingForAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBillingForAccountRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConcessions(ctx context.Context, accountId AccountId, params *GetConcessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConcessionsRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvoicesForAccount(ctx context.Context, accountId AccountId, params *GetInvoicesForAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvoicesForAccountRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPaymentSchedule(ctx context.Context, accountId AccountId, params *GetPaymentScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaymentScheduleRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServicePoints(ctx context.Context, params *ListServicePointsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServicePointsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDERBulk(ctx context.Context, params *ListDERBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDERBulkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDERForServicePointsWithBody(ctx context.Context, params *ListDERForServicePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDERForServicePointsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDERForServicePoints(ctx context.Context, params *ListDERForServicePointsParams, body ListDERForServicePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDERForServicePointsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsageBulk(ctx context.Context, params *ListUsageBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsageBulkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsageForServicePointsWithBody(ctx context.Context, params *ListUsageForServicePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsageForServicePointsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsageForServicePoints(ctx context.Context, params *ListUsageForServicePointsParams, body ListUsageForServicePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsageForServicePointsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServicePoint(ctx context.Context, servicePointId ServicePointId, params *GetServicePointParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicePointRequest(c.Server, servicePointId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDERForServicePoint(ctx context.Context, servicePointId ServicePointId, params *GetDERForServicePointParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDERForServicePointRequest(c.Server, servicePointId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsageForServicePoint(ctx context.Context, servicePointId ServicePointId, params *GetUsageForServicePointParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsageForServicePointRequest(c.Server, servicePointId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPlans(ctx context.Context, params *ListPlansParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPlansRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlan(ctx context.Context, planId string, params *GetPlanParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlanRequest(c.Server, planId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAccountsRequest generates requests for ListAccounts
func NewListAccountsRequest(server string, params *ListAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.OpenStatus != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "open-status", runtime.ParamLocationQuery, *params.OpenStatus); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListBalancesBulkRequest generates requests for ListBalancesBulk
func NewListBalancesBulkRequest(server string, params *ListBalancesBulkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/balances")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListBalancesForAccountsRequest calls the generic ListBalancesForAccounts builder with application/json body
func NewListBalancesForAccountsRequest(server string, params *ListBalancesForAccountsParams, body ListBalancesForAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListBalancesForAccountsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewListBalancesForAccountsRequestWithBody generates requests for ListBalancesForAccounts with any type of body
func NewListBalancesForAccountsRequestWithBody(server string, params *ListBalancesForAccountsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/balances")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListBillingBulkRequest generates requests for ListBillingBulk
func NewListBillingBulkRequest(server string, params *ListBillingBulkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/billing")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.NewestTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-time", runtime.ParamLocationQuery, *params.NewestTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OldestTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-time", runtime.ParamLocationQuery, *params.OldestTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListBillingForAccountsRequest calls the generic ListBillingForAccounts builder with application/json body
func NewListBillingForAccountsRequest(server string, params *ListBillingForAccountsParams, body ListBillingForAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListBillingForAccountsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewListBillingForAccountsRequestWithBody generates requests for ListBillingForAccounts with any type of body
func NewListBillingForAccountsRequestWithBody(server string, params *ListBillingForAccountsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/billing")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.NewestTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-time", runtime.ParamLocationQuery, *params.NewestTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OldestTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-time", runtime.ParamLocationQuery, *params.OldestTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListInvoicesBulkRequest generates requests for ListInvoicesBulk
func NewListInvoicesBulkRequest(server string, params *ListInvoicesBulkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/invoices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.NewestDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-date", runtime.ParamLocationQuery, *params.NewestDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OldestDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-date", runtime.ParamLocationQuery, *params.OldestDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListInvoicesForAccountsRequest calls the generic ListInvoicesForAccounts builder with application/json body
func NewListInvoicesForAccountsRequest(server string, params *ListInvoicesForAccountsParams, body ListInvoicesForAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListInvoicesForAccountsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewListInvoicesForAccountsRequestWithBody generates requests for ListInvoicesForAccounts with any type of body
func NewListInvoicesForAccountsRequestWithBody(server string, params *ListInvoicesForAccountsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/invoices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.NewestDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-date", runtime.ParamLocationQuery, *params.NewestDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OldestDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-date", runtime.ParamLocationQuery, *params.OldestDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewGetAccountRequest generates requests for GetAccount
func NewGetAccountRequest(server string, accountId AccountId, params *GetAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.OpenStatus != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "open-status", runtime.ParamLocationQuery, *params.OpenStatus); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewGetBalanceForAccountRequest generates requests for GetBalanceForAccount
func NewGetBalanceForAccountRequest(server string, accountId AccountId, params *GetBalanceForAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/%s/balance", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewGetBillingForAccountRequest generates requests for GetBillingForAccount
func NewGetBillingForAccountRequest(server string, accountId AccountId, params *GetBillingForAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/%s/billing", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.NewestTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-time", runtime.ParamLocationQuery, *params.NewestTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OldestTime != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-time", runtime.ParamLocationQuery, *params.OldestTime); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewGetConcessionsRequest generates requests for GetConcessions
func NewGetConcessionsRequest(server string, accountId AccountId, params *GetConcessionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/%s/concessions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewGetInvoicesForAccountRequest generates requests for GetInvoicesForAccount
func NewGetInvoicesForAccountRequest(server string, accountId AccountId, params *GetInvoicesForAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/%s/invoices", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.NewestDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-date", runtime.ParamLocationQuery, *params.NewestDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OldestDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-date", runtime.ParamLocationQuery, *params.OldestDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewGetPaymentScheduleRequest generates requests for GetPaymentSchedule
func NewGetPaymentScheduleRequest(server string, accountId AccountId, params *GetPaymentScheduleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/%s/payment-schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListServicePointsRequest generates requests for ListServicePoints
func NewListServicePointsRequest(server string, params *ListServicePointsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/electricity/servicepoints")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListDERBulkRequest generates requests for ListDERBulk
func NewListDERBulkRequest(server string, params *ListDERBulkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/electricity/servicepoints/der")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListDERForServicePointsRequest calls the generic ListDERForServicePoints builder with application/json body
func NewListDERForServicePointsRequest(server string, params *ListDERForServicePointsParams, body ListDERForServicePointsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListDERForServicePointsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewListDERForServicePointsRequestWithBody generates requests for ListDERForServicePoints with any type of body
func NewListDERForServicePointsRequestWithBody(server string, params *ListDERForServicePointsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/electricity/servicepoints/der")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListUsageBulkRequest generates requests for ListUsageBulk
func NewListUsageBulkRequest(server string, params *ListUsageBulkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/electricity/servicepoints/usage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IntervalReads != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval-reads", runtime.ParamLocationQuery, *params.IntervalReads); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OldestDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-date", runtime.ParamLocationQuery, *params.OldestDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NewestDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-date", runtime.ParamLocationQuery, *params.NewestDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListUsageForServicePointsRequest calls the generic ListUsageForServicePoints builder with application/json body
func NewListUsageForServicePointsRequest(server string, params *ListUsageForServicePointsParams, body ListUsageForServicePointsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListUsageForServicePointsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewListUsageForServicePointsRequestWithBody generates requests for ListUsageForServicePoints with any type of body
func NewListUsageForServicePointsRequestWithBody(server string, params *ListUsageForServicePointsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/electricity/servicepoints/usage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.OldestDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-date", runtime.ParamLocationQuery, *params.OldestDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NewestDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-date", runtime.ParamLocationQuery, *params.NewestDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IntervalReads != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval-reads", runtime.ParamLocationQuery, *params.IntervalReads); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewGetServicePointRequest generates requests for GetServicePoint
func NewGetServicePointRequest(server string, servicePointId ServicePointId, params *GetServicePointParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "servicePointId", runtime.ParamLocationPath, servicePointId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/electricity/servicepoints/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewGetDERForServicePointRequest generates requests for GetDERForServicePoint
func NewGetDERForServicePointRequest(server string, servicePointId ServicePointId, params *GetDERForServicePointParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "servicePointId", runtime.ParamLocationPath, servicePointId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/electricity/servicepoints/%s/der", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewGetUsageForServicePointRequest generates requests for GetUsageForServicePoint
func NewGetUsageForServicePointRequest(server string, servicePointId ServicePointId, params *GetUsageForServicePointParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "servicePointId", runtime.ParamLocationPath, servicePointId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/electricity/servicepoints/%s/usage", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.OldestDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-date", runtime.ParamLocationQuery, *params.OldestDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NewestDate != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-date", runtime.ParamLocationQuery, *params.NewestDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IntervalReads != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval-reads", runtime.ParamLocationQuery, *params.IntervalReads); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	if params.XFapiInteractionId != nil {
		var headerParam2 string

		headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-interaction-id", headerParam2)
	}

	if params.XFapiAuthDate != nil {
		var headerParam3 string

		headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-auth-date", headerParam3)
	}

	if params.XFapiCustomerIpAddress != nil {
		var headerParam4 string

		headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-fapi-customer-ip-address", headerParam4)
	}

	if params.XCdsClientHeaders != nil {
		var headerParam5 string

		headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-cds-client-headers", headerParam5)
	}

	return req, nil
}

// NewListPlansRequest generates requests for ListPlans
func NewListPlansRequest(server string, params *ListPlansParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/plans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FuelType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fuelType", runtime.ParamLocationQuery, *params.FuelType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Effective != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective", runtime.ParamLocationQuery, *params.Effective); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.UpdatedSince != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated-since", runtime.ParamLocationQuery, *params.UpdatedSince); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Brand != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "brand", runtime.ParamLocationQuery, *params.Brand); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	return req, nil
}

// NewGetPlanRequest generates requests for GetPlan
func NewGetPlanRequest(server string, planId string, params *GetPlanParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "planId", runtime.ParamLocationPath, planId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/plans/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	var headerParam0 string

	headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
	if err != nil {
		return nil, err
	}

	req.Header.Set("x-v", headerParam0)

	if params.XMinV != nil {
		var headerParam1 string

		headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-min-v", headerParam1)
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAccounts request
	ListAccountsWithResponse(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*ListAccountsResponse, error)

	// ListBalancesBulk request
	ListBalancesBulkWithResponse(ctx context.Context, params *ListBalancesBulkParams, reqEditors ...RequestEditorFn) (*ListBalancesBulkResponse, error)

	// ListBalancesForAccounts request with any body
	ListBalancesForAccountsWithBodyWithResponse(ctx context.Context, params *ListBalancesForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListBalancesForAccountsResponse, error)

	ListBalancesForAccountsWithResponse(ctx context.Context, params *ListBalancesForAccountsParams, body ListBalancesForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListBalancesForAccountsResponse, error)

	// ListBillingBulk request
	ListBillingBulkWithResponse(ctx context.Context, params *ListBillingBulkParams, reqEditors ...RequestEditorFn) (*ListBillingBulkResponse, error)

	// ListBillingForAccounts request with any body
	ListBillingForAccountsWithBodyWithResponse(ctx context.Context, params *ListBillingForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListBillingForAccountsResponse, error)

	ListBillingForAccountsWithResponse(ctx context.Context, params *ListBillingForAccountsParams, body ListBillingForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListBillingForAccountsResponse, error)

	// ListInvoicesBulk request
	ListInvoicesBulkWithResponse(ctx context.Context, params *ListInvoicesBulkParams, reqEditors ...RequestEditorFn) (*ListInvoicesBulkResponse, error)

	// ListInvoicesForAccounts request with any body
	ListInvoicesForAccountsWithBodyWithResponse(ctx context.Context, params *ListInvoicesForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListInvoicesForAccountsResponse, error)

	ListInvoicesForAccountsWithResponse(ctx context.Context, params *ListInvoicesForAccountsParams, body ListInvoicesForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListInvoicesForAccountsResponse, error)

	// GetAccount request
	GetAccountWithResponse(ctx context.Context, accountId AccountId, params *GetAccountParams, reqEditors ...RequestEditorFn) (*GetAccountResponse, error)

	// GetBalanceForAccount request
	GetBalanceForAccountWithResponse(ctx context.Context, accountId AccountId, params *GetBalanceForAccountParams, reqEditors ...RequestEditorFn) (*GetBalanceForAccountResponse, error)

	// GetBillingForAccount request
	GetBillingForAccountWithResponse(ctx context.Context, accountId AccountId, params *GetBillingForAccountParams, reqEditors ...RequestEditorFn) (*GetBillingForAccountResponse, error)

	// GetConcessions request
	GetConcessionsWithResponse(ctx context.Context, accountId AccountId, params *GetConcessionsParams, reqEditors ...RequestEditorFn) (*GetConcessionsResponse, error)

	// GetInvoicesForAccount request
	GetInvoicesForAccountWithResponse(ctx context.Context, accountId AccountId, params *GetInvoicesForAccountParams, reqEditors ...RequestEditorFn) (*GetInvoicesForAccountResponse, error)

	// GetPaymentSchedule request
	GetPaymentScheduleWithResponse(ctx context.Context, accountId AccountId, params *GetPaymentScheduleParams, reqEditors ...RequestEditorFn) (*GetPaymentScheduleResponse, error)

	// ListServicePoints request
	ListServicePointsWithResponse(ctx context.Context, params *ListServicePointsParams, reqEditors ...RequestEditorFn) (*ListServicePointsResponse, error)

	// ListDERBulk request
	ListDERBulkWithResponse(ctx context.Context, params *ListDERBulkParams, reqEditors ...RequestEditorFn) (*ListDERBulkResponse, error)

	// ListDERForServicePoints request with any body
	ListDERForServicePointsWithBodyWithResponse(ctx context.Context, params *ListDERForServicePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListDERForServicePointsResponse, error)

	ListDERForServicePointsWithResponse(ctx context.Context, params *ListDERForServicePointsParams, body ListDERForServicePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListDERForServicePointsResponse, error)

	// ListUsageBulk request
	ListUsageBulkWithResponse(ctx context.Context, params *ListUsageBulkParams, reqEditors ...RequestEditorFn) (*ListUsageBulkResponse, error)

	// ListUsageForServicePoints request with any body
	ListUsageForServicePointsWithBodyWithResponse(ctx context.Context, params *ListUsageForServicePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListUsageForServicePointsResponse, error)

	ListUsageForServicePointsWithResponse(ctx context.Context, params *ListUsageForServicePointsParams, body ListUsageForServicePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListUsageForServicePointsResponse, error)

	// GetServicePoint request
	GetServicePointWithResponse(ctx context.Context, servicePointId ServicePointId, params *GetServicePointParams, reqEditors ...RequestEditorFn) (*GetServicePointResponse, error)

	// GetDERForServicePoint request
	GetDERForServicePointWithResponse(ctx context.Context, servicePointId ServicePointId, params *GetDERForServicePointParams, reqEditors ...RequestEditorFn) (*GetDERForServicePointResponse, error)

	// GetUsageForServicePoint request
	GetUsageForServicePointWithResponse(ctx context.Context, servicePointId ServicePointId, params *GetUsageForServicePointParams, reqEditors ...RequestEditorFn) (*GetUsageForServicePointResponse, error)

	// ListPlans request
	ListPlansWithResponse(ctx context.Context, params *ListPlansParams, reqEditors ...RequestEditorFn) (*ListPlansResponse, error)

	// GetPlan request
	GetPlanWithResponse(ctx context.Context, planId string, params *GetPlanParams, reqEditors ...RequestEditorFn) (*GetPlanResponse, error)
}

type ListAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyAccountListResponseV2
	JSON400      *ErrorListResponse
	JSON406      *ErrorListResponse
	JSON422      *ErrorListResponse
}

// Status returns HTTPResponse.Status
func (r ListAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBalancesBulkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyBalanceListResponse
	JSON400      *ErrorListResponse
	JSON406      *ErrorListResponse
	JSON422      *ErrorListResponse
}

// Status returns HTTPResponse.Status
func (r ListBalancesBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBalancesBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBalancesForAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyBalanceListResponse
	JSON400      *ErrorListResponse
	JSON406      *ErrorListResponse
	JSON422      *ErrorListResponse
}

// Status returns HTTPResponse.Status
func (r ListBalancesForAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBalancesForAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBillingBulkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyBillingListResponse
	JSON400      *ErrorListResponse
	JSON406      *ErrorListResponse
	JSON422      *ErrorListResponse
}

// Status returns HTTPResponse.Status
func (r ListBillingBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBillingBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBillingForAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyBillingListResponse
	JSON400      *ErrorListResponse
	JSON406      *ErrorListResponse
	JSON422      *ErrorListResponse
}

// Status returns HTTPResponse.Status
func (r ListBillingForAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBillingForAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInvoicesBulkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyInvoiceListResponse
	JSON400      *ErrorListResponse
	JSON406      *ErrorListResponse
	JSON422      *ErrorListResponse
}

// Status returns HTTPResponse.Status
func (r ListInvoicesBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInvoicesBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInvoicesForAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyInvoiceListResponse
	JSON400      *ErrorListResponse
	JSON406      *ErrorListResponse
	JSON422      *ErrorListResponse
}

// Status returns HTTPResponse.Status
func (r ListInvoicesForAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInvoicesForAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyAccountDetailResponseV2
	JSON400      *ErrorListResponse
	JSON404      *ErrorListResponse
	JSON406      *ErrorListResponse
}

// Status returns HTTPResponse.Status
func (r GetAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBalanceForAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyBalanceResponse
	JSON400      *ErrorListResponse
	JSON404      *ErrorListResponse
	JSON406      *ErrorListResponse
}

// Status returns HTTPResponse.Status
func (r GetBalanceForAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBalanceForAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBillingForAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyBillingListResponse
	JSON400      *ErrorListResponse
	JSON404      *ErrorListResponse
	JSON406      *ErrorListResponse
	JSON422      *ErrorListResponse
}

// Status returns HTTPResponse.Status
func (r GetBillingForAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBillingForAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConcessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyConcessionsResponse
	JSON400      *ErrorListResponse
	JSON404      *ErrorListResponse
	JSON406      *ErrorListResponse
}

// Status returns HTTPResponse.Status
func (r GetConcessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConcessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvoicesForAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyInvoiceListResponse
	JSON400      *ErrorListResponse
	JSON404      *ErrorListResponse
	JSON406      *ErrorListResponse
	JSON422      *ErrorListResponse
}

// Status returns HTTPResponse.Status
func (r GetInvoicesForAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvoicesForAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyPaymentScheduleResponse
	JSON400      *ErrorListResponse
	JSON404      *ErrorListResponse
	JSON406      *ErrorListResponse
}

// Status returns HTTPResponse.Status
func (r GetPaymentScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListServicePointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyServicePointListResponse
	JSON400      *ErrorListResponse
	JSON406      *ErrorListResponse
	JSON422      *ErrorListResponse
}

// Status returns HTTPResponse.Status
func (r ListServicePointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServicePointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDERBulkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyDerListResponse
	JSON400      *ErrorListResponse
	JSON406      *ErrorListResponse
	JSON422      *ErrorListResponse
}

// Status returns HTTPResponse.Status
func (r ListDERBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDERBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDERForServicePointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyDerListResponse
	JSON400      *ErrorListResponse
	JSON406      *ErrorListResponse
	JSON422      *ErrorListResponse
}

// Status returns HTTPResponse.Status
func (r ListDERForServicePointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDERForServicePointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsageBulkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyUsageListResponse
	JSON400      *ErrorListResponse
	JSON406      *ErrorListResponse
	JSON422      *ErrorListResponse
}

// Status returns HTTPResponse.Status
func (r ListUsageBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsageBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsageForServicePointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyUsageListResponse
	JSON400      *ErrorListResponse
	JSON406      *ErrorListResponse
	JSON422      *ErrorListResponse
}

// Status returns HTTPResponse.Status
func (r ListUsageForServicePointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsageForServicePointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicePointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyServicePointDetailResponse
	JSON400      *ErrorListResponse
	JSON404      *ErrorListResponse
	JSON406      *ErrorListResponse
}

// Status returns HTTPResponse.Status
func (r GetServicePointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicePointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDERForServicePointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyDerDetailResponse
	JSON400      *ErrorListResponse
	JSON404      *ErrorListResponse
	JSON406      *ErrorListResponse
}

// Status returns HTTPResponse.Status
func (r GetDERForServicePointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDERForServicePointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsageForServicePointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyUsageListResponse
	JSON400      *ErrorListResponse
	JSON404      *ErrorListResponse
	JSON406      *ErrorListResponse
	JSON422      *ErrorListResponse
}

// Status returns HTTPResponse.Status
func (r GetUsageForServicePointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsageForServicePointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPlansResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyPlanListResponse
	JSON400      *ErrorListResponse
	JSON406      *ErrorListResponse
	JSON422      *ErrorListResponse
}

// Status returns HTTPResponse.Status
func (r ListPlansResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPlansResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlanResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyPlanResponse
	JSON400      *ErrorListResponse
	JSON404      *ErrorListResponse
	JSON406      *ErrorListResponse
}

// Status returns HTTPResponse.Status
func (r GetPlanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAccountsWithResponse request returning *ListAccountsResponse
func (c *ClientWithResponses) ListAccountsWithResponse(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*ListAccountsResponse, error) {
	rsp, err := c.ListAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAccountsResponse(rsp)
}

// ListBalancesBulkWithResponse request returning *ListBalancesBulkResponse
func (c *ClientWithResponses) ListBalancesBulkWithResponse(ctx context.Context, params *ListBalancesBulkParams, reqEditors ...RequestEditorFn) (*ListBalancesBulkResponse, error) {
	rsp, err := c.ListBalancesBulk(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBalancesBulkResponse(rsp)
}

// ListBalancesForAccountsWithBodyWithResponse request with arbitrary body returning *ListBalancesForAccountsResponse
func (c *ClientWithResponses) ListBalancesForAccountsWithBodyWithResponse(ctx context.Context, params *ListBalancesForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListBalancesForAccountsResponse, error) {
	rsp, err := c.ListBalancesForAccountsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBalancesForAccountsResponse(rsp)
}

func (c *ClientWithResponses) ListBalancesForAccountsWithResponse(ctx context.Context, params *ListBalancesForAccountsParams, body ListBalancesForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListBalancesForAccountsResponse, error) {
	rsp, err := c.ListBalancesForAccounts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBalancesForAccountsResponse(rsp)
}

// ListBillingBulkWithResponse request returning *ListBillingBulkResponse
func (c *ClientWithResponses) ListBillingBulkWithResponse(ctx context.Context, params *ListBillingBulkParams, reqEditors ...RequestEditorFn) (*ListBillingBulkResponse, error) {
	rsp, err := c.ListBillingBulk(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBillingBulkResponse(rsp)
}

// ListBillingForAccountsWithBodyWithResponse request with arbitrary body returning *ListBillingForAccountsResponse
func (c *ClientWithResponses) ListBillingForAccountsWithBodyWithResponse(ctx context.Context, params *ListBillingForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListBillingForAccountsResponse, error) {
	rsp, err := c.ListBillingForAccountsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBillingForAccountsResponse(rsp)
}

func (c *ClientWithResponses) ListBillingForAccountsWithResponse(ctx context.Context, params *ListBillingForAccountsParams, body ListBillingForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListBillingForAccountsResponse, error) {
	rsp, err := c.ListBillingForAccounts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBillingForAccountsResponse(rsp)
}

// ListInvoicesBulkWithResponse request returning *ListInvoicesBulkResponse
func (c *ClientWithResponses) ListInvoicesBulkWithResponse(ctx context.Context, params *ListInvoicesBulkParams, reqEditors ...RequestEditorFn) (*ListInvoicesBulkResponse, error) {
	rsp, err := c.ListInvoicesBulk(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInvoicesBulkResponse(rsp)
}

// ListInvoicesForAccountsWithBodyWithResponse request with arbitrary body returning *ListInvoicesForAccountsResponse
func (c *ClientWithResponses) ListInvoicesForAccountsWithBodyWithResponse(ctx context.Context, params *ListInvoicesForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListInvoicesForAccountsResponse, error) {
	rsp, err := c.ListInvoicesForAccountsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInvoicesForAccountsResponse(rsp)
}

func (c *ClientWithResponses) ListInvoicesForAccountsWithResponse(ctx context.Context, params *ListInvoicesForAccountsParams, body ListInvoicesForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListInvoicesForAccountsResponse, error) {
	rsp, err := c.ListInvoicesForAccounts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInvoicesForAccountsResponse(rsp)
}

// GetAccountWithResponse request returning *GetAccountResponse
func (c *ClientWithResponses) GetAccountWithResponse(ctx context.Context, accountId AccountId, params *GetAccountParams, reqEditors ...RequestEditorFn) (*GetAccountResponse, error) {
	rsp, err := c.GetAccount(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountResponse(rsp)
}

// GetBalanceForAccountWithResponse request returning *GetBalanceForAccountResponse
func (c *ClientWithResponses) GetBalanceForAccountWithResponse(ctx context.Context, accountId AccountId, params *GetBalanceForAccountParams, reqEditors ...RequestEditorFn) (*GetBalanceForAccountResponse, error) {
	rsp, err := c.GetBalanceForAccount(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBalanceForAccountResponse(rsp)
}

// GetBillingForAccountWithResponse request returning *GetBillingForAccountResponse
func (c *ClientWithResponses) GetBillingForAccountWithResponse(ctx context.Context, accountId AccountId, params *GetBillingForAccountParams, reqEditors ...RequestEditorFn) (*GetBillingForAccountResponse, error) {
	rsp, err := c.GetBillingForAccount(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBillingForAccountResponse(rsp)
}

// GetConcessionsWithResponse request returning *GetConcessionsResponse
func (c *ClientWithResponses) GetConcessionsWithResponse(ctx context.Context, accountId AccountId, params *GetConcessionsParams, reqEditors ...RequestEditorFn) (*GetConcessionsResponse, error) {
	rsp, err := c.GetConcessions(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConcessionsResponse(rsp)
}

// GetInvoicesForAccountWithResponse request returning *GetInvoicesForAccountResponse
func (c *ClientWithResponses) GetInvoicesForAccountWithResponse(ctx context.Context, accountId AccountId, params *GetInvoicesForAccountParams, reqEditors ...RequestEditorFn) (*GetInvoicesForAccountResponse, error) {
	rsp, err := c.GetInvoicesForAccount(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvoicesForAccountResponse(rsp)
}

// GetPaymentScheduleWithResponse request returning *GetPaymentScheduleResponse
func (c *ClientWithResponses) GetPaymentScheduleWithResponse(ctx context.Context, accountId AccountId, params *GetPaymentScheduleParams, reqEditors ...RequestEditorFn) (*GetPaymentScheduleResponse, error) {
	rsp, err := c.GetPaymentSchedule(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentScheduleResponse(rsp)
}

// ListServicePointsWithResponse request returning *ListServicePointsResponse
func (c *ClientWithResponses) ListServicePointsWithResponse(ctx context.Context, params *ListServicePointsParams, reqEditors ...RequestEditorFn) (*ListServicePointsResponse, error) {
	rsp, err := c.ListServicePoints(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServicePointsResponse(rsp)
}

// ListDERBulkWithResponse request returning *ListDERBulkResponse
func (c *ClientWithResponses) ListDERBulkWithResponse(ctx context.Context, params *ListDERBulkParams, reqEditors ...RequestEditorFn) (*ListDERBulkResponse, error) {
	rsp, err := c.ListDERBulk(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDERBulkResponse(rsp)
}

// ListDERForServicePointsWithBodyWithResponse request with arbitrary body returning *ListDERForServicePointsResponse
func (c *ClientWithResponses) ListDERForServicePointsWithBodyWithResponse(ctx context.Context, params *ListDERForServicePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListDERForServicePointsResponse, error) {
	rsp, err := c.ListDERForServicePointsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDERForServicePointsResponse(rsp)
}

func (c *ClientWithResponses) ListDERForServicePointsWithResponse(ctx context.Context, params *ListDERForServicePointsParams, body ListDERForServicePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListDERForServicePointsResponse, error) {
	rsp, err := c.ListDERForServicePoints(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDERForServicePointsResponse(rsp)
}

// ListUsageBulkWithResponse request returning *ListUsageBulkResponse
func (c *ClientWithResponses) ListUsageBulkWithResponse(ctx context.Context, params *ListUsageBulkParams, reqEditors ...RequestEditorFn) (*ListUsageBulkResponse, error) {
	rsp, err := c.ListUsageBulk(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsageBulkResponse(rsp)
}

// ListUsageForServicePointsWithBodyWithResponse request with arbitrary body returning *ListUsageForServicePointsResponse
func (c *ClientWithResponses) ListUsageForServicePointsWithBodyWithResponse(ctx context.Context, params *ListUsageForServicePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListUsageForServicePointsResponse, error) {
	rsp, err := c.ListUsageForServicePointsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsageForServicePointsResponse(rsp)
}

func (c *ClientWithResponses) ListUsageForServicePointsWithResponse(ctx context.Context, params *ListUsageForServicePointsParams, body ListUsageForServicePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListUsageForServicePointsResponse, error) {
	rsp, err := c.ListUsageForServicePoints(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsageForServicePointsResponse(rsp)
}

// GetServicePointWithResponse request returning *GetServicePointResponse
func (c *ClientWithResponses) GetServicePointWithResponse(ctx context.Context, servicePointId ServicePointId, params *GetServicePointParams, reqEditors ...RequestEditorFn) (*GetServicePointResponse, error) {
	rsp, err := c.GetServicePoint(ctx, servicePointId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicePointResponse(rsp)
}

// GetDERForServicePointWithResponse request returning *GetDERForServicePointResponse
func (c *ClientWithResponses) GetDERForServicePointWithResponse(ctx context.Context, servicePointId ServicePointId, params *GetDERForServicePointParams, reqEditors ...RequestEditorFn) (*GetDERForServicePointResponse, error) {
	rsp, err := c.GetDERForServicePoint(ctx, servicePointId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDERForServicePointResponse(rsp)
}

// GetUsageForServicePointWithResponse request returning *GetUsageForServicePointResponse
func (c *ClientWithResponses) GetUsageForServicePointWithResponse(ctx context.Context, servicePointId ServicePointId, params *GetUsageForServicePointParams, reqEditors ...RequestEditorFn) (*GetUsageForServicePointResponse, error) {
	rsp, err := c.GetUsageForServicePoint(ctx, servicePointId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsageForServicePointResponse(rsp)
}

// ListPlansWithResponse request returning *ListPlansResponse
func (c *ClientWithResponses) ListPlansWithResponse(ctx context.Context, params *ListPlansParams, reqEditors ...RequestEditorFn) (*ListPlansResponse, error) {
	rsp, err := c.ListPlans(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPlansResponse(rsp)
}

// GetPlanWithResponse request returning *GetPlanResponse
func (c *ClientWithResponses) GetPlanWithResponse(ctx context.Context, planId string, params *GetPlanParams, reqEditors ...RequestEditorFn) (*GetPlanResponse, error) {
	rsp, err := c.GetPlan(ctx, planId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlanResponse(rsp)
}

// ParseListAccountsResponse parses an HTTP response from a ListAccountsWithResponse call
func ParseListAccountsResponse(rsp *http.Response) (*ListAccountsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyAccountListResponseV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListBalancesBulkResponse parses an HTTP response from a ListBalancesBulkWithResponse call
func ParseListBalancesBulkResponse(rsp *http.Response) (*ListBalancesBulkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBalancesBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyBalanceListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListBalancesForAccountsResponse parses an HTTP response from a ListBalancesForAccountsWithResponse call
func ParseListBalancesForAccountsResponse(rsp *http.Response) (*ListBalancesForAccountsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBalancesForAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyBalanceListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListBillingBulkResponse parses an HTTP response from a ListBillingBulkWithResponse call
func ParseListBillingBulkResponse(rsp *http.Response) (*ListBillingBulkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBillingBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyBillingListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListBillingForAccountsResponse parses an HTTP response from a ListBillingForAccountsWithResponse call
func ParseListBillingForAccountsResponse(rsp *http.Response) (*ListBillingForAccountsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBillingForAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyBillingListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListInvoicesBulkResponse parses an HTTP response from a ListInvoicesBulkWithResponse call
func ParseListInvoicesBulkResponse(rsp *http.Response) (*ListInvoicesBulkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInvoicesBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyInvoiceListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListInvoicesForAccountsResponse parses an HTTP response from a ListInvoicesForAccountsWithResponse call
func ParseListInvoicesForAccountsResponse(rsp *http.Response) (*ListInvoicesForAccountsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInvoicesForAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyInvoiceListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetAccountResponse parses an HTTP response from a GetAccountWithResponse call
func ParseGetAccountResponse(rsp *http.Response) (*GetAccountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyAccountDetailResponseV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetBalanceForAccountResponse parses an HTTP response from a GetBalanceForAccountWithResponse call
func ParseGetBalanceForAccountResponse(rsp *http.Response) (*GetBalanceForAccountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBalanceForAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyBalanceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetBillingForAccountResponse parses an HTTP response from a GetBillingForAccountWithResponse call
func ParseGetBillingForAccountResponse(rsp *http.Response) (*GetBillingForAccountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBillingForAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyBillingListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetConcessionsResponse parses an HTTP response from a GetConcessionsWithResponse call
func ParseGetConcessionsResponse(rsp *http.Response) (*GetConcessionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConcessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyConcessionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetInvoicesForAccountResponse parses an HTTP response from a GetInvoicesForAccountWithResponse call
func ParseGetInvoicesForAccountResponse(rsp *http.Response) (*GetInvoicesForAccountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvoicesForAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyInvoiceListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetPaymentScheduleResponse parses an HTTP response from a GetPaymentScheduleWithResponse call
func ParseGetPaymentScheduleResponse(rsp *http.Response) (*GetPaymentScheduleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyPaymentScheduleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseListServicePointsResponse parses an HTTP response from a ListServicePointsWithResponse call
func ParseListServicePointsResponse(rsp *http.Response) (*ListServicePointsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListServicePointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyServicePointListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListDERBulkResponse parses an HTTP response from a ListDERBulkWithResponse call
func ParseListDERBulkResponse(rsp *http.Response) (*ListDERBulkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDERBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyDerListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListDERForServicePointsResponse parses an HTTP response from a ListDERForServicePointsWithResponse call
func ParseListDERForServicePointsResponse(rsp *http.Response) (*ListDERForServicePointsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDERForServicePointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyDerListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListUsageBulkResponse parses an HTTP response from a ListUsageBulkWithResponse call
func ParseListUsageBulkResponse(rsp *http.Response) (*ListUsageBulkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsageBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyUsageListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListUsageForServicePointsResponse parses an HTTP response from a ListUsageForServicePointsWithResponse call
func ParseListUsageForServicePointsResponse(rsp *http.Response) (*ListUsageForServicePointsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsageForServicePointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyUsageListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetServicePointResponse parses an HTTP response from a GetServicePointWithResponse call
func ParseGetServicePointResponse(rsp *http.Response) (*GetServicePointResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicePointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyServicePointDetailResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetDERForServicePointResponse parses an HTTP response from a GetDERForServicePointWithResponse call
func ParseGetDERForServicePointResponse(rsp *http.Response) (*GetDERForServicePointResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDERForServicePointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyDerDetailResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetUsageForServicePointResponse parses an HTTP response from a GetUsageForServicePointWithResponse call
func ParseGetUsageForServicePointResponse(rsp *http.Response) (*GetUsageForServicePointResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsageForServicePointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyUsageListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListPlansResponse parses an HTTP response from a ListPlansWithResponse call
func ParseListPlansResponse(rsp *http.Response) (*ListPlansResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPlansResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyPlanListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetPlanResponse parses an HTTP response from a GetPlanWithResponse call
func ParseGetPlanResponse(rsp *http.Response) (*GetPlanResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyPlanResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}
