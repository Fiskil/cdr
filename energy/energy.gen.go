// Package energy provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package energy

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for CommonPhysicalAddressAddressUType.
const (
	Paf    CommonPhysicalAddressAddressUType = "paf"
	Simple CommonPhysicalAddressAddressUType = "simple"
)

// Defines values for EnergyAccountBaseV2OpenStatus.
const (
	EnergyAccountBaseV2OpenStatusCLOSED EnergyAccountBaseV2OpenStatus = "CLOSED"
	EnergyAccountBaseV2OpenStatusOPEN   EnergyAccountBaseV2OpenStatus = "OPEN"
)

// Defines values for EnergyAccountDetailV3OpenStatus.
const (
	EnergyAccountDetailV3OpenStatusCLOSED EnergyAccountDetailV3OpenStatus = "CLOSED"
	EnergyAccountDetailV3OpenStatusOPEN   EnergyAccountDetailV3OpenStatus = "OPEN"
)

// Defines values for EnergyAccountDetailV3AllOfPlanDetailFuelType.
const (
	EnergyAccountDetailV3AllOfPlanDetailFuelTypeDUAL        EnergyAccountDetailV3AllOfPlanDetailFuelType = "DUAL"
	EnergyAccountDetailV3AllOfPlanDetailFuelTypeELECTRICITY EnergyAccountDetailV3AllOfPlanDetailFuelType = "ELECTRICITY"
	EnergyAccountDetailV3AllOfPlanDetailFuelTypeGAS         EnergyAccountDetailV3AllOfPlanDetailFuelType = "GAS"
)

// Defines values for EnergyAccountV2OpenStatus.
const (
	EnergyAccountV2OpenStatusCLOSED EnergyAccountV2OpenStatus = "CLOSED"
	EnergyAccountV2OpenStatusOPEN   EnergyAccountV2OpenStatus = "OPEN"
)

// Defines values for EnergyBillingDemandTransactionTimeOfUseType.
const (
	EnergyBillingDemandTransactionTimeOfUseTypeAGGREGATE           EnergyBillingDemandTransactionTimeOfUseType = "AGGREGATE"
	EnergyBillingDemandTransactionTimeOfUseTypeCONTROLLEDLOAD      EnergyBillingDemandTransactionTimeOfUseType = "CONTROLLED_LOAD"
	EnergyBillingDemandTransactionTimeOfUseTypeOFFPEAK             EnergyBillingDemandTransactionTimeOfUseType = "OFF_PEAK"
	EnergyBillingDemandTransactionTimeOfUseTypeOFFPEAKDEMANDCHARGE EnergyBillingDemandTransactionTimeOfUseType = "OFF_PEAK_DEMAND_CHARGE"
	EnergyBillingDemandTransactionTimeOfUseTypePEAK                EnergyBillingDemandTransactionTimeOfUseType = "PEAK"
	EnergyBillingDemandTransactionTimeOfUseTypeSHOULDER            EnergyBillingDemandTransactionTimeOfUseType = "SHOULDER"
	EnergyBillingDemandTransactionTimeOfUseTypeSHOULDER1           EnergyBillingDemandTransactionTimeOfUseType = "SHOULDER1"
	EnergyBillingDemandTransactionTimeOfUseTypeSHOULDER2           EnergyBillingDemandTransactionTimeOfUseType = "SHOULDER2"
	EnergyBillingDemandTransactionTimeOfUseTypeSOLAR               EnergyBillingDemandTransactionTimeOfUseType = "SOLAR"
)

// Defines values for EnergyBillingOtherTransactionType.
const (
	EnergyBillingOtherTransactionTypeENVIRONMENTAL EnergyBillingOtherTransactionType = "ENVIRONMENTAL"
	EnergyBillingOtherTransactionTypeMETERING      EnergyBillingOtherTransactionType = "METERING"
	EnergyBillingOtherTransactionTypeNETWORK       EnergyBillingOtherTransactionType = "NETWORK"
	EnergyBillingOtherTransactionTypeOTHER         EnergyBillingOtherTransactionType = "OTHER"
	EnergyBillingOtherTransactionTypeRCTI          EnergyBillingOtherTransactionType = "RCTI"
	EnergyBillingOtherTransactionTypeREGULATED     EnergyBillingOtherTransactionType = "REGULATED"
	EnergyBillingOtherTransactionTypeRETAILSERVICE EnergyBillingOtherTransactionType = "RETAIL_SERVICE"
)

// Defines values for EnergyBillingPaymentTransactionMethod.
const (
	EnergyBillingPaymentTransactionMethodBPAY        EnergyBillingPaymentTransactionMethod = "BPAY"
	EnergyBillingPaymentTransactionMethodCARD        EnergyBillingPaymentTransactionMethod = "CARD"
	EnergyBillingPaymentTransactionMethodCASH        EnergyBillingPaymentTransactionMethod = "CASH"
	EnergyBillingPaymentTransactionMethodCHEQUE      EnergyBillingPaymentTransactionMethod = "CHEQUE"
	EnergyBillingPaymentTransactionMethodDIRECTDEBIT EnergyBillingPaymentTransactionMethod = "DIRECT_DEBIT"
	EnergyBillingPaymentTransactionMethodOTHER       EnergyBillingPaymentTransactionMethod = "OTHER"
	EnergyBillingPaymentTransactionMethodTRANSFER    EnergyBillingPaymentTransactionMethod = "TRANSFER"
)

// Defines values for EnergyBillingTransactionTransactionUType.
const (
	Demand       EnergyBillingTransactionTransactionUType = "demand"
	OnceOff      EnergyBillingTransactionTransactionUType = "onceOff"
	OtherCharges EnergyBillingTransactionTransactionUType = "otherCharges"
	Payment      EnergyBillingTransactionTransactionUType = "payment"
	Usage        EnergyBillingTransactionTransactionUType = "usage"
)

// Defines values for EnergyBillingUsageTransactionMeasureUnit.
const (
	EnergyBillingUsageTransactionMeasureUnitDAYS  EnergyBillingUsageTransactionMeasureUnit = "DAYS"
	EnergyBillingUsageTransactionMeasureUnitKVA   EnergyBillingUsageTransactionMeasureUnit = "KVA"
	EnergyBillingUsageTransactionMeasureUnitKVAR  EnergyBillingUsageTransactionMeasureUnit = "KVAR"
	EnergyBillingUsageTransactionMeasureUnitKVARH EnergyBillingUsageTransactionMeasureUnit = "KVARH"
	EnergyBillingUsageTransactionMeasureUnitKW    EnergyBillingUsageTransactionMeasureUnit = "KW"
	EnergyBillingUsageTransactionMeasureUnitKWH   EnergyBillingUsageTransactionMeasureUnit = "KWH"
	EnergyBillingUsageTransactionMeasureUnitMETER EnergyBillingUsageTransactionMeasureUnit = "METER"
	EnergyBillingUsageTransactionMeasureUnitMONTH EnergyBillingUsageTransactionMeasureUnit = "MONTH"
)

// Defines values for EnergyBillingUsageTransactionTimeOfUseType.
const (
	EnergyBillingUsageTransactionTimeOfUseTypeAGGREGATE           EnergyBillingUsageTransactionTimeOfUseType = "AGGREGATE"
	EnergyBillingUsageTransactionTimeOfUseTypeCONTROLLEDLOAD      EnergyBillingUsageTransactionTimeOfUseType = "CONTROLLED_LOAD"
	EnergyBillingUsageTransactionTimeOfUseTypeOFFPEAK             EnergyBillingUsageTransactionTimeOfUseType = "OFF_PEAK"
	EnergyBillingUsageTransactionTimeOfUseTypeOFFPEAKDEMANDCHARGE EnergyBillingUsageTransactionTimeOfUseType = "OFF_PEAK_DEMAND_CHARGE"
	EnergyBillingUsageTransactionTimeOfUseTypePEAK                EnergyBillingUsageTransactionTimeOfUseType = "PEAK"
	EnergyBillingUsageTransactionTimeOfUseTypeSHOULDER            EnergyBillingUsageTransactionTimeOfUseType = "SHOULDER"
	EnergyBillingUsageTransactionTimeOfUseTypeSHOULDER1           EnergyBillingUsageTransactionTimeOfUseType = "SHOULDER1"
	EnergyBillingUsageTransactionTimeOfUseTypeSHOULDER2           EnergyBillingUsageTransactionTimeOfUseType = "SHOULDER2"
	EnergyBillingUsageTransactionTimeOfUseTypeSOLAR               EnergyBillingUsageTransactionTimeOfUseType = "SOLAR"
)

// Defines values for EnergyBillingUsageTransactionCalculationFactorsType.
const (
	DLF EnergyBillingUsageTransactionCalculationFactorsType = "DLF"
	MLF EnergyBillingUsageTransactionCalculationFactorsType = "MLF"
)

// Defines values for EnergyConcessionAppliedTo.
const (
	CONTROLLEDLOAD EnergyConcessionAppliedTo = "CONTROLLED_LOAD"
	INVOICE        EnergyConcessionAppliedTo = "INVOICE"
	SERVICECHARGE  EnergyConcessionAppliedTo = "SERVICE_CHARGE"
	USAGE          EnergyConcessionAppliedTo = "USAGE"
)

// Defines values for EnergyConcessionType.
const (
	EnergyConcessionTypeFIXEDAMOUNT     EnergyConcessionType = "FIXED_AMOUNT"
	EnergyConcessionTypeFIXEDPERCENTAGE EnergyConcessionType = "FIXED_PERCENTAGE"
	EnergyConcessionTypeVARIABLE        EnergyConcessionType = "VARIABLE"
)

// Defines values for EnergyDerRecordAcConnectionsEquipmentType.
const (
	EnergyDerRecordAcConnectionsEquipmentTypeINVERTER EnergyDerRecordAcConnectionsEquipmentType = "INVERTER"
	EnergyDerRecordAcConnectionsEquipmentTypeOTHER    EnergyDerRecordAcConnectionsEquipmentType = "OTHER"
)

// Defines values for EnergyDerRecordAcConnectionsStatus.
const (
	EnergyDerRecordAcConnectionsStatusACTIVE         EnergyDerRecordAcConnectionsStatus = "ACTIVE"
	EnergyDerRecordAcConnectionsStatusDECOMMISSIONED EnergyDerRecordAcConnectionsStatus = "DECOMMISSIONED"
	EnergyDerRecordAcConnectionsStatusINACTIVE       EnergyDerRecordAcConnectionsStatus = "INACTIVE"
)

// Defines values for EnergyDerRecordDerDevicesStatus.
const (
	EnergyDerRecordDerDevicesStatusACTIVE         EnergyDerRecordDerDevicesStatus = "ACTIVE"
	EnergyDerRecordDerDevicesStatusDECOMMISSIONED EnergyDerRecordDerDevicesStatus = "DECOMMISSIONED"
	EnergyDerRecordDerDevicesStatusINACTIVE       EnergyDerRecordDerDevicesStatus = "INACTIVE"
)

// Defines values for EnergyDerRecordDerDevicesType.
const (
	EnergyDerRecordDerDevicesTypeFOSSIL     EnergyDerRecordDerDevicesType = "FOSSIL"
	EnergyDerRecordDerDevicesTypeGEOTHERMAL EnergyDerRecordDerDevicesType = "GEOTHERMAL"
	EnergyDerRecordDerDevicesTypeHYDRO      EnergyDerRecordDerDevicesType = "HYDRO"
	EnergyDerRecordDerDevicesTypeOTHER      EnergyDerRecordDerDevicesType = "OTHER"
	EnergyDerRecordDerDevicesTypeRENEWABLE  EnergyDerRecordDerDevicesType = "RENEWABLE"
	EnergyDerRecordDerDevicesTypeSOLARPV    EnergyDerRecordDerDevicesType = "SOLAR_PV"
	EnergyDerRecordDerDevicesTypeSTORAGE    EnergyDerRecordDerDevicesType = "STORAGE"
	EnergyDerRecordDerDevicesTypeWIND       EnergyDerRecordDerDevicesType = "WIND"
)

// Defines values for EnergyInvoicePaymentStatus.
const (
	NOTPAID       EnergyInvoicePaymentStatus = "NOT_PAID"
	PAID          EnergyInvoicePaymentStatus = "PAID"
	PARTIALLYPAID EnergyInvoicePaymentStatus = "PARTIALLY_PAID"
)

// Defines values for EnergyInvoiceGasUsageChargesOtherChargesType.
const (
	EnergyInvoiceGasUsageChargesOtherChargesTypeENVIRONMENTAL EnergyInvoiceGasUsageChargesOtherChargesType = "ENVIRONMENTAL"
	EnergyInvoiceGasUsageChargesOtherChargesTypeMETERING      EnergyInvoiceGasUsageChargesOtherChargesType = "METERING"
	EnergyInvoiceGasUsageChargesOtherChargesTypeNETWORK       EnergyInvoiceGasUsageChargesOtherChargesType = "NETWORK"
	EnergyInvoiceGasUsageChargesOtherChargesTypeOTHER         EnergyInvoiceGasUsageChargesOtherChargesType = "OTHER"
	EnergyInvoiceGasUsageChargesOtherChargesTypeRCTI          EnergyInvoiceGasUsageChargesOtherChargesType = "RCTI"
	EnergyInvoiceGasUsageChargesOtherChargesTypeREGULATED     EnergyInvoiceGasUsageChargesOtherChargesType = "REGULATED"
	EnergyInvoiceGasUsageChargesOtherChargesTypeRETAILSERVICE EnergyInvoiceGasUsageChargesOtherChargesType = "RETAIL_SERVICE"
)

// Defines values for EnergyPaymentSchedulePaymentScheduleUType.
const (
	CardDebit     EnergyPaymentSchedulePaymentScheduleUType = "cardDebit"
	DigitalWallet EnergyPaymentSchedulePaymentScheduleUType = "digitalWallet"
	DirectDebit   EnergyPaymentSchedulePaymentScheduleUType = "directDebit"
	ManualPayment EnergyPaymentSchedulePaymentScheduleUType = "manualPayment"
)

// Defines values for EnergyPaymentScheduleCardDebitCalculationType.
const (
	EnergyPaymentScheduleCardDebitCalculationTypeBALANCE    EnergyPaymentScheduleCardDebitCalculationType = "BALANCE"
	EnergyPaymentScheduleCardDebitCalculationTypeCALCULATED EnergyPaymentScheduleCardDebitCalculationType = "CALCULATED"
	EnergyPaymentScheduleCardDebitCalculationTypeSTATIC     EnergyPaymentScheduleCardDebitCalculationType = "STATIC"
)

// Defines values for EnergyPaymentScheduleCardDebitCardScheme.
const (
	EnergyPaymentScheduleCardDebitCardSchemeAMEX       EnergyPaymentScheduleCardDebitCardScheme = "AMEX"
	EnergyPaymentScheduleCardDebitCardSchemeDINERS     EnergyPaymentScheduleCardDebitCardScheme = "DINERS"
	EnergyPaymentScheduleCardDebitCardSchemeMASTERCARD EnergyPaymentScheduleCardDebitCardScheme = "MASTERCARD"
	EnergyPaymentScheduleCardDebitCardSchemeOTHER      EnergyPaymentScheduleCardDebitCardScheme = "OTHER"
	EnergyPaymentScheduleCardDebitCardSchemeUNKNOWN    EnergyPaymentScheduleCardDebitCardScheme = "UNKNOWN"
	EnergyPaymentScheduleCardDebitCardSchemeVISA       EnergyPaymentScheduleCardDebitCardScheme = "VISA"
)

// Defines values for EnergyPaymentScheduleDigitalWalletCalculationType.
const (
	EnergyPaymentScheduleDigitalWalletCalculationTypeBALANCE    EnergyPaymentScheduleDigitalWalletCalculationType = "BALANCE"
	EnergyPaymentScheduleDigitalWalletCalculationTypeCALCULATED EnergyPaymentScheduleDigitalWalletCalculationType = "CALCULATED"
	EnergyPaymentScheduleDigitalWalletCalculationTypeSTATIC     EnergyPaymentScheduleDigitalWalletCalculationType = "STATIC"
)

// Defines values for EnergyPaymentScheduleDigitalWalletProvider.
const (
	EnergyPaymentScheduleDigitalWalletProviderOTHER    EnergyPaymentScheduleDigitalWalletProvider = "OTHER"
	EnergyPaymentScheduleDigitalWalletProviderPAYPALAU EnergyPaymentScheduleDigitalWalletProvider = "PAYPAL_AU"
)

// Defines values for EnergyPaymentScheduleDigitalWalletType.
const (
	CONTACTNAME EnergyPaymentScheduleDigitalWalletType = "CONTACT_NAME"
	EMAIL       EnergyPaymentScheduleDigitalWalletType = "EMAIL"
	TELEPHONE   EnergyPaymentScheduleDigitalWalletType = "TELEPHONE"
)

// Defines values for EnergyPaymentScheduleDirectDebitCalculationType.
const (
	BALANCE    EnergyPaymentScheduleDirectDebitCalculationType = "BALANCE"
	CALCULATED EnergyPaymentScheduleDirectDebitCalculationType = "CALCULATED"
	STATIC     EnergyPaymentScheduleDirectDebitCalculationType = "STATIC"
)

// Defines values for EnergyPlanCustomerType.
const (
	EnergyPlanCustomerTypeBUSINESS    EnergyPlanCustomerType = "BUSINESS"
	EnergyPlanCustomerTypeRESIDENTIAL EnergyPlanCustomerType = "RESIDENTIAL"
)

// Defines values for EnergyPlanFuelType.
const (
	EnergyPlanFuelTypeDUAL        EnergyPlanFuelType = "DUAL"
	EnergyPlanFuelTypeELECTRICITY EnergyPlanFuelType = "ELECTRICITY"
	EnergyPlanFuelTypeGAS         EnergyPlanFuelType = "GAS"
)

// Defines values for EnergyPlanType.
const (
	EnergyPlanTypeMARKET    EnergyPlanType = "MARKET"
	EnergyPlanTypeREGULATED EnergyPlanType = "REGULATED"
	EnergyPlanTypeSTANDING  EnergyPlanType = "STANDING"
)

// Defines values for EnergyPlanContractFullV2PaymentOption.
const (
	EnergyPlanContractFullV2PaymentOptionBPAY        EnergyPlanContractFullV2PaymentOption = "BPAY"
	EnergyPlanContractFullV2PaymentOptionCREDITCARD  EnergyPlanContractFullV2PaymentOption = "CREDIT_CARD"
	EnergyPlanContractFullV2PaymentOptionDIRECTDEBIT EnergyPlanContractFullV2PaymentOption = "DIRECT_DEBIT"
	EnergyPlanContractFullV2PaymentOptionOTHER       EnergyPlanContractFullV2PaymentOption = "OTHER"
	EnergyPlanContractFullV2PaymentOptionPAPERBILL   EnergyPlanContractFullV2PaymentOption = "PAPER_BILL"
)

// Defines values for EnergyPlanContractFullV2PricingModel.
const (
	EnergyPlanContractFullV2PricingModelFLEXIBLE           EnergyPlanContractFullV2PricingModel = "FLEXIBLE"
	EnergyPlanContractFullV2PricingModelFLEXIBLECONTLOAD   EnergyPlanContractFullV2PricingModel = "FLEXIBLE_CONT_LOAD"
	EnergyPlanContractFullV2PricingModelQUOTA              EnergyPlanContractFullV2PricingModel = "QUOTA"
	EnergyPlanContractFullV2PricingModelSINGLERATE         EnergyPlanContractFullV2PricingModel = "SINGLE_RATE"
	EnergyPlanContractFullV2PricingModelSINGLERATECONTLOAD EnergyPlanContractFullV2PricingModel = "SINGLE_RATE_CONT_LOAD"
	EnergyPlanContractFullV2PricingModelTIMEOFUSE          EnergyPlanContractFullV2PricingModel = "TIME_OF_USE"
	EnergyPlanContractFullV2PricingModelTIMEOFUSECONTLOAD  EnergyPlanContractFullV2PricingModel = "TIME_OF_USE_CONT_LOAD"
)

// Defines values for EnergyPlanContractFullV2TermType.
const (
	EnergyPlanContractFullV2TermTypeN1YEAR  EnergyPlanContractFullV2TermType = "1_YEAR"
	EnergyPlanContractFullV2TermTypeN2YEAR  EnergyPlanContractFullV2TermType = "2_YEAR"
	EnergyPlanContractFullV2TermTypeN3YEAR  EnergyPlanContractFullV2TermType = "3_YEAR"
	EnergyPlanContractFullV2TermTypeN4YEAR  EnergyPlanContractFullV2TermType = "4_YEAR"
	EnergyPlanContractFullV2TermTypeN5YEAR  EnergyPlanContractFullV2TermType = "5_YEAR"
	EnergyPlanContractFullV2TermTypeONGOING EnergyPlanContractFullV2TermType = "ONGOING"
	EnergyPlanContractFullV2TermTypeOTHER   EnergyPlanContractFullV2TermType = "OTHER"
)

// Defines values for EnergyPlanContractFullV2TimeZone.
const (
	EnergyPlanContractFullV2TimeZoneAEST  EnergyPlanContractFullV2TimeZone = "AEST"
	EnergyPlanContractFullV2TimeZoneLOCAL EnergyPlanContractFullV2TimeZone = "LOCAL"
)

// Defines values for EnergyPlanContractFullV2AllOfTermType.
const (
	EnergyPlanContractFullV2AllOfTermTypeN1YEAR  EnergyPlanContractFullV2AllOfTermType = "1_YEAR"
	EnergyPlanContractFullV2AllOfTermTypeN2YEAR  EnergyPlanContractFullV2AllOfTermType = "2_YEAR"
	EnergyPlanContractFullV2AllOfTermTypeN3YEAR  EnergyPlanContractFullV2AllOfTermType = "3_YEAR"
	EnergyPlanContractFullV2AllOfTermTypeN4YEAR  EnergyPlanContractFullV2AllOfTermType = "4_YEAR"
	EnergyPlanContractFullV2AllOfTermTypeN5YEAR  EnergyPlanContractFullV2AllOfTermType = "5_YEAR"
	EnergyPlanContractFullV2AllOfTermTypeONGOING EnergyPlanContractFullV2AllOfTermType = "ONGOING"
	EnergyPlanContractFullV2AllOfTermTypeOTHER   EnergyPlanContractFullV2AllOfTermType = "OTHER"
)

// Defines values for EnergyPlanContractV2PaymentOption.
const (
	EnergyPlanContractV2PaymentOptionBPAY        EnergyPlanContractV2PaymentOption = "BPAY"
	EnergyPlanContractV2PaymentOptionCREDITCARD  EnergyPlanContractV2PaymentOption = "CREDIT_CARD"
	EnergyPlanContractV2PaymentOptionDIRECTDEBIT EnergyPlanContractV2PaymentOption = "DIRECT_DEBIT"
	EnergyPlanContractV2PaymentOptionOTHER       EnergyPlanContractV2PaymentOption = "OTHER"
	EnergyPlanContractV2PaymentOptionPAPERBILL   EnergyPlanContractV2PaymentOption = "PAPER_BILL"
)

// Defines values for EnergyPlanContractV2PricingModel.
const (
	EnergyPlanContractV2PricingModelFLEXIBLE           EnergyPlanContractV2PricingModel = "FLEXIBLE"
	EnergyPlanContractV2PricingModelFLEXIBLECONTLOAD   EnergyPlanContractV2PricingModel = "FLEXIBLE_CONT_LOAD"
	EnergyPlanContractV2PricingModelQUOTA              EnergyPlanContractV2PricingModel = "QUOTA"
	EnergyPlanContractV2PricingModelSINGLERATE         EnergyPlanContractV2PricingModel = "SINGLE_RATE"
	EnergyPlanContractV2PricingModelSINGLERATECONTLOAD EnergyPlanContractV2PricingModel = "SINGLE_RATE_CONT_LOAD"
	EnergyPlanContractV2PricingModelTIMEOFUSE          EnergyPlanContractV2PricingModel = "TIME_OF_USE"
	EnergyPlanContractV2PricingModelTIMEOFUSECONTLOAD  EnergyPlanContractV2PricingModel = "TIME_OF_USE_CONT_LOAD"
)

// Defines values for EnergyPlanContractV2TimeZone.
const (
	EnergyPlanContractV2TimeZoneAEST  EnergyPlanContractV2TimeZone = "AEST"
	EnergyPlanContractV2TimeZoneLOCAL EnergyPlanContractV2TimeZone = "LOCAL"
)

// Defines values for EnergyPlanControlledLoadRateBlockUType.
const (
	EnergyPlanControlledLoadRateBlockUTypeSingleRate     EnergyPlanControlledLoadRateBlockUType = "singleRate"
	EnergyPlanControlledLoadRateBlockUTypeTimeOfUseRates EnergyPlanControlledLoadRateBlockUType = "timeOfUseRates"
)

// Defines values for EnergyPlanControlledLoadSingleRateRatesMeasureUnit.
const (
	EnergyPlanControlledLoadSingleRateRatesMeasureUnitDAYS  EnergyPlanControlledLoadSingleRateRatesMeasureUnit = "DAYS"
	EnergyPlanControlledLoadSingleRateRatesMeasureUnitKVA   EnergyPlanControlledLoadSingleRateRatesMeasureUnit = "KVA"
	EnergyPlanControlledLoadSingleRateRatesMeasureUnitKVAR  EnergyPlanControlledLoadSingleRateRatesMeasureUnit = "KVAR"
	EnergyPlanControlledLoadSingleRateRatesMeasureUnitKVARH EnergyPlanControlledLoadSingleRateRatesMeasureUnit = "KVARH"
	EnergyPlanControlledLoadSingleRateRatesMeasureUnitKW    EnergyPlanControlledLoadSingleRateRatesMeasureUnit = "KW"
	EnergyPlanControlledLoadSingleRateRatesMeasureUnitKWH   EnergyPlanControlledLoadSingleRateRatesMeasureUnit = "KWH"
	EnergyPlanControlledLoadSingleRateRatesMeasureUnitMETER EnergyPlanControlledLoadSingleRateRatesMeasureUnit = "METER"
	EnergyPlanControlledLoadSingleRateRatesMeasureUnitMONTH EnergyPlanControlledLoadSingleRateRatesMeasureUnit = "MONTH"
)

// Defines values for EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnit.
const (
	EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnitDAYS  EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnit = "DAYS"
	EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnitKVA   EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnit = "KVA"
	EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnitKVAR  EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnit = "KVAR"
	EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnitKVARH EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnit = "KVARH"
	EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnitKW    EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnit = "KW"
	EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnitKWH   EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnit = "KWH"
	EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnitMETER EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnit = "METER"
	EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnitMONTH EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnit = "MONTH"
)

// Defines values for EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDays.
const (
	EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDaysFRI            EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDays = "FRI"
	EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDaysMON            EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDays = "MON"
	EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDaysPUBLICHOLIDAYS EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDays = "PUBLIC_HOLIDAYS"
	EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDaysSAT            EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDays = "SAT"
	EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDaysSUN            EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDays = "SUN"
	EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDaysTHU            EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDays = "THU"
	EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDaysTUE            EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDays = "TUE"
	EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDaysWED            EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDays = "WED"
)

// Defines values for EnergyPlanControlledLoadTimeOfUseRatesType.
const (
	EnergyPlanControlledLoadTimeOfUseRatesTypeOFFPEAK     EnergyPlanControlledLoadTimeOfUseRatesType = "OFF_PEAK"
	EnergyPlanControlledLoadTimeOfUseRatesTypePEAK        EnergyPlanControlledLoadTimeOfUseRatesType = "PEAK"
	EnergyPlanControlledLoadTimeOfUseRatesTypeSHOULDER    EnergyPlanControlledLoadTimeOfUseRatesType = "SHOULDER"
	EnergyPlanControlledLoadTimeOfUseRatesTypeSOLARSPONGE EnergyPlanControlledLoadTimeOfUseRatesType = "SOLAR_SPONGE"
)

// Defines values for EnergyPlanDetailV2CustomerType.
const (
	EnergyPlanDetailV2CustomerTypeBUSINESS    EnergyPlanDetailV2CustomerType = "BUSINESS"
	EnergyPlanDetailV2CustomerTypeRESIDENTIAL EnergyPlanDetailV2CustomerType = "RESIDENTIAL"
)

// Defines values for EnergyPlanDetailV2FuelType.
const (
	EnergyPlanDetailV2FuelTypeDUAL        EnergyPlanDetailV2FuelType = "DUAL"
	EnergyPlanDetailV2FuelTypeELECTRICITY EnergyPlanDetailV2FuelType = "ELECTRICITY"
	EnergyPlanDetailV2FuelTypeGAS         EnergyPlanDetailV2FuelType = "GAS"
)

// Defines values for EnergyPlanDetailV2Type.
const (
	EnergyPlanDetailV2TypeMARKET    EnergyPlanDetailV2Type = "MARKET"
	EnergyPlanDetailV2TypeREGULATED EnergyPlanDetailV2Type = "REGULATED"
	EnergyPlanDetailV2TypeSTANDING  EnergyPlanDetailV2Type = "STANDING"
)

// Defines values for EnergyPlanDiscountsCategory.
const (
	EnergyPlanDiscountsCategoryDIRECTDEBIT        EnergyPlanDiscountsCategory = "DIRECT_DEBIT"
	EnergyPlanDiscountsCategoryGUARANTEEDDISCOUNT EnergyPlanDiscountsCategory = "GUARANTEED_DISCOUNT"
	EnergyPlanDiscountsCategoryOTHER              EnergyPlanDiscountsCategory = "OTHER"
	EnergyPlanDiscountsCategoryPAYONTIME          EnergyPlanDiscountsCategory = "PAY_ON_TIME"
)

// Defines values for EnergyPlanDiscountsMethodUType.
const (
	FixedAmount          EnergyPlanDiscountsMethodUType = "fixedAmount"
	PercentOfBill        EnergyPlanDiscountsMethodUType = "percentOfBill"
	PercentOfUse         EnergyPlanDiscountsMethodUType = "percentOfUse"
	PercentOverThreshold EnergyPlanDiscountsMethodUType = "percentOverThreshold"
)

// Defines values for EnergyPlanDiscountsType.
const (
	EnergyPlanDiscountsTypeCONDITIONAL EnergyPlanDiscountsType = "CONDITIONAL"
	EnergyPlanDiscountsTypeGUARANTEED  EnergyPlanDiscountsType = "GUARANTEED"
	EnergyPlanDiscountsTypeOTHER       EnergyPlanDiscountsType = "OTHER"
)

// Defines values for EnergyPlanEligibilityType.
const (
	EnergyPlanEligibilityTypeCONTINGENTPLAN     EnergyPlanEligibilityType = "CONTINGENT_PLAN"
	EnergyPlanEligibilityTypeEXISTINGBASICMETER EnergyPlanEligibilityType = "EXISTING_BASIC_METER"
	EnergyPlanEligibilityTypeEXISTINGBATTERY    EnergyPlanEligibilityType = "EXISTING_BATTERY"
	EnergyPlanEligibilityTypeEXISTINGCUST       EnergyPlanEligibilityType = "EXISTING_CUST"
	EnergyPlanEligibilityTypeEXISTINGPOOL       EnergyPlanEligibilityType = "EXISTING_POOL"
	EnergyPlanEligibilityTypeEXISTINGSMARTMETER EnergyPlanEligibilityType = "EXISTING_SMART_METER"
	EnergyPlanEligibilityTypeEXISTINGSOLAR      EnergyPlanEligibilityType = "EXISTING_SOLAR"
	EnergyPlanEligibilityTypeGROUPBUYMEMBER     EnergyPlanEligibilityType = "GROUP_BUY_MEMBER"
	EnergyPlanEligibilityTypeLOYALTYMEMBER      EnergyPlanEligibilityType = "LOYALTY_MEMBER"
	EnergyPlanEligibilityTypeMINIMUMUSAGE       EnergyPlanEligibilityType = "MINIMUM_USAGE"
	EnergyPlanEligibilityTypeNEWCUSTOMER        EnergyPlanEligibilityType = "NEW_CUSTOMER"
	EnergyPlanEligibilityTypeNOSOLARFIT         EnergyPlanEligibilityType = "NO_SOLAR_FIT"
	EnergyPlanEligibilityTypeONLINEONLY         EnergyPlanEligibilityType = "ONLINE_ONLY"
	EnergyPlanEligibilityTypeORGMEMBER          EnergyPlanEligibilityType = "ORG_MEMBER"
	EnergyPlanEligibilityTypeOTHER              EnergyPlanEligibilityType = "OTHER"
	EnergyPlanEligibilityTypeREQEQUIPSUPPLIER   EnergyPlanEligibilityType = "REQ_EQUIP_SUPPLIER"
	EnergyPlanEligibilityTypeSENIORCARD         EnergyPlanEligibilityType = "SENIOR_CARD"
	EnergyPlanEligibilityTypeSMALLBUSINESS      EnergyPlanEligibilityType = "SMALL_BUSINESS"
	EnergyPlanEligibilityTypeSPECIFICLOCATION   EnergyPlanEligibilityType = "SPECIFIC_LOCATION"
	EnergyPlanEligibilityTypeSPORTCLUBMEMBER    EnergyPlanEligibilityType = "SPORT_CLUB_MEMBER"
	EnergyPlanEligibilityTypeTHIRDPARTYONLY     EnergyPlanEligibilityType = "THIRD_PARTY_ONLY"
)

// Defines values for EnergyPlanFeesTerm.
const (
	EnergyPlanFeesTermANNUAL        EnergyPlanFeesTerm = "ANNUAL"
	EnergyPlanFeesTermBIANNUAL      EnergyPlanFeesTerm = "BIANNUAL"
	EnergyPlanFeesTermDAILY         EnergyPlanFeesTerm = "DAILY"
	EnergyPlanFeesTermFIXED         EnergyPlanFeesTerm = "FIXED"
	EnergyPlanFeesTermMONTHLY       EnergyPlanFeesTerm = "MONTHLY"
	EnergyPlanFeesTermN1YEAR        EnergyPlanFeesTerm = "1_YEAR"
	EnergyPlanFeesTermN2YEAR        EnergyPlanFeesTerm = "2_YEAR"
	EnergyPlanFeesTermN3YEAR        EnergyPlanFeesTerm = "3_YEAR"
	EnergyPlanFeesTermN4YEAR        EnergyPlanFeesTerm = "4_YEAR"
	EnergyPlanFeesTermN5YEAR        EnergyPlanFeesTerm = "5_YEAR"
	EnergyPlanFeesTermPERCENTOFBILL EnergyPlanFeesTerm = "PERCENT_OF_BILL"
	EnergyPlanFeesTermVARIABLE      EnergyPlanFeesTerm = "VARIABLE"
	EnergyPlanFeesTermWEEKLY        EnergyPlanFeesTerm = "WEEKLY"
)

// Defines values for EnergyPlanFeesType.
const (
	EnergyPlanFeesTypeCCPROCESSING      EnergyPlanFeesType = "CC_PROCESSING"
	EnergyPlanFeesTypeCHEQUEDISHONOUR   EnergyPlanFeesType = "CHEQUE_DISHONOUR"
	EnergyPlanFeesTypeCONNECTION        EnergyPlanFeesType = "CONNECTION"
	EnergyPlanFeesTypeCONTRIBUTION      EnergyPlanFeesType = "CONTRIBUTION"
	EnergyPlanFeesTypeDDDISHONOUR       EnergyPlanFeesType = "DD_DISHONOUR"
	EnergyPlanFeesTypeDISCONNECTION     EnergyPlanFeesType = "DISCONNECTION"
	EnergyPlanFeesTypeDISCONNECTMOVEOUT EnergyPlanFeesType = "DISCONNECT_MOVE_OUT"
	EnergyPlanFeesTypeDISCONNECTNONPAY  EnergyPlanFeesType = "DISCONNECT_NON_PAY"
	EnergyPlanFeesTypeESTABLISHMENT     EnergyPlanFeesType = "ESTABLISHMENT"
	EnergyPlanFeesTypeEXIT              EnergyPlanFeesType = "EXIT"
	EnergyPlanFeesTypeLATEPAYMENT       EnergyPlanFeesType = "LATE_PAYMENT"
	EnergyPlanFeesTypeMEMBERSHIP        EnergyPlanFeesType = "MEMBERSHIP"
	EnergyPlanFeesTypeOTHER             EnergyPlanFeesType = "OTHER"
	EnergyPlanFeesTypePAPERBILL         EnergyPlanFeesType = "PAPER_BILL"
	EnergyPlanFeesTypePAYMENTPROCESSING EnergyPlanFeesType = "PAYMENT_PROCESSING"
	EnergyPlanFeesTypeRECONNECTION      EnergyPlanFeesType = "RECONNECTION"
)

// Defines values for EnergyPlanGreenPowerChargesScheme.
const (
	EnergyPlanGreenPowerChargesSchemeGREENPOWER EnergyPlanGreenPowerChargesScheme = "GREENPOWER"
	EnergyPlanGreenPowerChargesSchemeOTHER      EnergyPlanGreenPowerChargesScheme = "OTHER"
)

// Defines values for EnergyPlanGreenPowerChargesType.
const (
	FIXEDPERDAY   EnergyPlanGreenPowerChargesType = "FIXED_PER_DAY"
	FIXEDPERMONTH EnergyPlanGreenPowerChargesType = "FIXED_PER_MONTH"
	FIXEDPERUNIT  EnergyPlanGreenPowerChargesType = "FIXED_PER_UNIT"
	FIXEDPERWEEK  EnergyPlanGreenPowerChargesType = "FIXED_PER_WEEK"
	PERCENTOFBILL EnergyPlanGreenPowerChargesType = "PERCENT_OF_BILL"
	PERCENTOFUSE  EnergyPlanGreenPowerChargesType = "PERCENT_OF_USE"
)

// Defines values for EnergyPlanIncentivesCategory.
const (
	EnergyPlanIncentivesCategoryACCOUNTCREDIT EnergyPlanIncentivesCategory = "ACCOUNT_CREDIT"
	EnergyPlanIncentivesCategoryGIFT          EnergyPlanIncentivesCategory = "GIFT"
	EnergyPlanIncentivesCategoryOTHER         EnergyPlanIncentivesCategory = "OTHER"
)

// Defines values for EnergyPlanSolarFeedInTariffV2PayerType.
const (
	GOVERNMENT EnergyPlanSolarFeedInTariffV2PayerType = "GOVERNMENT"
	RETAILER   EnergyPlanSolarFeedInTariffV2PayerType = "RETAILER"
)

// Defines values for EnergyPlanSolarFeedInTariffV2Scheme.
const (
	EnergyPlanSolarFeedInTariffV2SchemeOTHER   EnergyPlanSolarFeedInTariffV2Scheme = "OTHER"
	EnergyPlanSolarFeedInTariffV2SchemePREMIUM EnergyPlanSolarFeedInTariffV2Scheme = "PREMIUM"
)

// Defines values for EnergyPlanSolarFeedInTariffV2SingleTariffRatesMeasureUnit.
const (
	EnergyPlanSolarFeedInTariffV2SingleTariffRatesMeasureUnitDAYS  EnergyPlanSolarFeedInTariffV2SingleTariffRatesMeasureUnit = "DAYS"
	EnergyPlanSolarFeedInTariffV2SingleTariffRatesMeasureUnitKVA   EnergyPlanSolarFeedInTariffV2SingleTariffRatesMeasureUnit = "KVA"
	EnergyPlanSolarFeedInTariffV2SingleTariffRatesMeasureUnitKVAR  EnergyPlanSolarFeedInTariffV2SingleTariffRatesMeasureUnit = "KVAR"
	EnergyPlanSolarFeedInTariffV2SingleTariffRatesMeasureUnitKVARH EnergyPlanSolarFeedInTariffV2SingleTariffRatesMeasureUnit = "KVARH"
	EnergyPlanSolarFeedInTariffV2SingleTariffRatesMeasureUnitKW    EnergyPlanSolarFeedInTariffV2SingleTariffRatesMeasureUnit = "KW"
	EnergyPlanSolarFeedInTariffV2SingleTariffRatesMeasureUnitKWH   EnergyPlanSolarFeedInTariffV2SingleTariffRatesMeasureUnit = "KWH"
	EnergyPlanSolarFeedInTariffV2SingleTariffRatesMeasureUnitMETER EnergyPlanSolarFeedInTariffV2SingleTariffRatesMeasureUnit = "METER"
	EnergyPlanSolarFeedInTariffV2SingleTariffRatesMeasureUnitMONTH EnergyPlanSolarFeedInTariffV2SingleTariffRatesMeasureUnit = "MONTH"
)

// Defines values for EnergyPlanSolarFeedInTariffV2TariffUType.
const (
	SingleTariff       EnergyPlanSolarFeedInTariffV2TariffUType = "singleTariff"
	TimeVaryingTariffs EnergyPlanSolarFeedInTariffV2TariffUType = "timeVaryingTariffs"
)

// Defines values for EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsRatesMeasureUnit.
const (
	EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsRatesMeasureUnitDAYS  EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsRatesMeasureUnit = "DAYS"
	EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsRatesMeasureUnitKVA   EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsRatesMeasureUnit = "KVA"
	EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsRatesMeasureUnitKVAR  EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsRatesMeasureUnit = "KVAR"
	EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsRatesMeasureUnitKVARH EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsRatesMeasureUnit = "KVARH"
	EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsRatesMeasureUnitKW    EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsRatesMeasureUnit = "KW"
	EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsRatesMeasureUnitKWH   EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsRatesMeasureUnit = "KWH"
	EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsRatesMeasureUnitMETER EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsRatesMeasureUnit = "METER"
	EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsRatesMeasureUnitMONTH EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsRatesMeasureUnit = "MONTH"
)

// Defines values for EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsTimeVariationsDays.
const (
	EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsTimeVariationsDaysFRI            EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsTimeVariationsDays = "FRI"
	EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsTimeVariationsDaysMON            EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsTimeVariationsDays = "MON"
	EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsTimeVariationsDaysPUBLICHOLIDAYS EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsTimeVariationsDays = "PUBLIC_HOLIDAYS"
	EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsTimeVariationsDaysSAT            EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsTimeVariationsDays = "SAT"
	EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsTimeVariationsDaysSUN            EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsTimeVariationsDays = "SUN"
	EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsTimeVariationsDaysTHU            EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsTimeVariationsDays = "THU"
	EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsTimeVariationsDaysTUE            EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsTimeVariationsDays = "TUE"
	EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsTimeVariationsDaysWED            EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsTimeVariationsDays = "WED"
)

// Defines values for EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsType.
const (
	EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsTypeOFFPEAK  EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsType = "OFF_PEAK"
	EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsTypePEAK     EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsType = "PEAK"
	EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsTypeSHOULDER EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsType = "SHOULDER"
)

// Defines values for EnergyPlanTariffPeriodDemandChargesChargePeriod.
const (
	EnergyPlanTariffPeriodDemandChargesChargePeriodDAY          EnergyPlanTariffPeriodDemandChargesChargePeriod = "DAY"
	EnergyPlanTariffPeriodDemandChargesChargePeriodMONTH        EnergyPlanTariffPeriodDemandChargesChargePeriod = "MONTH"
	EnergyPlanTariffPeriodDemandChargesChargePeriodTARIFFPERIOD EnergyPlanTariffPeriodDemandChargesChargePeriod = "TARIFF_PERIOD"
)

// Defines values for EnergyPlanTariffPeriodDemandChargesDays.
const (
	EnergyPlanTariffPeriodDemandChargesDaysFRI            EnergyPlanTariffPeriodDemandChargesDays = "FRI"
	EnergyPlanTariffPeriodDemandChargesDaysMON            EnergyPlanTariffPeriodDemandChargesDays = "MON"
	EnergyPlanTariffPeriodDemandChargesDaysPUBLICHOLIDAYS EnergyPlanTariffPeriodDemandChargesDays = "PUBLIC_HOLIDAYS"
	EnergyPlanTariffPeriodDemandChargesDaysSAT            EnergyPlanTariffPeriodDemandChargesDays = "SAT"
	EnergyPlanTariffPeriodDemandChargesDaysSUN            EnergyPlanTariffPeriodDemandChargesDays = "SUN"
	EnergyPlanTariffPeriodDemandChargesDaysTHU            EnergyPlanTariffPeriodDemandChargesDays = "THU"
	EnergyPlanTariffPeriodDemandChargesDaysTUE            EnergyPlanTariffPeriodDemandChargesDays = "TUE"
	EnergyPlanTariffPeriodDemandChargesDaysWED            EnergyPlanTariffPeriodDemandChargesDays = "WED"
)

// Defines values for EnergyPlanTariffPeriodDemandChargesMeasureUnit.
const (
	EnergyPlanTariffPeriodDemandChargesMeasureUnitDAYS  EnergyPlanTariffPeriodDemandChargesMeasureUnit = "DAYS"
	EnergyPlanTariffPeriodDemandChargesMeasureUnitKVA   EnergyPlanTariffPeriodDemandChargesMeasureUnit = "KVA"
	EnergyPlanTariffPeriodDemandChargesMeasureUnitKVAR  EnergyPlanTariffPeriodDemandChargesMeasureUnit = "KVAR"
	EnergyPlanTariffPeriodDemandChargesMeasureUnitKVARH EnergyPlanTariffPeriodDemandChargesMeasureUnit = "KVARH"
	EnergyPlanTariffPeriodDemandChargesMeasureUnitKW    EnergyPlanTariffPeriodDemandChargesMeasureUnit = "KW"
	EnergyPlanTariffPeriodDemandChargesMeasureUnitKWH   EnergyPlanTariffPeriodDemandChargesMeasureUnit = "KWH"
	EnergyPlanTariffPeriodDemandChargesMeasureUnitMETER EnergyPlanTariffPeriodDemandChargesMeasureUnit = "METER"
	EnergyPlanTariffPeriodDemandChargesMeasureUnitMONTH EnergyPlanTariffPeriodDemandChargesMeasureUnit = "MONTH"
)

// Defines values for EnergyPlanTariffPeriodDemandChargesMeasurementPeriod.
const (
	EnergyPlanTariffPeriodDemandChargesMeasurementPeriodDAY          EnergyPlanTariffPeriodDemandChargesMeasurementPeriod = "DAY"
	EnergyPlanTariffPeriodDemandChargesMeasurementPeriodMONTH        EnergyPlanTariffPeriodDemandChargesMeasurementPeriod = "MONTH"
	EnergyPlanTariffPeriodDemandChargesMeasurementPeriodTARIFFPERIOD EnergyPlanTariffPeriodDemandChargesMeasurementPeriod = "TARIFF_PERIOD"
)

// Defines values for EnergyPlanTariffPeriodRateBlockUType.
const (
	EnergyPlanTariffPeriodRateBlockUTypeDemandCharges  EnergyPlanTariffPeriodRateBlockUType = "demandCharges"
	EnergyPlanTariffPeriodRateBlockUTypeSingleRate     EnergyPlanTariffPeriodRateBlockUType = "singleRate"
	EnergyPlanTariffPeriodRateBlockUTypeTimeOfUseRates EnergyPlanTariffPeriodRateBlockUType = "timeOfUseRates"
)

// Defines values for EnergyPlanTariffPeriodSingleRateRatesMeasureUnit.
const (
	EnergyPlanTariffPeriodSingleRateRatesMeasureUnitDAYS  EnergyPlanTariffPeriodSingleRateRatesMeasureUnit = "DAYS"
	EnergyPlanTariffPeriodSingleRateRatesMeasureUnitKVA   EnergyPlanTariffPeriodSingleRateRatesMeasureUnit = "KVA"
	EnergyPlanTariffPeriodSingleRateRatesMeasureUnitKVAR  EnergyPlanTariffPeriodSingleRateRatesMeasureUnit = "KVAR"
	EnergyPlanTariffPeriodSingleRateRatesMeasureUnitKVARH EnergyPlanTariffPeriodSingleRateRatesMeasureUnit = "KVARH"
	EnergyPlanTariffPeriodSingleRateRatesMeasureUnitKW    EnergyPlanTariffPeriodSingleRateRatesMeasureUnit = "KW"
	EnergyPlanTariffPeriodSingleRateRatesMeasureUnitKWH   EnergyPlanTariffPeriodSingleRateRatesMeasureUnit = "KWH"
	EnergyPlanTariffPeriodSingleRateRatesMeasureUnitMETER EnergyPlanTariffPeriodSingleRateRatesMeasureUnit = "METER"
	EnergyPlanTariffPeriodSingleRateRatesMeasureUnitMONTH EnergyPlanTariffPeriodSingleRateRatesMeasureUnit = "MONTH"
)

// Defines values for EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnit.
const (
	EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnitDAYS  EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnit = "DAYS"
	EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnitKVA   EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnit = "KVA"
	EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnitKVAR  EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnit = "KVAR"
	EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnitKVARH EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnit = "KVARH"
	EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnitKW    EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnit = "KW"
	EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnitKWH   EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnit = "KWH"
	EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnitMETER EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnit = "METER"
	EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnitMONTH EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnit = "MONTH"
)

// Defines values for EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDays.
const (
	EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDaysFRI            EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDays = "FRI"
	EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDaysMON            EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDays = "MON"
	EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDaysPUBLICHOLIDAYS EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDays = "PUBLIC_HOLIDAYS"
	EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDaysSAT            EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDays = "SAT"
	EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDaysSUN            EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDays = "SUN"
	EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDaysTHU            EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDays = "THU"
	EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDaysTUE            EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDays = "TUE"
	EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDaysWED            EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDays = "WED"
)

// Defines values for EnergyPlanTariffPeriodTimeOfUseRatesType.
const (
	EnergyPlanTariffPeriodTimeOfUseRatesTypeOFFPEAK   EnergyPlanTariffPeriodTimeOfUseRatesType = "OFF_PEAK"
	EnergyPlanTariffPeriodTimeOfUseRatesTypePEAK      EnergyPlanTariffPeriodTimeOfUseRatesType = "PEAK"
	EnergyPlanTariffPeriodTimeOfUseRatesTypeSHOULDER  EnergyPlanTariffPeriodTimeOfUseRatesType = "SHOULDER"
	EnergyPlanTariffPeriodTimeOfUseRatesTypeSHOULDER1 EnergyPlanTariffPeriodTimeOfUseRatesType = "SHOULDER1"
	EnergyPlanTariffPeriodTimeOfUseRatesTypeSHOULDER2 EnergyPlanTariffPeriodTimeOfUseRatesType = "SHOULDER2"
)

// Defines values for EnergyPlanTariffPeriodTimeZone.
const (
	AEST  EnergyPlanTariffPeriodTimeZone = "AEST"
	LOCAL EnergyPlanTariffPeriodTimeZone = "LOCAL"
)

// Defines values for EnergyPlanTariffPeriodType.
const (
	EnergyPlanTariffPeriodTypeENVIRONMENTAL EnergyPlanTariffPeriodType = "ENVIRONMENTAL"
	EnergyPlanTariffPeriodTypeMETERING      EnergyPlanTariffPeriodType = "METERING"
	EnergyPlanTariffPeriodTypeNETWORK       EnergyPlanTariffPeriodType = "NETWORK"
	EnergyPlanTariffPeriodTypeOTHER         EnergyPlanTariffPeriodType = "OTHER"
	EnergyPlanTariffPeriodTypeRCTI          EnergyPlanTariffPeriodType = "RCTI"
	EnergyPlanTariffPeriodTypeREGULATED     EnergyPlanTariffPeriodType = "REGULATED"
	EnergyPlanTariffPeriodTypeRETAILSERVICE EnergyPlanTariffPeriodType = "RETAIL_SERVICE"
)

// Defines values for EnergyServicePointJurisdictionCode.
const (
	EnergyServicePointJurisdictionCodeACT EnergyServicePointJurisdictionCode = "ACT"
	EnergyServicePointJurisdictionCodeALL EnergyServicePointJurisdictionCode = "ALL"
	EnergyServicePointJurisdictionCodeNEM EnergyServicePointJurisdictionCode = "NEM"
	EnergyServicePointJurisdictionCodeNSW EnergyServicePointJurisdictionCode = "NSW"
	EnergyServicePointJurisdictionCodeQLD EnergyServicePointJurisdictionCode = "QLD"
	EnergyServicePointJurisdictionCodeSA  EnergyServicePointJurisdictionCode = "SA"
	EnergyServicePointJurisdictionCodeTAS EnergyServicePointJurisdictionCode = "TAS"
	EnergyServicePointJurisdictionCodeVIC EnergyServicePointJurisdictionCode = "VIC"
)

// Defines values for EnergyServicePointServicePointClassification.
const (
	EnergyServicePointServicePointClassificationDISTRIBUTIONWHOLESALE          EnergyServicePointServicePointClassification = "DISTRIBUTION_WHOLESALE"
	EnergyServicePointServicePointClassificationEXTERNALPROFILE                EnergyServicePointServicePointClassification = "EXTERNAL_PROFILE"
	EnergyServicePointServicePointClassificationGENERATOR                      EnergyServicePointServicePointClassification = "GENERATOR"
	EnergyServicePointServicePointClassificationLARGE                          EnergyServicePointServicePointClassification = "LARGE"
	EnergyServicePointServicePointClassificationNONCONTESTUNMETEREDLOAD        EnergyServicePointServicePointClassification = "NON_CONTEST_UNMETERED_LOAD"
	EnergyServicePointServicePointClassificationNONREGISTEREDEMBEDDEDGENERATOR EnergyServicePointServicePointClassification = "NON_REGISTERED_EMBEDDED_GENERATOR"
	EnergyServicePointServicePointClassificationSMALL                          EnergyServicePointServicePointClassification = "SMALL"
	EnergyServicePointServicePointClassificationWHOLESALE                      EnergyServicePointServicePointClassification = "WHOLESALE"
)

// Defines values for EnergyServicePointServicePointStatus.
const (
	EnergyServicePointServicePointStatusACTIVE      EnergyServicePointServicePointStatus = "ACTIVE"
	EnergyServicePointServicePointStatusDEENERGISED EnergyServicePointServicePointStatus = "DE_ENERGISED"
	EnergyServicePointServicePointStatusEXTINCT     EnergyServicePointServicePointStatus = "EXTINCT"
	EnergyServicePointServicePointStatusGREENFIELD  EnergyServicePointServicePointStatus = "GREENFIELD"
	EnergyServicePointServicePointStatusOFFMARKET   EnergyServicePointServicePointStatus = "OFF_MARKET"
)

// Defines values for EnergyServicePointDetailJurisdictionCode.
const (
	EnergyServicePointDetailJurisdictionCodeACT EnergyServicePointDetailJurisdictionCode = "ACT"
	EnergyServicePointDetailJurisdictionCodeALL EnergyServicePointDetailJurisdictionCode = "ALL"
	EnergyServicePointDetailJurisdictionCodeNEM EnergyServicePointDetailJurisdictionCode = "NEM"
	EnergyServicePointDetailJurisdictionCodeNSW EnergyServicePointDetailJurisdictionCode = "NSW"
	EnergyServicePointDetailJurisdictionCodeQLD EnergyServicePointDetailJurisdictionCode = "QLD"
	EnergyServicePointDetailJurisdictionCodeSA  EnergyServicePointDetailJurisdictionCode = "SA"
	EnergyServicePointDetailJurisdictionCodeTAS EnergyServicePointDetailJurisdictionCode = "TAS"
	EnergyServicePointDetailJurisdictionCodeVIC EnergyServicePointDetailJurisdictionCode = "VIC"
)

// Defines values for EnergyServicePointDetailServicePointClassification.
const (
	EnergyServicePointDetailServicePointClassificationDISTRIBUTIONWHOLESALE          EnergyServicePointDetailServicePointClassification = "DISTRIBUTION_WHOLESALE"
	EnergyServicePointDetailServicePointClassificationEXTERNALPROFILE                EnergyServicePointDetailServicePointClassification = "EXTERNAL_PROFILE"
	EnergyServicePointDetailServicePointClassificationGENERATOR                      EnergyServicePointDetailServicePointClassification = "GENERATOR"
	EnergyServicePointDetailServicePointClassificationLARGE                          EnergyServicePointDetailServicePointClassification = "LARGE"
	EnergyServicePointDetailServicePointClassificationNONCONTESTUNMETEREDLOAD        EnergyServicePointDetailServicePointClassification = "NON_CONTEST_UNMETERED_LOAD"
	EnergyServicePointDetailServicePointClassificationNONREGISTEREDEMBEDDEDGENERATOR EnergyServicePointDetailServicePointClassification = "NON_REGISTERED_EMBEDDED_GENERATOR"
	EnergyServicePointDetailServicePointClassificationSMALL                          EnergyServicePointDetailServicePointClassification = "SMALL"
	EnergyServicePointDetailServicePointClassificationWHOLESALE                      EnergyServicePointDetailServicePointClassification = "WHOLESALE"
)

// Defines values for EnergyServicePointDetailServicePointStatus.
const (
	EnergyServicePointDetailServicePointStatusACTIVE      EnergyServicePointDetailServicePointStatus = "ACTIVE"
	EnergyServicePointDetailServicePointStatusDEENERGISED EnergyServicePointDetailServicePointStatus = "DE_ENERGISED"
	EnergyServicePointDetailServicePointStatusEXTINCT     EnergyServicePointDetailServicePointStatus = "EXTINCT"
	EnergyServicePointDetailServicePointStatusGREENFIELD  EnergyServicePointDetailServicePointStatus = "GREENFIELD"
	EnergyServicePointDetailServicePointStatusOFFMARKET   EnergyServicePointDetailServicePointStatus = "OFF_MARKET"
)

// Defines values for EnergyServicePointDetailRegistersConsumptionType.
const (
	EnergyServicePointDetailRegistersConsumptionTypeACTUAL     EnergyServicePointDetailRegistersConsumptionType = "ACTUAL"
	EnergyServicePointDetailRegistersConsumptionTypeCUMULATIVE EnergyServicePointDetailRegistersConsumptionType = "CUMULATIVE"
)

// Defines values for EnergyServicePointDetailRegistersRegisterConsumptionType.
const (
	EnergyServicePointDetailRegistersRegisterConsumptionTypeACTIVE         EnergyServicePointDetailRegistersRegisterConsumptionType = "ACTIVE"
	EnergyServicePointDetailRegistersRegisterConsumptionTypeACTIVEIMPORT   EnergyServicePointDetailRegistersRegisterConsumptionType = "ACTIVE_IMPORT"
	EnergyServicePointDetailRegistersRegisterConsumptionTypeBASIC          EnergyServicePointDetailRegistersRegisterConsumptionType = "BASIC"
	EnergyServicePointDetailRegistersRegisterConsumptionTypeINTERVAL       EnergyServicePointDetailRegistersRegisterConsumptionType = "INTERVAL"
	EnergyServicePointDetailRegistersRegisterConsumptionTypePROFILEDATA    EnergyServicePointDetailRegistersRegisterConsumptionType = "PROFILE_DATA"
	EnergyServicePointDetailRegistersRegisterConsumptionTypeREACTIVE       EnergyServicePointDetailRegistersRegisterConsumptionType = "REACTIVE"
	EnergyServicePointDetailRegistersRegisterConsumptionTypeREACTIVEIMPORT EnergyServicePointDetailRegistersRegisterConsumptionType = "REACTIVE_IMPORT"
)

// Defines values for EnergyServicePointDetailRegistersTimeOfDay.
const (
	EnergyServicePointDetailRegistersTimeOfDayALLDAY     EnergyServicePointDetailRegistersTimeOfDay = "ALLDAY"
	EnergyServicePointDetailRegistersTimeOfDayBUSINESS   EnergyServicePointDetailRegistersTimeOfDay = "BUSINESS"
	EnergyServicePointDetailRegistersTimeOfDayCONTROLLED EnergyServicePointDetailRegistersTimeOfDay = "CONTROLLED"
	EnergyServicePointDetailRegistersTimeOfDayDEMAND     EnergyServicePointDetailRegistersTimeOfDay = "DEMAND"
	EnergyServicePointDetailRegistersTimeOfDayEVENING    EnergyServicePointDetailRegistersTimeOfDay = "EVENING"
	EnergyServicePointDetailRegistersTimeOfDayINTERVAL   EnergyServicePointDetailRegistersTimeOfDay = "INTERVAL"
	EnergyServicePointDetailRegistersTimeOfDayOFFPEAK    EnergyServicePointDetailRegistersTimeOfDay = "OFFPEAK"
	EnergyServicePointDetailRegistersTimeOfDayPEAK       EnergyServicePointDetailRegistersTimeOfDay = "PEAK"
	EnergyServicePointDetailRegistersTimeOfDaySHOULDER   EnergyServicePointDetailRegistersTimeOfDay = "SHOULDER"
)

// Defines values for EnergyServicePointDetailRelatedParticipantsRole.
const (
	DRSP EnergyServicePointDetailRelatedParticipantsRole = "DRSP"
	FRMP EnergyServicePointDetailRelatedParticipantsRole = "FRMP"
	LNSP EnergyServicePointDetailRelatedParticipantsRole = "LNSP"
)

// Defines values for EnergyServicePointDetailSpecificationsInstallationType.
const (
	EnergyServicePointDetailSpecificationsInstallationTypeBASIC    EnergyServicePointDetailSpecificationsInstallationType = "BASIC"
	EnergyServicePointDetailSpecificationsInstallationTypeCOMMS1   EnergyServicePointDetailSpecificationsInstallationType = "COMMS1"
	EnergyServicePointDetailSpecificationsInstallationTypeCOMMS2   EnergyServicePointDetailSpecificationsInstallationType = "COMMS2"
	EnergyServicePointDetailSpecificationsInstallationTypeCOMMS3   EnergyServicePointDetailSpecificationsInstallationType = "COMMS3"
	EnergyServicePointDetailSpecificationsInstallationTypeCOMMS4   EnergyServicePointDetailSpecificationsInstallationType = "COMMS4"
	EnergyServicePointDetailSpecificationsInstallationTypeCOMMS4C  EnergyServicePointDetailSpecificationsInstallationType = "COMMS4C"
	EnergyServicePointDetailSpecificationsInstallationTypeCOMMS4D  EnergyServicePointDetailSpecificationsInstallationType = "COMMS4D"
	EnergyServicePointDetailSpecificationsInstallationTypeMRAM     EnergyServicePointDetailSpecificationsInstallationType = "MRAM"
	EnergyServicePointDetailSpecificationsInstallationTypeMRIM     EnergyServicePointDetailSpecificationsInstallationType = "MRIM"
	EnergyServicePointDetailSpecificationsInstallationTypeNCOLNUML EnergyServicePointDetailSpecificationsInstallationType = "NCOLNUML"
	EnergyServicePointDetailSpecificationsInstallationTypePROF     EnergyServicePointDetailSpecificationsInstallationType = "PROF"
	EnergyServicePointDetailSpecificationsInstallationTypeSAMPLE   EnergyServicePointDetailSpecificationsInstallationType = "SAMPLE"
	EnergyServicePointDetailSpecificationsInstallationTypeUMCP     EnergyServicePointDetailSpecificationsInstallationType = "UMCP"
	EnergyServicePointDetailSpecificationsInstallationTypeVICAMI   EnergyServicePointDetailSpecificationsInstallationType = "VICAMI"
)

// Defines values for EnergyServicePointDetailSpecificationsStatus.
const (
	EnergyServicePointDetailSpecificationsStatusCURRENT      EnergyServicePointDetailSpecificationsStatus = "CURRENT"
	EnergyServicePointDetailSpecificationsStatusDISCONNECTED EnergyServicePointDetailSpecificationsStatus = "DISCONNECTED"
)

// Defines values for EnergyServicePointConsumerProfileClassification.
const (
	BUSINESS    EnergyServicePointConsumerProfileClassification = "BUSINESS"
	RESIDENTIAL EnergyServicePointConsumerProfileClassification = "RESIDENTIAL"
)

// Defines values for EnergyServicePointConsumerProfileThreshold.
const (
	HIGH   EnergyServicePointConsumerProfileThreshold = "HIGH"
	LOW    EnergyServicePointConsumerProfileThreshold = "LOW"
	MEDIUM EnergyServicePointConsumerProfileThreshold = "MEDIUM"
)

// Defines values for EnergyUsageReadReadUType.
const (
	BasicRead    EnergyUsageReadReadUType = "basicRead"
	IntervalRead EnergyUsageReadReadUType = "intervalRead"
)

// Defines values for EnergyUsageReadBasicReadQuality.
const (
	EnergyUsageReadBasicReadQualityACTUAL          EnergyUsageReadBasicReadQuality = "ACTUAL"
	EnergyUsageReadBasicReadQualityFINALSUBSTITUTE EnergyUsageReadBasicReadQuality = "FINAL_SUBSTITUTE"
	EnergyUsageReadBasicReadQualitySUBSTITUTE      EnergyUsageReadBasicReadQuality = "SUBSTITUTE"
)

// Defines values for EnergyUsageReadIntervalReadReadQualitiesQuality.
const (
	FINALSUBSTITUTE EnergyUsageReadIntervalReadReadQualitiesQuality = "FINAL_SUBSTITUTE"
	SUBSTITUTE      EnergyUsageReadIntervalReadReadQualitiesQuality = "SUBSTITUTE"
)

// Defines values for ListAccountsParamsOpenStatus.
const (
	ListAccountsParamsOpenStatusALL    ListAccountsParamsOpenStatus = "ALL"
	ListAccountsParamsOpenStatusCLOSED ListAccountsParamsOpenStatus = "CLOSED"
	ListAccountsParamsOpenStatusOPEN   ListAccountsParamsOpenStatus = "OPEN"
)

// Defines values for ListUsageBulkParamsIntervalReads.
const (
	ListUsageBulkParamsIntervalReadsFULL  ListUsageBulkParamsIntervalReads = "FULL"
	ListUsageBulkParamsIntervalReadsMIN30 ListUsageBulkParamsIntervalReads = "MIN_30"
	ListUsageBulkParamsIntervalReadsNONE  ListUsageBulkParamsIntervalReads = "NONE"
)

// Defines values for ListUsageForServicePointsParamsIntervalReads.
const (
	ListUsageForServicePointsParamsIntervalReadsFULL  ListUsageForServicePointsParamsIntervalReads = "FULL"
	ListUsageForServicePointsParamsIntervalReadsMIN30 ListUsageForServicePointsParamsIntervalReads = "MIN_30"
	ListUsageForServicePointsParamsIntervalReadsNONE  ListUsageForServicePointsParamsIntervalReads = "NONE"
)

// Defines values for GetUsageForServicePointParamsIntervalReads.
const (
	FULL  GetUsageForServicePointParamsIntervalReads = "FULL"
	MIN30 GetUsageForServicePointParamsIntervalReads = "MIN_30"
	NONE  GetUsageForServicePointParamsIntervalReads = "NONE"
)

// Defines values for ListPlansParamsType.
const (
	ListPlansParamsTypeALL       ListPlansParamsType = "ALL"
	ListPlansParamsTypeMARKET    ListPlansParamsType = "MARKET"
	ListPlansParamsTypeREGULATED ListPlansParamsType = "REGULATED"
	ListPlansParamsTypeSTANDING  ListPlansParamsType = "STANDING"
)

// Defines values for ListPlansParamsFuelType.
const (
	ListPlansParamsFuelTypeALL         ListPlansParamsFuelType = "ALL"
	ListPlansParamsFuelTypeDUAL        ListPlansParamsFuelType = "DUAL"
	ListPlansParamsFuelTypeELECTRICITY ListPlansParamsFuelType = "ELECTRICITY"
	ListPlansParamsFuelTypeGAS         ListPlansParamsFuelType = "GAS"
)

// Defines values for ListPlansParamsEffective.
const (
	ListPlansParamsEffectiveALL     ListPlansParamsEffective = "ALL"
	ListPlansParamsEffectiveCURRENT ListPlansParamsEffective = "CURRENT"
	ListPlansParamsEffectiveFUTURE  ListPlansParamsEffective = "FUTURE"
)

// CommonPAFAddress Australian address formatted according to the file format defined by the [PAF file format](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf). Required if addressUType is set to paf
type CommonPAFAddress struct {
	// BuildingName1 Building/Property name 1
	BuildingName1 *string `json:"buildingName1,omitempty"`

	// BuildingName2 Building/Property name 2
	BuildingName2 *string `json:"buildingName2,omitempty"`

	// Dpid Unique identifier for an address as defined by Australia Post.  Also known as Delivery Point Identifier
	Dpid *string `json:"dpid,omitempty"`

	// FlatUnitNumber Unit number (including suffix, if applicable)
	FlatUnitNumber *string `json:"flatUnitNumber,omitempty"`

	// FlatUnitType Type of flat or unit for the address
	FlatUnitType *string `json:"flatUnitType,omitempty"`

	// FloorLevelNumber Floor or level number (including alpha characters)
	FloorLevelNumber *string `json:"floorLevelNumber,omitempty"`

	// FloorLevelType Type of floor or level for the address
	FloorLevelType *string `json:"floorLevelType,omitempty"`

	// LocalityName Full name of locality
	LocalityName string `json:"localityName"`

	// LotNumber Allotment number for the address
	LotNumber *string `json:"lotNumber,omitempty"`

	// PostalDeliveryNumber Postal delivery number if the address is a postal delivery type
	PostalDeliveryNumber *int `json:"postalDeliveryNumber,omitempty"`

	// PostalDeliveryNumberPrefix Postal delivery number prefix related to the postal delivery number
	PostalDeliveryNumberPrefix *string `json:"postalDeliveryNumberPrefix,omitempty"`

	// PostalDeliveryNumberSuffix Postal delivery number suffix related to the postal delivery number
	PostalDeliveryNumberSuffix *string `json:"postalDeliveryNumberSuffix,omitempty"`

	// PostalDeliveryType Postal delivery type. (eg. PO BOX). Valid enumeration defined by Australia Post PAF code file
	PostalDeliveryType *string `json:"postalDeliveryType,omitempty"`

	// Postcode Postcode for the locality
	Postcode string `json:"postcode"`

	// State State in which the address belongs. Valid enumeration defined by Australia Post PAF code file [State Type Abbreviation](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf). NSW, QLD, VIC, NT, WA, SA, TAS, ACT, AAT
	State string `json:"state"`

	// StreetName The name of the street
	StreetName *string `json:"streetName,omitempty"`

	// StreetSuffix The street type suffix. Valid enumeration defined by Australia Post PAF code file
	StreetSuffix *string `json:"streetSuffix,omitempty"`

	// StreetType The street type. Valid enumeration defined by Australia Post PAF code file
	StreetType *string `json:"streetType,omitempty"`

	// ThoroughfareNumber1 Thoroughfare number for a property (first number in a property ranged address)
	ThoroughfareNumber1 *int `json:"thoroughfareNumber1,omitempty"`

	// ThoroughfareNumber1Suffix Suffix for the thoroughfare number. Only relevant is thoroughfareNumber1 is populated
	ThoroughfareNumber1Suffix *string `json:"thoroughfareNumber1Suffix,omitempty"`

	// ThoroughfareNumber2 Second thoroughfare number (only used if the property has a ranged address eg 23-25)
	ThoroughfareNumber2 *int `json:"thoroughfareNumber2,omitempty"`

	// ThoroughfareNumber2Suffix Suffix for the second thoroughfare number. Only relevant is thoroughfareNumber2 is populated
	ThoroughfareNumber2Suffix *string `json:"thoroughfareNumber2Suffix,omitempty"`
}

// CommonPhysicalAddress defines model for CommonPhysicalAddress.
type CommonPhysicalAddress struct {
	// AddressUType The type of address object present
	AddressUType CommonPhysicalAddressAddressUType `json:"addressUType"`

	// Paf Australian address formatted according to the file format defined by the [PAF file format](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf). Required if addressUType is set to paf
	Paf *CommonPAFAddress `json:"paf,omitempty"`

	// Simple Required if addressUType is set to simple
	Simple *CommonSimpleAddress `json:"simple,omitempty"`
}

// CommonPhysicalAddressAddressUType The type of address object present
type CommonPhysicalAddressAddressUType string

// CommonSimpleAddress Required if addressUType is set to simple
type CommonSimpleAddress struct {
	// AddressLine1 First line of the standard address object
	AddressLine1 string `json:"addressLine1"`

	// AddressLine2 Second line of the standard address object
	AddressLine2 *string `json:"addressLine2,omitempty"`

	// AddressLine3 Third line of the standard address object
	AddressLine3 *string `json:"addressLine3,omitempty"`

	// City Name of the city or locality
	City string `json:"city"`

	// Country A valid [ISO 3166 Alpha-3](https://www.iso.org/iso-3166-country-codes.html) country code. Australia (AUS) is assumed if country is not present.
	Country *string `json:"country,omitempty"`

	// MailingName Name of the individual or business formatted for inclusion in an address used for physical mail
	MailingName *string `json:"mailingName,omitempty"`

	// Postcode Mandatory for Australian addresses
	Postcode *string `json:"postcode,omitempty"`

	// State Free text if the country is not Australia. If country is Australia then must be one of the values defined by the [State Type Abbreviation](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf) in the PAF file format. NSW, QLD, VIC, NT, WA, SA, TAS, ACT, AAT
	State string `json:"state"`
}

// EnergyAccountBaseV2 defines model for EnergyAccountBaseV2.
type EnergyAccountBaseV2 struct {
	// AccountId The ID of the account.  To be created in accordance with CDR ID permanence requirements
	AccountId string `json:"accountId"`

	// AccountNumber Optional identifier of the account as defined by the data holder.  This must be the value presented on physical statements (if it exists) and must not be used for the value of accountId
	AccountNumber *string `json:"accountNumber,omitempty"`

	// CreationDate The date that the account was created or opened. Mandatory if openStatus is OPEN
	CreationDate *string `json:"creationDate,omitempty"`

	// DisplayName An optional display name for the account if one exists or can be derived.  The content of this field is at the discretion of the data holder
	DisplayName *string `json:"displayName,omitempty"`

	// OpenStatus Open or closed status for the account. If not present then OPEN is assumed
	OpenStatus *EnergyAccountBaseV2OpenStatus `json:"openStatus,omitempty"`
}

// EnergyAccountBaseV2OpenStatus Open or closed status for the account. If not present then OPEN is assumed
type EnergyAccountBaseV2OpenStatus string

// EnergyAccountDetailResponseV3 defines model for EnergyAccountDetailResponseV3.
type EnergyAccountDetailResponseV3 struct {
	Data  EnergyAccountDetailV3 `json:"data"`
	Links Links                 `json:"links"`
	Meta  *Meta                 `json:"meta,omitempty"`
}

// EnergyAccountDetailV3 defines model for EnergyAccountDetailV3.
type EnergyAccountDetailV3 struct {
	// AccountId The ID of the account.  To be created in accordance with CDR ID permanence requirements
	AccountId string `json:"accountId"`

	// AccountNumber Optional identifier of the account as defined by the data holder.  This must be the value presented on physical statements (if it exists) and must not be used for the value of accountId
	AccountNumber *string `json:"accountNumber,omitempty"`

	// CreationDate The date that the account was created or opened. Mandatory if openStatus is OPEN
	CreationDate *string `json:"creationDate,omitempty"`

	// DisplayName An optional display name for the account if one exists or can be derived.  The content of this field is at the discretion of the data holder
	DisplayName *string `json:"displayName,omitempty"`

	// OpenStatus Open or closed status for the account. If not present then OPEN is assumed
	OpenStatus *EnergyAccountDetailV3OpenStatus `json:"openStatus,omitempty"`

	// Plans The array of plans containing service points and associated plan details
	Plans []EnergyAccountDetailV3AllOfPlans `json:"plans"`
}

// EnergyAccountDetailV3OpenStatus Open or closed status for the account. If not present then OPEN is assumed
type EnergyAccountDetailV3OpenStatus string

// EnergyAccountDetailV3AllOf The array of plans containing service points and associated plan details
type EnergyAccountDetailV3AllOf struct {
	// Plans The array of plans containing service points and associated plan details
	Plans []EnergyAccountDetailV3AllOfPlans `json:"plans"`
}

// EnergyAccountDetailV3AllOfAuthorisedContacts defines model for EnergyAccountDetailV3_allOf_authorisedContacts.
type EnergyAccountDetailV3AllOfAuthorisedContacts struct {
	// FirstName For people with single names this field need not be present. The single name should be in the lastName field
	FirstName *string `json:"firstName,omitempty"`

	// LastName For people with single names the single name should be in this field
	LastName string `json:"lastName"`

	// MiddleNames Field is mandatory but array may be empty
	MiddleNames *[]string `json:"middleNames,omitempty"`

	// Prefix Also known as title or salutation. The prefix to the name (e.g. Mr, Mrs, Ms, Miss, Sir, etc)
	Prefix *string `json:"prefix,omitempty"`

	// Suffix Used for a trailing suffix to the name (e.g. Jr)
	Suffix *string `json:"suffix,omitempty"`
}

// EnergyAccountDetailV3AllOfPlanDetail Detail on the plan applicable to this account. Mandatory if openStatus is OPEN
type EnergyAccountDetailV3AllOfPlanDetail struct {
	ElectricityContract *EnergyPlanContractV2 `json:"electricityContract,omitempty"`

	// FuelType The fuel types covered by the plan
	FuelType    EnergyAccountDetailV3AllOfPlanDetailFuelType `json:"fuelType"`
	GasContract *EnergyPlanContractV2                        `json:"gasContract,omitempty"`

	// IsContingentPlan Flag that indicates that the plan is contingent on the customer taking up an alternate fuel plan from the same retailer (for instance, if the fuelType is ELECTRICITY then a GAS plan from the same retailer must be taken up). Has no meaning if the plan has a fuelType of DUAL. If absent the value is assumed to be false
	IsContingentPlan *bool `json:"isContingentPlan,omitempty"`

	// MeteringCharges Charges for metering included in the plan
	MeteringCharges *[]EnergyPlanDetailV2AllOfMeteringCharges `json:"meteringCharges,omitempty"`
}

// EnergyAccountDetailV3AllOfPlanDetailFuelType The fuel types covered by the plan
type EnergyAccountDetailV3AllOfPlanDetailFuelType string

// EnergyAccountDetailV3AllOfPlans defines model for EnergyAccountDetailV3_allOf_plans.
type EnergyAccountDetailV3AllOfPlans struct {
	// AuthorisedContacts An array of additional contacts that are authorised to act on this account
	AuthorisedContacts *[]EnergyAccountDetailV3AllOfAuthorisedContacts `json:"authorisedContacts,omitempty"`

	// Nickname Optional display name for the plan provided by the customer to help differentiate multiple plans
	Nickname *string `json:"nickname,omitempty"`

	// PlanDetail Detail on the plan applicable to this account. Mandatory if openStatus is OPEN
	PlanDetail *EnergyAccountDetailV3AllOfPlanDetail `json:"planDetail,omitempty"`

	// PlanOverview Mandatory if openStatus is OPEN
	PlanOverview *EnergyAccountV2AllOfPlanOverview `json:"planOverview,omitempty"`

	// ServicePointIds An array of servicePointIds, representing NMIs, that this account is linked to
	ServicePointIds []string `json:"servicePointIds"`
}

// EnergyAccountListResponseV2 defines model for EnergyAccountListResponseV2.
type EnergyAccountListResponseV2 struct {
	Data  EnergyAccountListResponseV2Data `json:"data"`
	Links LinksPaginated                  `json:"links"`
	Meta  MetaPaginated                   `json:"meta"`
}

// EnergyAccountListResponseV2Data defines model for EnergyAccountListResponseV2_data.
type EnergyAccountListResponseV2Data struct {
	// Accounts Array of accounts
	Accounts []EnergyAccountV2 `json:"accounts"`
}

// EnergyAccountV2 defines model for EnergyAccountV2.
type EnergyAccountV2 struct {
	// AccountId The ID of the account.  To be created in accordance with CDR ID permanence requirements
	AccountId string `json:"accountId"`

	// AccountNumber Optional identifier of the account as defined by the data holder.  This must be the value presented on physical statements (if it exists) and must not be used for the value of accountId
	AccountNumber *string `json:"accountNumber,omitempty"`

	// CreationDate The date that the account was created or opened. Mandatory if openStatus is OPEN
	CreationDate *string `json:"creationDate,omitempty"`

	// DisplayName An optional display name for the account if one exists or can be derived.  The content of this field is at the discretion of the data holder
	DisplayName *string `json:"displayName,omitempty"`

	// OpenStatus Open or closed status for the account. If not present then OPEN is assumed
	OpenStatus *EnergyAccountV2OpenStatus `json:"openStatus,omitempty"`

	// Plans The array of plans containing service points and associated plan details
	Plans []EnergyAccountV2AllOfPlans `json:"plans"`
}

// EnergyAccountV2OpenStatus Open or closed status for the account. If not present then OPEN is assumed
type EnergyAccountV2OpenStatus string

// EnergyAccountV2AllOf The array of plans containing service points and associated plan details
type EnergyAccountV2AllOf struct {
	// Plans The array of plans containing service points and associated plan details
	Plans []EnergyAccountV2AllOfPlans `json:"plans"`
}

// EnergyAccountV2AllOfPlanOverview Mandatory if openStatus is OPEN
type EnergyAccountV2AllOfPlanOverview struct {
	// DisplayName The name of the plan if one exists
	DisplayName *string `json:"displayName,omitempty"`

	// EndDate The end date of the applicability of this plan
	EndDate *string `json:"endDate,omitempty"`

	// StartDate The start date of the applicability of this plan
	StartDate string `json:"startDate"`
}

// EnergyAccountV2AllOfPlans defines model for EnergyAccountV2_allOf_plans.
type EnergyAccountV2AllOfPlans struct {
	// Nickname Optional display name for the plan provided by the customer to help differentiate multiple plans
	Nickname *string `json:"nickname,omitempty"`

	// PlanOverview Mandatory if openStatus is OPEN
	PlanOverview *EnergyAccountV2AllOfPlanOverview `json:"planOverview,omitempty"`

	// ServicePointIds An array of servicePointIds, representing NMIs, that this plan is linked to.  If there are no service points allocated to this plan then an empty array would be expected
	ServicePointIds []string `json:"servicePointIds"`
}

// EnergyBalanceListResponse defines model for EnergyBalanceListResponse.
type EnergyBalanceListResponse struct {
	Data  EnergyBalanceListResponseData `json:"data"`
	Links LinksPaginated                `json:"links"`
	Meta  MetaPaginated                 `json:"meta"`
}

// EnergyBalanceListResponseData defines model for EnergyBalanceListResponse_data.
type EnergyBalanceListResponseData struct {
	// Balances Array of account balances
	Balances []EnergyBalanceListResponseDataBalances `json:"balances"`
}

// EnergyBalanceListResponseDataBalances defines model for EnergyBalanceListResponse_data_balances.
type EnergyBalanceListResponseDataBalances struct {
	// AccountId The ID of the account
	AccountId string `json:"accountId"`

	// Balance The current balance of the account.  A positive value indicates that amount is owing to be paid.  A negative value indicates that the account is in credit
	Balance string `json:"balance"`
}

// EnergyBalanceResponse defines model for EnergyBalanceResponse.
type EnergyBalanceResponse struct {
	Data  EnergyBalanceResponseData `json:"data"`
	Links Links                     `json:"links"`
	Meta  *Meta                     `json:"meta,omitempty"`
}

// EnergyBalanceResponseData defines model for EnergyBalanceResponse_data.
type EnergyBalanceResponseData struct {
	// Balance The current balance of the account.  A positive value indicates that amount is owing to be paid.  A negative value indicates that the account is in credit
	Balance string `json:"balance"`
}

// EnergyBillingDemandTransaction defines model for EnergyBillingDemandTransaction.
type EnergyBillingDemandTransaction struct {
	// Adjustments Optional array of adjustments arising for this transaction
	Adjustments *[]EnergyBillingUsageTransactionAdjustments `json:"adjustments,omitempty"`

	// Amount The amount charged or credited for this transaction prior to any adjustments being applied.  A negative value indicates a credit
	Amount string `json:"amount"`

	// CalculationFactors Additional calculation factors that inform the transaction
	CalculationFactors *[]EnergyBillingUsageTransactionCalculationFactors `json:"calculationFactors,omitempty"`

	// Description Optional description of the transaction that can be used for display purposes
	Description *string `json:"description,omitempty"`

	// EndDate Date and time when the demand period ends
	EndDate string `json:"endDate"`

	// InvoiceNumber The number of the invoice in which this transaction is included if it has been issued
	InvoiceNumber *string `json:"invoiceNumber,omitempty"`

	// IsEstimate Flag indicating if the usage is estimated or actual.  True indicates estimate.  False or absent indicates actual
	IsEstimate *bool `json:"isEstimate,omitempty"`

	// Rate The rate for the demand charge in kVA.  A negative value indicates power generated
	Rate float32 `json:"rate"`

	// ServicePointId The ID of the service point to which this transaction applies if any
	ServicePointId *string `json:"servicePointId,omitempty"`

	// StartDate Date and time when the demand period starts
	StartDate string `json:"startDate"`

	// TimeOfUseType The time of use type that the transaction applies to
	TimeOfUseType EnergyBillingDemandTransactionTimeOfUseType `json:"timeOfUseType"`
}

// EnergyBillingDemandTransactionTimeOfUseType The time of use type that the transaction applies to
type EnergyBillingDemandTransactionTimeOfUseType string

// EnergyBillingListResponse defines model for EnergyBillingListResponse.
type EnergyBillingListResponse struct {
	Data  EnergyBillingListResponseData `json:"data"`
	Links LinksPaginated                `json:"links"`
	Meta  MetaPaginated                 `json:"meta"`
}

// EnergyBillingListResponseData defines model for EnergyBillingListResponse_data.
type EnergyBillingListResponseData struct {
	// Transactions Array of transactions sorted by date and time in descending order
	Transactions []EnergyBillingTransaction `json:"transactions"`
}

// EnergyBillingOnceOffTransaction defines model for EnergyBillingOnceOffTransaction.
type EnergyBillingOnceOffTransaction struct {
	// Amount The amount of the charge or credit.  A positive value indicates a charge and a negative value indicates a credit
	Amount string `json:"amount"`

	// Description A free text description of the item
	Description string `json:"description"`

	// InvoiceNumber The number of the invoice in which this transaction is included if it has been issued
	InvoiceNumber *string `json:"invoiceNumber,omitempty"`

	// ServicePointId The ID of the service point to which this transaction applies if any
	ServicePointId *string `json:"servicePointId,omitempty"`
}

// EnergyBillingOtherTransaction defines model for EnergyBillingOtherTransaction.
type EnergyBillingOtherTransaction struct {
	// Adjustments Optional array of adjustments arising for this transaction
	Adjustments *[]EnergyBillingUsageTransactionAdjustments `json:"adjustments,omitempty"`

	// Amount The amount of the charge
	Amount string `json:"amount"`

	// CalculationFactors Additional calculation factors that inform the transaction
	CalculationFactors *[]EnergyBillingUsageTransactionCalculationFactors `json:"calculationFactors,omitempty"`

	// Description A free text description of the item
	Description string `json:"description"`

	// EndDate Optional end date for the application of the charge
	EndDate *string `json:"endDate,omitempty"`

	// InvoiceNumber The number of the invoice in which this transaction is included if it has been issued
	InvoiceNumber *string `json:"invoiceNumber,omitempty"`

	// ServicePointId The ID of the service point to which this transaction applies if any
	ServicePointId *string `json:"servicePointId,omitempty"`

	// StartDate Optional start date for the application of the charge
	StartDate *string `json:"startDate,omitempty"`

	// Type Type of charge. Assumed to be other if absent
	Type *EnergyBillingOtherTransactionType `json:"type,omitempty"`
}

// EnergyBillingOtherTransactionType Type of charge. Assumed to be other if absent
type EnergyBillingOtherTransactionType string

// EnergyBillingPaymentTransaction defines model for EnergyBillingPaymentTransaction.
type EnergyBillingPaymentTransaction struct {
	// Amount The amount paid
	Amount string `json:"amount"`

	// Method The method of payment
	Method EnergyBillingPaymentTransactionMethod `json:"method"`
}

// EnergyBillingPaymentTransactionMethod The method of payment
type EnergyBillingPaymentTransactionMethod string

// EnergyBillingTransaction defines model for EnergyBillingTransaction.
type EnergyBillingTransaction struct {
	// AccountId The ID of the account for which transaction applies
	AccountId string                          `json:"accountId"`
	Demand    *EnergyBillingDemandTransaction `json:"demand,omitempty"`

	// ExecutionDateTime The date and time that the transaction occurred
	ExecutionDateTime string `json:"executionDateTime"`

	// Gst The GST incurred in the transaction.  Should not be included for credits or payments.  If absent zero is assumed
	Gst          *string                          `json:"gst,omitempty"`
	OnceOff      *EnergyBillingOnceOffTransaction `json:"onceOff,omitempty"`
	OtherCharges *EnergyBillingOtherTransaction   `json:"otherCharges,omitempty"`
	Payment      *EnergyBillingPaymentTransaction `json:"payment,omitempty"`

	// TransactionUType Indicator of the type of transaction object present in this record
	TransactionUType EnergyBillingTransactionTransactionUType `json:"transactionUType"`
	Usage            *EnergyBillingUsageTransaction           `json:"usage,omitempty"`
}

// EnergyBillingTransactionTransactionUType Indicator of the type of transaction object present in this record
type EnergyBillingTransactionTransactionUType string

// EnergyBillingUsageTransaction defines model for EnergyBillingUsageTransaction.
type EnergyBillingUsageTransaction struct {
	// Adjustments Optional array of adjustments arising for this transaction
	Adjustments *[]EnergyBillingUsageTransactionAdjustments `json:"adjustments,omitempty"`

	// Amount The amount charged or credited for this transaction prior to any adjustments being applied.  A negative value indicates a credit
	Amount string `json:"amount"`

	// CalculationFactors Additional calculation factors that inform the transaction
	CalculationFactors *[]EnergyBillingUsageTransactionCalculationFactors `json:"calculationFactors,omitempty"`

	// Description Optional description of the transaction that can be used for display purposes
	Description *string `json:"description,omitempty"`

	// EndDate Date and time when the usage period ends
	EndDate string `json:"endDate"`

	// InvoiceNumber The number of the invoice in which this transaction is included if it has been issued
	InvoiceNumber *string `json:"invoiceNumber,omitempty"`

	// IsEstimate Flag indicating if the usage is estimated or actual.  True indicates estimate.  False or absent indicates actual
	IsEstimate *bool `json:"isEstimate,omitempty"`

	// MeasureUnit The measurement unit of rate. Assumed to be KWH if absent
	MeasureUnit *EnergyBillingUsageTransactionMeasureUnit `json:"measureUnit,omitempty"`

	// ServicePointId The ID of the service point to which this transaction applies if any
	ServicePointId *string `json:"servicePointId,omitempty"`

	// StartDate Date and time when the usage period starts
	StartDate string `json:"startDate"`

	// TimeOfUseType The time of use type that the transaction applies to
	TimeOfUseType EnergyBillingUsageTransactionTimeOfUseType `json:"timeOfUseType"`

	// Usage The usage for the period in measure unit.  A negative value indicates power generated
	Usage float32 `json:"usage"`
}

// EnergyBillingUsageTransactionMeasureUnit The measurement unit of rate. Assumed to be KWH if absent
type EnergyBillingUsageTransactionMeasureUnit string

// EnergyBillingUsageTransactionTimeOfUseType The time of use type that the transaction applies to
type EnergyBillingUsageTransactionTimeOfUseType string

// EnergyBillingUsageTransactionAdjustments defines model for EnergyBillingUsageTransaction_adjustments.
type EnergyBillingUsageTransactionAdjustments struct {
	// Amount The amount of the adjustment
	Amount string `json:"amount"`

	// Description A free text description of the adjustment
	Description string `json:"description"`
}

// EnergyBillingUsageTransactionCalculationFactors defines model for EnergyBillingUsageTransaction_calculationFactors.
type EnergyBillingUsageTransactionCalculationFactors struct {
	// Type The type of the calculation factor
	Type EnergyBillingUsageTransactionCalculationFactorsType `json:"type"`

	// Value The value of the calculation factor
	Value float32 `json:"value"`
}

// EnergyBillingUsageTransactionCalculationFactorsType The type of the calculation factor
type EnergyBillingUsageTransactionCalculationFactorsType string

// EnergyConcession defines model for EnergyConcession.
type EnergyConcession struct {
	// AdditionalInfo Display text providing more information on the concession. Mandatory if type is VARIABLE
	AdditionalInfo *string `json:"additionalInfo,omitempty"`

	// AdditionalInfoUri Optional link to additional information regarding the concession
	AdditionalInfoUri *string `json:"additionalInfoUri,omitempty"`

	// Amount Conditional attribute for the amount of discount for the concession- required if type is FIXED_AMOUNT
	Amount *string `json:"amount,omitempty"`

	// AppliedTo Array of ENUM's to specify what the concession applies to. Multiple ENUM values can be provided. If absent, USAGE is assumed
	AppliedTo *[]EnergyConcessionAppliedTo `json:"appliedTo,omitempty"`

	// DiscountFrequency Conditional attribute for frequency at which a concession is applied. Required if type is FIXED_AMOUNT or FIXED_PERCENTAGE. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	DiscountFrequency *string `json:"discountFrequency,omitempty"`

	// DisplayName The display name of the concession
	DisplayName string `json:"displayName"`

	// EndDate Optional end date for the application of the concession
	EndDate *string `json:"endDate,omitempty"`

	// Percentage Conditional attribute for the percentage of discount of concession - required if type is FIXED_PERCENTAGE
	Percentage *string `json:"percentage,omitempty"`

	// StartDate Optional start date for the application of the concession
	StartDate *string `json:"startDate,omitempty"`

	// Type Indicator of the method of concession calculation
	Type EnergyConcessionType `json:"type"`
}

// EnergyConcessionAppliedTo defines model for EnergyConcession.AppliedTo.
type EnergyConcessionAppliedTo string

// EnergyConcessionType Indicator of the method of concession calculation
type EnergyConcessionType string

// EnergyConcessionsResponse defines model for EnergyConcessionsResponse.
type EnergyConcessionsResponse struct {
	Data  EnergyConcessionsResponseData `json:"data"`
	Links Links                         `json:"links"`
	Meta  *Meta                         `json:"meta,omitempty"`
}

// EnergyConcessionsResponseData defines model for EnergyConcessionsResponse_data.
type EnergyConcessionsResponseData struct {
	// Concessions Array may be empty if no concessions exist
	Concessions []EnergyConcession `json:"concessions"`
}

// EnergyDerDetailResponse defines model for EnergyDerDetailResponse.
type EnergyDerDetailResponse struct {
	Data  EnergyDerRecord `json:"data"`
	Links Links           `json:"links"`
	Meta  *Meta           `json:"meta,omitempty"`
}

// EnergyDerListResponse defines model for EnergyDerListResponse.
type EnergyDerListResponse struct {
	Data  EnergyDerListResponseData `json:"data"`
	Links LinksPaginated            `json:"links"`
	Meta  MetaPaginated             `json:"meta"`
}

// EnergyDerListResponseData defines model for EnergyDerListResponse_data.
type EnergyDerListResponseData struct {
	// DerRecords Array of meter reads
	DerRecords []EnergyDerRecord `json:"derRecords"`
}

// EnergyDerRecord defines model for EnergyDerRecord.
type EnergyDerRecord struct {
	AcConnections []EnergyDerRecordAcConnections `json:"acConnections"`

	// ApprovedCapacity Approved small generating unit capacity as agreed with NSP in the connection agreement, expressed in kVA. Value of 0 indicates no DER record exists for the given servicePointId
	ApprovedCapacity float32 `json:"approvedCapacity"`

	// AvailablePhasesCount The number of phases available for the installation of DER. Acceptable values are 0, 1, 2 or 3. Value of 0 indicates no DER record exists for the given servicePointId
	AvailablePhasesCount int `json:"availablePhasesCount"`

	// HasCentralProtectionControl For DER installations where NSPs specify the need for additional forms of protection above those inbuilt in an inverter.  If absent then assumed to be false
	HasCentralProtectionControl *bool `json:"hasCentralProtectionControl,omitempty"`

	// InstalledPhasesCount The number of phases that DER is connected to. Acceptable values are 0, 1, 2 or 3. Value of 0 indicates no DER record exists for the given servicePointId
	InstalledPhasesCount int `json:"installedPhasesCount"`

	// IslandableInstallation For identification of small generating units designed with the ability to operate in an islanded mode
	IslandableInstallation bool `json:"islandableInstallation"`

	// ProtectionMode Required only when the hasCentralProtectionAndControl flag is set to true.  One or more of the object fields will be provided to describe the protection modes in place
	ProtectionMode *EnergyDerRecordProtectionMode `json:"protectionMode,omitempty"`

	// ServicePointId Tokenised ID of the service point to be used for referring to the service point in the CDR API suite.  To be created in accordance with CDR ID permanence requirements
	ServicePointId string `json:"servicePointId"`
}

// EnergyDerRecordAcConnections defines model for EnergyDerRecord_acConnections.
type EnergyDerRecordAcConnections struct {
	// CommissioningDate The date that the DER installation is commissioned
	CommissioningDate string `json:"commissioningDate"`

	// ConnectionIdentifier AC Connection ID as defined in the DER register.  Does not align with CDR ID permanence standards
	ConnectionIdentifier float32 `json:"connectionIdentifier"`

	// Count Number of AC Connections in the group. For the suite of AC Connections to be considered as a group, all of the AC Connections included must have the same attributes
	Count      int                         `json:"count"`
	DerDevices []EnergyDerRecordDerDevices `json:"derDevices"`

	// EquipmentType Indicates whether the DER device is connected via an inverter (and what category of inverter it is) or not (e.g. rotating machine). If absent, assume equipment type to be OTHER.
	EquipmentType *EnergyDerRecordAcConnectionsEquipmentType `json:"equipmentType,omitempty"`

	// InverterDeviceCapacity The rated AC output power that is listed in the product specified by the manufacturer. Mandatory if equipmentType is INVERTER. Default is 0 if value not known
	InverterDeviceCapacity *float32 `json:"inverterDeviceCapacity,omitempty"`

	// InverterModelNumber The inverter model number. Mandatory if equipmentType is INVERTER
	InverterModelNumber *string `json:"inverterModelNumber,omitempty"`

	// InverterSeries The inverter series. Mandatory if equipmentType is INVERTER
	InverterSeries *string `json:"inverterSeries,omitempty"`

	// ManufacturerName The name of the inverter manufacturer. Mandatory if equipmentType is INVERTER
	ManufacturerName *string `json:"manufacturerName,omitempty"`

	// Status Code used to indicate the status of the Inverter. This will be used to identify if an inverter is active or inactive or decommissioned
	Status EnergyDerRecordAcConnectionsStatus `json:"status"`
}

// EnergyDerRecordAcConnectionsEquipmentType Indicates whether the DER device is connected via an inverter (and what category of inverter it is) or not (e.g. rotating machine). If absent, assume equipment type to be OTHER.
type EnergyDerRecordAcConnectionsEquipmentType string

// EnergyDerRecordAcConnectionsStatus Code used to indicate the status of the Inverter. This will be used to identify if an inverter is active or inactive or decommissioned
type EnergyDerRecordAcConnectionsStatus string

// EnergyDerRecordDerDevices defines model for EnergyDerRecord_derDevices.
type EnergyDerRecordDerDevices struct {
	// Count Number of devices in the group of DER devices
	Count int `json:"count"`

	// DeviceIdentifier Unique identifier for a single DER device or a group of DER devices with the same attributes. Does not align with CDR ID permanence standards
	DeviceIdentifier float32 `json:"deviceIdentifier"`

	// Manufacturer The name of the device manufacturer. If absent then assumed to be unknown
	Manufacturer *string `json:"manufacturer,omitempty"`

	// ModelNumber The model number of the device. If absent then assumed to be unknown
	ModelNumber *string `json:"modelNumber,omitempty"`

	// NominalRatedCapacity Maximum output in kVA that is listed in the product specification by the manufacturer. This refers to the capacity of each unit within the device group. Default is 0 if value not known
	NominalRatedCapacity float32 `json:"nominalRatedCapacity"`

	// NominalStorageCapacity Maximum storage capacity in kVAh. This refers to the capacity of each storage module within the device group. Mandatory if type is equal to STORAGE. Default is 0 if value not known
	NominalStorageCapacity *float32 `json:"nominalStorageCapacity,omitempty"`

	// Status Code used to indicate the status of the device. This will be used to identify if an inverter is active or inactive or decommissioned
	Status *EnergyDerRecordDerDevicesStatus `json:"status,omitempty"`

	// Subtype Used to indicate the primary technology used in the DER device. This field is also used to record for example the battery chemistry, or the type of PV panel. It is also used to record if a battery is contained in an electric vehicle connected in a vehicle-to-grid arrangement. If absent then assumed to be other
	Subtype *string `json:"subtype,omitempty"`

	// Type Used to indicate the primary technology used in the DER device
	Type EnergyDerRecordDerDevicesType `json:"type"`
}

// EnergyDerRecordDerDevicesStatus Code used to indicate the status of the device. This will be used to identify if an inverter is active or inactive or decommissioned
type EnergyDerRecordDerDevicesStatus string

// EnergyDerRecordDerDevicesType Used to indicate the primary technology used in the DER device
type EnergyDerRecordDerDevicesType string

// EnergyDerRecordProtectionMode Required only when the hasCentralProtectionAndControl flag is set to true.  One or more of the object fields will be provided to describe the protection modes in place
type EnergyDerRecordProtectionMode struct {
	// ExportLimitKva Maximum amount of power (kVA) that may be exported from a connection point to the grid, as monitored by a control / relay function. An absent value indicates no limit
	ExportLimitKva *float32 `json:"exportLimitKva,omitempty"`

	// FrequencyRateOfChange Rate of change of frequency trip point (Hz/s).
	FrequencyRateOfChange *float32 `json:"frequencyRateOfChange,omitempty"`

	// InterTripScheme Description of the form of inter-trip (e.g. 'from local substation').
	InterTripScheme *string `json:"interTripScheme,omitempty"`

	// NeutralVoltageDisplacement Trip voltage.
	NeutralVoltageDisplacement *float32 `json:"neutralVoltageDisplacement,omitempty"`

	// OverFrequencyProtection Protective function limit in Hz.
	OverFrequencyProtection *float32 `json:"overFrequencyProtection,omitempty"`

	// OverFrequencyProtectionDelay Trip delay time in seconds.
	OverFrequencyProtectionDelay *float32 `json:"overFrequencyProtectionDelay,omitempty"`

	// OverVoltageProtection Protective function limit in V.
	OverVoltageProtection *float32 `json:"overVoltageProtection,omitempty"`

	// OverVoltageProtectionDelay Trip delay time in seconds.
	OverVoltageProtectionDelay *float32 `json:"overVoltageProtectionDelay,omitempty"`

	// SustainedOverVoltage Sustained over voltage.
	SustainedOverVoltage *float32 `json:"sustainedOverVoltage,omitempty"`

	// SustainedOverVoltageDelay Sustained Over voltage protection delay in seconds.
	SustainedOverVoltageDelay *float32 `json:"sustainedOverVoltageDelay,omitempty"`

	// UnderFrequencyProtection Protective function limit in Hz.
	UnderFrequencyProtection *float32 `json:"underFrequencyProtection,omitempty"`

	// UnderFrequencyProtectionDelay Trip delay time in seconds.
	UnderFrequencyProtectionDelay *float32 `json:"underFrequencyProtectionDelay,omitempty"`

	// UnderVoltageProtection Protective function limit in V.
	UnderVoltageProtection *float32 `json:"underVoltageProtection,omitempty"`

	// UnderVoltageProtectionDelay Trip delay time in seconds.
	UnderVoltageProtectionDelay *float32 `json:"underVoltageProtectionDelay,omitempty"`

	// VoltageVectorShift Trip angle in degrees.
	VoltageVectorShift *float32 `json:"voltageVectorShift,omitempty"`
}

// EnergyInvoice defines model for EnergyInvoice.
type EnergyInvoice struct {
	// AccountCharges Object contains account level charges and credits related to electricity usage
	AccountCharges *EnergyInvoiceAccountCharges `json:"accountCharges,omitempty"`

	// AccountId The ID of the account for which the invoice was issued
	AccountId string `json:"accountId"`

	// BalanceAtIssue The account balance at the time the invoice was issued
	BalanceAtIssue string `json:"balanceAtIssue"`

	// DueDate The date that the invoice is due to be paid
	DueDate     *string                               `json:"dueDate,omitempty"`
	Electricity *EnergyInvoiceElectricityUsageCharges `json:"electricity,omitempty"`
	Gas         *EnergyInvoiceGasUsageCharges         `json:"gas,omitempty"`

	// GstAmount The total GST amount for this invoice.  If absent then zero is assumed
	GstAmount *string `json:"gstAmount,omitempty"`

	// InvoiceAmount The net amount due for this invoice regardless of previous balance
	InvoiceAmount *string `json:"invoiceAmount,omitempty"`

	// InvoiceNumber The number assigned to this invoice by the energy Retailer
	InvoiceNumber string `json:"invoiceNumber"`

	// IssueDate The date that the invoice was actually issued (as opposed to generated or calculated)
	IssueDate openapi_types.Date `json:"issueDate"`

	// PayOnTimeDiscount A discount for on time payment
	PayOnTimeDiscount *EnergyInvoicePayOnTimeDiscount `json:"payOnTimeDiscount,omitempty"`

	// PaymentStatus Indicator of the payment status for the invoice
	PaymentStatus EnergyInvoicePaymentStatus `json:"paymentStatus"`

	// Period Object containing the start and end date for the period covered by the invoice.  Mandatory if any usage or demand based charges are included in the invoice
	Period *EnergyInvoicePeriod `json:"period,omitempty"`

	// ServicePoints Array of service point IDs to which this invoice applies. May be empty if the invoice contains no electricity usage related charges
	ServicePoints []string `json:"servicePoints"`
}

// EnergyInvoicePaymentStatus Indicator of the payment status for the invoice
type EnergyInvoicePaymentStatus string

// EnergyInvoiceAccountCharges Object contains account level charges and credits related to electricity usage
type EnergyInvoiceAccountCharges struct {
	// TotalCharges The aggregate total of account level charges for the period covered by the invoice
	TotalCharges string `json:"totalCharges"`

	// TotalDiscounts The aggregate total of account level discounts or credits for the period covered by the invoice
	TotalDiscounts string `json:"totalDiscounts"`

	// TotalGst The total GST for all account level charges.  If absent then zero is assumed
	TotalGst *string `json:"totalGst,omitempty"`
}

// EnergyInvoiceElectricityUsageCharges defines model for EnergyInvoiceElectricityUsageCharges.
type EnergyInvoiceElectricityUsageCharges struct {
	// OtherCharges Optional array of charges that may be part of the invoice (for e.g. environmental charges for C&I consumers) (exclusive of GST)
	OtherCharges *[]EnergyInvoiceGasUsageChargesOtherCharges `json:"otherCharges,omitempty"`

	// TotalGenerationCredits The aggregate total of generation credits for the period covered by the invoice (exclusive of GST)
	TotalGenerationCredits string `json:"totalGenerationCredits"`

	// TotalGst The total GST for all electricity usage charges.  If absent then zero is assumed
	TotalGst *string `json:"totalGst,omitempty"`

	// TotalOnceOffCharges The aggregate total of any once off charges arising from electricity usage for the period covered by the invoice (exclusive of GST)
	TotalOnceOffCharges string `json:"totalOnceOffCharges"`

	// TotalOnceOffDiscounts The aggregate total of any once off discounts or credits arising from electricity usage for the period covered by the invoice (exclusive of GST)
	TotalOnceOffDiscounts string `json:"totalOnceOffDiscounts"`

	// TotalUsageCharges The aggregate total of usage charges for the period covered by the invoice (exclusive of GST)
	TotalUsageCharges string `json:"totalUsageCharges"`
}

// EnergyInvoiceGasUsageCharges defines model for EnergyInvoiceGasUsageCharges.
type EnergyInvoiceGasUsageCharges struct {
	// OtherCharges Optional array of charges that may be part of the invoice (for e.g. environmental charges for C&I consumers) (exclusive of GST)
	OtherCharges *[]EnergyInvoiceGasUsageChargesOtherCharges `json:"otherCharges,omitempty"`

	// TotalGenerationCredits The aggregate total of generation credits for the period covered by the invoice (exclusive of GST)
	TotalGenerationCredits string `json:"totalGenerationCredits"`

	// TotalGst The total GST for all electricity usage charges.  If absent then zero is assumed
	TotalGst *string `json:"totalGst,omitempty"`

	// TotalOnceOffCharges The aggregate total of any once off charges arising from electricity usage for the period covered by the invoice (exclusive of GST)
	TotalOnceOffCharges string `json:"totalOnceOffCharges"`

	// TotalOnceOffDiscounts The aggregate total of any once off discounts or credits arising from electricity usage for the period covered by the invoice (exclusive of GST)
	TotalOnceOffDiscounts string `json:"totalOnceOffDiscounts"`

	// TotalUsageCharges The aggregate total of usage charges for the period covered by the invoice (exclusive of GST)
	TotalUsageCharges string `json:"totalUsageCharges"`
}

// EnergyInvoiceGasUsageChargesOtherCharges defines model for EnergyInvoiceGasUsageCharges_otherCharges.
type EnergyInvoiceGasUsageChargesOtherCharges struct {
	// Amount The aggregate total of charges for this item (exclusive of GST)
	Amount string `json:"amount"`

	// Description A free text description of the type of charge
	Description string `json:"description"`

	// Type Type of charge. Assumed to be other if absent
	Type *EnergyInvoiceGasUsageChargesOtherChargesType `json:"type,omitempty"`
}

// EnergyInvoiceGasUsageChargesOtherChargesType Type of charge. Assumed to be other if absent
type EnergyInvoiceGasUsageChargesOtherChargesType string

// EnergyInvoiceListResponse defines model for EnergyInvoiceListResponse.
type EnergyInvoiceListResponse struct {
	Data  EnergyInvoiceListResponseData `json:"data"`
	Links LinksPaginated                `json:"links"`
	Meta  MetaPaginated                 `json:"meta"`
}

// EnergyInvoiceListResponseData defines model for EnergyInvoiceListResponse_data.
type EnergyInvoiceListResponseData struct {
	// Invoices Array of invoices sorted by issue date in descending order
	Invoices []EnergyInvoice `json:"invoices"`
}

// EnergyInvoicePayOnTimeDiscount A discount for on time payment
type EnergyInvoicePayOnTimeDiscount struct {
	// Date The date by which the invoice must be paid to receive the pay on time discount
	Date string `json:"date"`

	// DiscountAmount The amount that will be discounted if the invoice is paid by the date specified
	DiscountAmount string `json:"discountAmount"`

	// GstAmount The GST amount that will be discounted if the invoice is paid by the date specified.  If absent then zero is assumed
	GstAmount *string `json:"gstAmount,omitempty"`
}

// EnergyInvoicePeriod Object containing the start and end date for the period covered by the invoice.  Mandatory if any usage or demand based charges are included in the invoice
type EnergyInvoicePeriod struct {
	// EndDate The end date of the period covered by this invoice
	EndDate string `json:"endDate"`

	// StartDate The start date of the period covered by this invoice
	StartDate string `json:"startDate"`
}

// EnergyPaymentSchedule defines model for EnergyPaymentSchedule.
type EnergyPaymentSchedule struct {
	// Amount Optional payment amount indicating that a constant payment amount is scheduled to be paid (used in bill smoothing scenarios)
	Amount *string `json:"amount,omitempty"`

	// CardDebit Represents a regular credit card payment schedule. Mandatory if paymentScheduleUType is set to cardDebit
	CardDebit *EnergyPaymentScheduleCardDebit `json:"cardDebit,omitempty"`

	// DigitalWallet Represents a regular payment from a digital wallet. Mandatory if paymentScheduleUType is set to digitalWallet
	DigitalWallet *EnergyPaymentScheduleDigitalWallet `json:"digitalWallet,omitempty"`

	// DirectDebit Represents a regular direct debit from a specified bank account. Mandatory if paymentScheduleUType is set to directDebit
	DirectDebit *EnergyPaymentScheduleDirectDebit `json:"directDebit,omitempty"`

	// ManualPayment Represents a manual payment schedule where the customer pays in response to a delivered statement. Mandatory if paymentScheduleUType is set to manualPayment
	ManualPayment *EnergyPaymentScheduleManualPayment `json:"manualPayment,omitempty"`

	// PaymentScheduleUType The type of object present in this response
	PaymentScheduleUType EnergyPaymentSchedulePaymentScheduleUType `json:"paymentScheduleUType"`
}

// EnergyPaymentSchedulePaymentScheduleUType The type of object present in this response
type EnergyPaymentSchedulePaymentScheduleUType string

// EnergyPaymentScheduleResponse defines model for EnergyPaymentScheduleResponse.
type EnergyPaymentScheduleResponse struct {
	Data  EnergyPaymentScheduleResponseData `json:"data"`
	Links Links                             `json:"links"`
	Meta  *Meta                             `json:"meta,omitempty"`
}

// EnergyPaymentScheduleResponseData defines model for EnergyPaymentScheduleResponse_data.
type EnergyPaymentScheduleResponseData struct {
	// PaymentSchedules Array may be empty if no payment schedule exist
	PaymentSchedules []EnergyPaymentSchedule `json:"paymentSchedules"`
}

// EnergyPaymentScheduleCardDebit Represents a regular credit card payment schedule. Mandatory if paymentScheduleUType is set to cardDebit
type EnergyPaymentScheduleCardDebit struct {
	// CalculationType The mechanism by which the payment amount is calculated.  Explanation of values are as follows:<br/><ul><li>**STATIC** - Indicates a consistent, static amount, per payment</li><li>**BALANCE** - Indicates that the outstanding balance for the account is paid per period</li><li>**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm</li></ul>
	CalculationType EnergyPaymentScheduleCardDebitCalculationType `json:"calculationType"`

	// CardScheme The type of credit card held on file
	CardScheme EnergyPaymentScheduleCardDebitCardScheme `json:"cardScheme"`

	// PaymentFrequency The frequency that payments will occur.  Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	PaymentFrequency string `json:"paymentFrequency"`
}

// EnergyPaymentScheduleCardDebitCalculationType The mechanism by which the payment amount is calculated.  Explanation of values are as follows:<br/><ul><li>**STATIC** - Indicates a consistent, static amount, per payment</li><li>**BALANCE** - Indicates that the outstanding balance for the account is paid per period</li><li>**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm</li></ul>
type EnergyPaymentScheduleCardDebitCalculationType string

// EnergyPaymentScheduleCardDebitCardScheme The type of credit card held on file
type EnergyPaymentScheduleCardDebitCardScheme string

// EnergyPaymentScheduleDigitalWallet Represents a regular payment from a digital wallet. Mandatory if paymentScheduleUType is set to digitalWallet
type EnergyPaymentScheduleDigitalWallet struct {
	// CalculationType The mechanism by which the payment amount is calculated.  Explanation of values are as follows:<br/><ul><li>**STATIC** - Indicates a consistent, static amount, per payment</li><li>**BALANCE** - Indicates that the outstanding balance for the account is paid per period</li><li>**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm</li></ul>
	CalculationType EnergyPaymentScheduleDigitalWalletCalculationType `json:"calculationType"`

	// Identifier The identifier of the digital wallet (dependent on type)
	Identifier string `json:"identifier"`

	// Name The name assigned to the digital wallet by the owner of the wallet, else the display name provided by the digital wallet provider
	Name string `json:"name"`

	// PaymentFrequency The frequency that payments will occur.  Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	PaymentFrequency string `json:"paymentFrequency"`

	// Provider The provider of the digital wallet
	Provider EnergyPaymentScheduleDigitalWalletProvider `json:"provider"`

	// Type The type of the digital wallet identifier
	Type EnergyPaymentScheduleDigitalWalletType `json:"type"`
}

// EnergyPaymentScheduleDigitalWalletCalculationType The mechanism by which the payment amount is calculated.  Explanation of values are as follows:<br/><ul><li>**STATIC** - Indicates a consistent, static amount, per payment</li><li>**BALANCE** - Indicates that the outstanding balance for the account is paid per period</li><li>**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm</li></ul>
type EnergyPaymentScheduleDigitalWalletCalculationType string

// EnergyPaymentScheduleDigitalWalletProvider The provider of the digital wallet
type EnergyPaymentScheduleDigitalWalletProvider string

// EnergyPaymentScheduleDigitalWalletType The type of the digital wallet identifier
type EnergyPaymentScheduleDigitalWalletType string

// EnergyPaymentScheduleDirectDebit Represents a regular direct debit from a specified bank account. Mandatory if paymentScheduleUType is set to directDebit
type EnergyPaymentScheduleDirectDebit struct {
	// AccountNumber The unmasked account number for the account to be debited. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces.  Is required if isTokenised is absent or false
	AccountNumber *string `json:"accountNumber,omitempty"`

	// Bsb The unmasked BSB for the account to be debited. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces.  Is required if isTokenised is absent or false
	Bsb *string `json:"bsb,omitempty"`

	// CalculationType The mechanism by which the payment amount is calculated.  Explanation of values are as follows:<br/><ul><li>**STATIC** - Indicates a consistent, static amount, per payment</li><li>**BALANCE** - Indicates that the outstanding balance for the account is paid per period</li><li>**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm</li></ul>
	CalculationType EnergyPaymentScheduleDirectDebitCalculationType `json:"calculationType"`

	// IsTokenised Flag indicating that the account details are tokenised and cannot be shared.  False if absent
	IsTokenised *bool `json:"isTokenised,omitempty"`

	// PaymentFrequency The frequency that payments will occur.  Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	PaymentFrequency string `json:"paymentFrequency"`
}

// EnergyPaymentScheduleDirectDebitCalculationType The mechanism by which the payment amount is calculated.  Explanation of values are as follows:<br/><ul><li>**STATIC** - Indicates a consistent, static amount, per payment</li><li>**BALANCE** - Indicates that the outstanding balance for the account is paid per period</li><li>**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm</li></ul>
type EnergyPaymentScheduleDirectDebitCalculationType string

// EnergyPaymentScheduleManualPayment Represents a manual payment schedule where the customer pays in response to a delivered statement. Mandatory if paymentScheduleUType is set to manualPayment
type EnergyPaymentScheduleManualPayment struct {
	// BillFrequency The frequency with which a bill will be issued.  Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	BillFrequency string `json:"billFrequency"`
}

// EnergyPlan defines model for EnergyPlan.
type EnergyPlan struct {
	// AdditionalInformation Object that contains links to additional information on specific topics
	AdditionalInformation *EnergyPlanAdditionalInformation `json:"additionalInformation,omitempty"`

	// ApplicationUri A link to an application web page where this plan can be applied for
	ApplicationUri *string `json:"applicationUri,omitempty"`

	// Brand The ID of the brand under which this plan is offered
	Brand string `json:"brand"`

	// BrandName The display name of the brand under which this plan is offered
	BrandName string `json:"brandName"`

	// CustomerType The type of customer that the plan is offered to.  If absent then the plan is available to all customers
	CustomerType *EnergyPlanCustomerType `json:"customerType,omitempty"`

	// Description A description of the plan
	Description *string `json:"description,omitempty"`

	// DisplayName The display name of the plan
	DisplayName *string `json:"displayName,omitempty"`

	// EffectiveFrom The date and time from which this plan is effective (ie. is available for origination). Used to enable the articulation of products to the regime before they are available for customers to originate
	EffectiveFrom *string `json:"effectiveFrom,omitempty"`

	// EffectiveTo The date and time at which this plan will be retired and will no longer be offered. Used to enable the managed deprecation of plans
	EffectiveTo *string `json:"effectiveTo,omitempty"`

	// FuelType The fuel types covered by the plan
	FuelType EnergyPlanFuelType `json:"fuelType"`

	// Geography Describes the geographical area that the plan is available for.  If absent then it is assumed the plan is not geographically limited
	Geography *EnergyPlanGeography `json:"geography,omitempty"`

	// LastUpdated The last date and time that the information for this plan was changed (or the creation date for the plan if it has never been altered)
	LastUpdated string `json:"lastUpdated"`

	// PlanId The ID of the specific plan
	PlanId string `json:"planId"`

	// Type The type of the plan
	Type EnergyPlanType `json:"type"`
}

// EnergyPlanCustomerType The type of customer that the plan is offered to.  If absent then the plan is available to all customers
type EnergyPlanCustomerType string

// EnergyPlanFuelType The fuel types covered by the plan
type EnergyPlanFuelType string

// EnergyPlanType The type of the plan
type EnergyPlanType string

// EnergyPlanContractFullV2 defines model for EnergyPlanContractFullV2.
type EnergyPlanContractFullV2 struct {
	// AdditionalFeeInformation Free text field containing additional information of the fees for this contract
	AdditionalFeeInformation *string `json:"additionalFeeInformation,omitempty"`

	// BenefitPeriod Description of the benefit period.  Should only be present if termType has the value ONGOING
	BenefitPeriod *string `json:"benefitPeriod,omitempty"`

	// BillFrequency An array of the available billing schedules for this contract. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	BillFrequency []string `json:"billFrequency"`

	// ControlledLoad Required if pricing model is SINGLE_RATE_CONT_LOAD or TIME_OF_USE_CONT_LOAD or FLEXIBLE_CONT_LOAD
	ControlledLoad *EnergyPlanControlledLoad `json:"controlledLoad,omitempty"`

	// CoolingOffDays Number of days in the cooling off period for the contract.  Mandatory for plans with type of MARKET
	CoolingOffDays *int `json:"coolingOffDays,omitempty"`

	// Discounts Optional list of discounts available for the contract
	Discounts *EnergyPlanDiscounts `json:"discounts,omitempty"`

	// Eligibility Eligibility restrictions or requirements
	Eligibility *EnergyPlanEligibility `json:"eligibility,omitempty"`

	// Fees An array of fees applicable to the plan
	Fees *EnergyPlanFees `json:"fees,omitempty"`

	// GreenPowerCharges Optional list of charges applicable to green power
	GreenPowerCharges *EnergyPlanGreenPowerCharges `json:"greenPowerCharges,omitempty"`

	// Incentives Optional list of incentives available for the contract
	Incentives *EnergyPlanIncentives `json:"incentives,omitempty"`

	// IntrinsicGreenPower Describes intrinsic green power for the plan.  If present then the plan includes a percentage of green power in the base plan. Should not be present for gas contracts
	IntrinsicGreenPower *EnergyPlanContractV2IntrinsicGreenPower `json:"intrinsicGreenPower,omitempty"`

	// IsFixed Flag indicating whether prices are fixed or variable
	IsFixed bool `json:"isFixed"`

	// MeterTypes An array of the meter types that this contract is available for
	MeterTypes *[]string `json:"meterTypes,omitempty"`

	// OnExpiryDescription Free text field that describes what will occur on or prior to expiry of the fixed contract term or benefit period
	OnExpiryDescription *string `json:"onExpiryDescription,omitempty"`

	// PaymentOption Payment options for this contract
	PaymentOption []EnergyPlanContractFullV2PaymentOption `json:"paymentOption"`

	// PricingModel The pricing model for the contract.  Contracts for gas must use SINGLE_RATE.  Note that the detail for the enumeration values are:<ul><li>**SINGLE_RATE** - all energy usage is charged at a single unit rate no matter when it is consumed. Multiple unit rates may exist that correspond to varying volumes of usage i.e. a block or step tariff (first 50kWh @ X cents, next 50kWh at Y cents etc.</li><li>**SINGLE_RATE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**TIME_OF_USE** - energy usage is charged at unit rates that vary dependent on time of day and day of week that the energy is consumed</li><li>**TIME_OF_USE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**FLEXIBLE** - energy usage is charged at unit rates that vary based on external factors</li><li>**FLEXIBLE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**QUOTA** - all energy usage is charged at a single fixed rate, up to a specified usage quota/allowance. All excess usage beyond the allowance is then charged at a single unit rate (may not be the best way to explain it but it is essentially a subscription or telco style product i.e. $50/month for up to 150kWh included usage</li></ul>
	PricingModel EnergyPlanContractFullV2PricingModel `json:"pricingModel"`

	// SolarFeedInTariff Array of feed in tariffs for solar power
	SolarFeedInTariff *EnergyPlanSolarFeedInTariffV2 `json:"solarFeedInTariff,omitempty"`

	// TariffPeriod Array of tariff periods
	TariffPeriod EnergyPlanTariffPeriod `json:"tariffPeriod"`

	// TermType The term for the contract.  If absent assumes no specified term
	TermType *EnergyPlanContractFullV2TermType `json:"termType,omitempty"`

	// Terms Free text description of the terms for the contract
	Terms *string `json:"terms,omitempty"`

	// TimeZone Required if pricingModel is set to TIME_OF_USE.  Defines the time zone to use for calculation of the time of use thresholds. Defaults to AEST if absent
	TimeZone *EnergyPlanContractFullV2TimeZone `json:"timeZone,omitempty"`

	// Variation Free text description of price variation policy and conditions for the contract.  Mandatory if `isFixed` is false
	Variation *string `json:"variation,omitempty"`
}

// EnergyPlanContractFullV2PaymentOption defines model for EnergyPlanContractFullV2.PaymentOption.
type EnergyPlanContractFullV2PaymentOption string

// EnergyPlanContractFullV2PricingModel The pricing model for the contract.  Contracts for gas must use SINGLE_RATE.  Note that the detail for the enumeration values are:<ul><li>**SINGLE_RATE** - all energy usage is charged at a single unit rate no matter when it is consumed. Multiple unit rates may exist that correspond to varying volumes of usage i.e. a block or step tariff (first 50kWh @ X cents, next 50kWh at Y cents etc.</li><li>**SINGLE_RATE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**TIME_OF_USE** - energy usage is charged at unit rates that vary dependent on time of day and day of week that the energy is consumed</li><li>**TIME_OF_USE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**FLEXIBLE** - energy usage is charged at unit rates that vary based on external factors</li><li>**FLEXIBLE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**QUOTA** - all energy usage is charged at a single fixed rate, up to a specified usage quota/allowance. All excess usage beyond the allowance is then charged at a single unit rate (may not be the best way to explain it but it is essentially a subscription or telco style product i.e. $50/month for up to 150kWh included usage</li></ul>
type EnergyPlanContractFullV2PricingModel string

// EnergyPlanContractFullV2TermType The term for the contract.  If absent assumes no specified term
type EnergyPlanContractFullV2TermType string

// EnergyPlanContractFullV2TimeZone Required if pricingModel is set to TIME_OF_USE.  Defines the time zone to use for calculation of the time of use thresholds. Defaults to AEST if absent
type EnergyPlanContractFullV2TimeZone string

// EnergyPlanContractFullV2AllOf defines model for EnergyPlanContractFullV2_allOf.
type EnergyPlanContractFullV2AllOf struct {
	// BenefitPeriod Description of the benefit period.  Should only be present if termType has the value ONGOING
	BenefitPeriod *string `json:"benefitPeriod,omitempty"`

	// BillFrequency An array of the available billing schedules for this contract. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	BillFrequency []string `json:"billFrequency"`

	// CoolingOffDays Number of days in the cooling off period for the contract.  Mandatory for plans with type of MARKET
	CoolingOffDays *int `json:"coolingOffDays,omitempty"`

	// MeterTypes An array of the meter types that this contract is available for
	MeterTypes *[]string `json:"meterTypes,omitempty"`

	// TermType The term for the contract.  If absent assumes no specified term
	TermType *EnergyPlanContractFullV2AllOfTermType `json:"termType,omitempty"`

	// Terms Free text description of the terms for the contract
	Terms *string `json:"terms,omitempty"`
}

// EnergyPlanContractFullV2AllOfTermType The term for the contract.  If absent assumes no specified term
type EnergyPlanContractFullV2AllOfTermType string

// EnergyPlanContractV2 defines model for EnergyPlanContractV2.
type EnergyPlanContractV2 struct {
	// AdditionalFeeInformation Free text field containing additional information of the fees for this contract
	AdditionalFeeInformation *string `json:"additionalFeeInformation,omitempty"`

	// ControlledLoad Required if pricing model is SINGLE_RATE_CONT_LOAD or TIME_OF_USE_CONT_LOAD or FLEXIBLE_CONT_LOAD
	ControlledLoad *EnergyPlanControlledLoad `json:"controlledLoad,omitempty"`

	// Discounts Optional list of discounts available for the contract
	Discounts *EnergyPlanDiscounts `json:"discounts,omitempty"`

	// Eligibility Eligibility restrictions or requirements
	Eligibility *EnergyPlanEligibility `json:"eligibility,omitempty"`

	// Fees An array of fees applicable to the plan
	Fees *EnergyPlanFees `json:"fees,omitempty"`

	// GreenPowerCharges Optional list of charges applicable to green power
	GreenPowerCharges *EnergyPlanGreenPowerCharges `json:"greenPowerCharges,omitempty"`

	// Incentives Optional list of incentives available for the contract
	Incentives *EnergyPlanIncentives `json:"incentives,omitempty"`

	// IntrinsicGreenPower Describes intrinsic green power for the plan.  If present then the plan includes a percentage of green power in the base plan. Should not be present for gas contracts
	IntrinsicGreenPower *EnergyPlanContractV2IntrinsicGreenPower `json:"intrinsicGreenPower,omitempty"`

	// IsFixed Flag indicating whether prices are fixed or variable
	IsFixed bool `json:"isFixed"`

	// OnExpiryDescription Free text field that describes what will occur on or prior to expiry of the fixed contract term or benefit period
	OnExpiryDescription *string `json:"onExpiryDescription,omitempty"`

	// PaymentOption Payment options for this contract
	PaymentOption []EnergyPlanContractV2PaymentOption `json:"paymentOption"`

	// PricingModel The pricing model for the contract.  Contracts for gas must use SINGLE_RATE.  Note that the detail for the enumeration values are:<ul><li>**SINGLE_RATE** - all energy usage is charged at a single unit rate no matter when it is consumed. Multiple unit rates may exist that correspond to varying volumes of usage i.e. a block or step tariff (first 50kWh @ X cents, next 50kWh at Y cents etc.</li><li>**SINGLE_RATE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**TIME_OF_USE** - energy usage is charged at unit rates that vary dependent on time of day and day of week that the energy is consumed</li><li>**TIME_OF_USE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**FLEXIBLE** - energy usage is charged at unit rates that vary based on external factors</li><li>**FLEXIBLE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**QUOTA** - all energy usage is charged at a single fixed rate, up to a specified usage quota/allowance. All excess usage beyond the allowance is then charged at a single unit rate (may not be the best way to explain it but it is essentially a subscription or telco style product i.e. $50/month for up to 150kWh included usage</li></ul>
	PricingModel EnergyPlanContractV2PricingModel `json:"pricingModel"`

	// SolarFeedInTariff Array of feed in tariffs for solar power
	SolarFeedInTariff *EnergyPlanSolarFeedInTariffV2 `json:"solarFeedInTariff,omitempty"`

	// TariffPeriod Array of tariff periods
	TariffPeriod EnergyPlanTariffPeriod `json:"tariffPeriod"`

	// TimeZone Required if pricingModel is set to TIME_OF_USE.  Defines the time zone to use for calculation of the time of use thresholds. Defaults to AEST if absent
	TimeZone *EnergyPlanContractV2TimeZone `json:"timeZone,omitempty"`

	// Variation Free text description of price variation policy and conditions for the contract.  Mandatory if `isFixed` is false
	Variation *string `json:"variation,omitempty"`
}

// EnergyPlanContractV2PaymentOption defines model for EnergyPlanContractV2.PaymentOption.
type EnergyPlanContractV2PaymentOption string

// EnergyPlanContractV2PricingModel The pricing model for the contract.  Contracts for gas must use SINGLE_RATE.  Note that the detail for the enumeration values are:<ul><li>**SINGLE_RATE** - all energy usage is charged at a single unit rate no matter when it is consumed. Multiple unit rates may exist that correspond to varying volumes of usage i.e. a block or step tariff (first 50kWh @ X cents, next 50kWh at Y cents etc.</li><li>**SINGLE_RATE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**TIME_OF_USE** - energy usage is charged at unit rates that vary dependent on time of day and day of week that the energy is consumed</li><li>**TIME_OF_USE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**FLEXIBLE** - energy usage is charged at unit rates that vary based on external factors</li><li>**FLEXIBLE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**QUOTA** - all energy usage is charged at a single fixed rate, up to a specified usage quota/allowance. All excess usage beyond the allowance is then charged at a single unit rate (may not be the best way to explain it but it is essentially a subscription or telco style product i.e. $50/month for up to 150kWh included usage</li></ul>
type EnergyPlanContractV2PricingModel string

// EnergyPlanContractV2TimeZone Required if pricingModel is set to TIME_OF_USE.  Defines the time zone to use for calculation of the time of use thresholds. Defaults to AEST if absent
type EnergyPlanContractV2TimeZone string

// EnergyPlanContractV2IntrinsicGreenPower Describes intrinsic green power for the plan.  If present then the plan includes a percentage of green power in the base plan. Should not be present for gas contracts
type EnergyPlanContractV2IntrinsicGreenPower struct {
	// GreenPercentage Percentage of green power intrinsically included in the plan
	GreenPercentage string `json:"greenPercentage"`
}

// EnergyPlanControlledLoad Required if pricing model is SINGLE_RATE_CONT_LOAD or TIME_OF_USE_CONT_LOAD or FLEXIBLE_CONT_LOAD
type EnergyPlanControlledLoad = []struct {
	// DisplayName A display name for the controlled load
	DisplayName string `json:"displayName"`

	// EndDate Optional end date of the application of the controlled load rate
	EndDate *string `json:"endDate,omitempty"`

	// RateBlockUType Specifies the type of controlloed load rate
	RateBlockUType EnergyPlanControlledLoadRateBlockUType `json:"rateBlockUType"`

	// SingleRate Object representing a single controlled load rate.  Required if rateBlockUType is singleRate
	SingleRate *struct {
		// DailySupplyCharge The daily supply charge (exclusive of GST) for this controlled load tier
		DailySupplyCharge *string `json:"dailySupplyCharge,omitempty"`

		// Description Description of the controlled load rate
		Description *string `json:"description,omitempty"`

		// DisplayName Display name of the controlled load rate
		DisplayName string `json:"displayName"`

		// Rates Array of controlled load rates in order of usage volume
		Rates []struct {
			// MeasureUnit The measurement unit of rate. Assumed to be KWH if absent
			MeasureUnit *EnergyPlanControlledLoadSingleRateRatesMeasureUnit `json:"measureUnit,omitempty"`

			// UnitPrice Unit price of usage per  measure unit (exclusive of GST)
			UnitPrice string `json:"unitPrice"`

			// Volume Volume in kWh that this rate applies to.  Only applicable for stepped rates where different rates apply for different volumes of usage in a period
			Volume *float32 `json:"volume,omitempty"`
		} `json:"rates"`
	} `json:"singleRate,omitempty"`

	// StartDate Optional start date of the application of the controlled load rate
	StartDate *string `json:"startDate,omitempty"`

	// TimeOfUseRates Array of objects representing time of use rates.  Required if rateBlockUType is timeOfUseRates
	TimeOfUseRates *[]struct {
		// DailySupplyCharge The daily supply charge (exclusive of GST) for this controlled load tier
		DailySupplyCharge *string `json:"dailySupplyCharge,omitempty"`

		// Description Description of the controlled load rate
		Description *string `json:"description,omitempty"`

		// DisplayName Display name of the controlled load rate
		DisplayName string `json:"displayName"`

		// Rates Array of controlled load rates in order of usage volume
		Rates []struct {
			// MeasureUnit The measurement unit of rate. Assumed to be KWH if absent
			MeasureUnit *EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnit `json:"measureUnit,omitempty"`

			// UnitPrice Unit price of usage per  measure unit (exclusive of GST)
			UnitPrice string `json:"unitPrice"`

			// Volume Volume in kWh that this rate applies to.  Only applicable for stepped rates where different rates apply for different volumes of usage in a period
			Volume *float32 `json:"volume,omitempty"`
		} `json:"rates"`

		// TimeOfUse Array of times of use.
		TimeOfUse []struct {
			// AdditionalInfo Display text providing more information on the contrlled load, for e.g. controlled load availability if specific day/time is not known. Required if startTime and endTime absent or if additionalInfoUri provided
			AdditionalInfo *string `json:"additionalInfo,omitempty"`

			// AdditionalInfoUri Optional link to additional information regarding the controlled load
			AdditionalInfoUri *string `json:"additionalInfoUri,omitempty"`

			// Days The days that the rate applies to
			Days *[]EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDays `json:"days,omitempty"`

			// EndTime The end of the time period per day for which the controlled load rate applies. Required if startTime provided
			EndTime *string `json:"endTime,omitempty"`

			// StartTime The beginning of the time period per day for which the controlled load rate applies. Required if endTime provided
			StartTime *string `json:"startTime,omitempty"`
		} `json:"timeOfUse"`

		// Type The type of usage that the rate applies to
		Type EnergyPlanControlledLoadTimeOfUseRatesType `json:"type"`
	} `json:"timeOfUseRates,omitempty"`
}

// EnergyPlanControlledLoadRateBlockUType Specifies the type of controlloed load rate
type EnergyPlanControlledLoadRateBlockUType string

// EnergyPlanControlledLoadSingleRateRatesMeasureUnit The measurement unit of rate. Assumed to be KWH if absent
type EnergyPlanControlledLoadSingleRateRatesMeasureUnit string

// EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnit The measurement unit of rate. Assumed to be KWH if absent
type EnergyPlanControlledLoadTimeOfUseRatesRatesMeasureUnit string

// EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDays defines model for EnergyPlanControlledLoad.TimeOfUseRates.TimeOfUse.Days.
type EnergyPlanControlledLoadTimeOfUseRatesTimeOfUseDays string

// EnergyPlanControlledLoadTimeOfUseRatesType The type of usage that the rate applies to
type EnergyPlanControlledLoadTimeOfUseRatesType string

// EnergyPlanDetailV2 defines model for EnergyPlanDetailV2.
type EnergyPlanDetailV2 struct {
	// AdditionalInformation Object that contains links to additional information on specific topics
	AdditionalInformation *EnergyPlanAdditionalInformation `json:"additionalInformation,omitempty"`

	// ApplicationUri A link to an application web page where this plan can be applied for
	ApplicationUri *string `json:"applicationUri,omitempty"`

	// Brand The ID of the brand under which this plan is offered
	Brand string `json:"brand"`

	// BrandName The display name of the brand under which this plan is offered
	BrandName string `json:"brandName"`

	// CustomerType The type of customer that the plan is offered to.  If absent then the plan is available to all customers
	CustomerType *EnergyPlanDetailV2CustomerType `json:"customerType,omitempty"`

	// Description A description of the plan
	Description *string `json:"description,omitempty"`

	// DisplayName The display name of the plan
	DisplayName *string `json:"displayName,omitempty"`

	// EffectiveFrom The date and time from which this plan is effective (ie. is available for origination). Used to enable the articulation of products to the regime before they are available for customers to originate
	EffectiveFrom *string `json:"effectiveFrom,omitempty"`

	// EffectiveTo The date and time at which this plan will be retired and will no longer be offered. Used to enable the managed deprecation of plans
	EffectiveTo         *string                   `json:"effectiveTo,omitempty"`
	ElectricityContract *EnergyPlanContractFullV2 `json:"electricityContract,omitempty"`

	// FuelType The fuel types covered by the plan
	FuelType    EnergyPlanDetailV2FuelType `json:"fuelType"`
	GasContract *EnergyPlanContractFullV2  `json:"gasContract,omitempty"`

	// Geography Describes the geographical area that the plan is available for.  If absent then it is assumed the plan is not geographically limited
	Geography *EnergyPlanGeography `json:"geography,omitempty"`

	// LastUpdated The last date and time that the information for this plan was changed (or the creation date for the plan if it has never been altered)
	LastUpdated string `json:"lastUpdated"`

	// MeteringCharges Charges for metering included in the plan
	MeteringCharges *[]EnergyPlanDetailV2AllOfMeteringCharges `json:"meteringCharges,omitempty"`

	// PlanId The ID of the specific plan
	PlanId string `json:"planId"`

	// Type The type of the plan
	Type EnergyPlanDetailV2Type `json:"type"`
}

// EnergyPlanDetailV2CustomerType The type of customer that the plan is offered to.  If absent then the plan is available to all customers
type EnergyPlanDetailV2CustomerType string

// EnergyPlanDetailV2FuelType The fuel types covered by the plan
type EnergyPlanDetailV2FuelType string

// EnergyPlanDetailV2Type The type of the plan
type EnergyPlanDetailV2Type string

// EnergyPlanDetailV2AllOf defines model for EnergyPlanDetailV2_allOf.
type EnergyPlanDetailV2AllOf struct {
	ElectricityContract *EnergyPlanContractFullV2 `json:"electricityContract,omitempty"`
	GasContract         *EnergyPlanContractFullV2 `json:"gasContract,omitempty"`

	// MeteringCharges Charges for metering included in the plan
	MeteringCharges *[]EnergyPlanDetailV2AllOfMeteringCharges `json:"meteringCharges,omitempty"`
}

// EnergyPlanDetailV2AllOfMeteringCharges defines model for EnergyPlanDetailV2_allOf_meteringCharges.
type EnergyPlanDetailV2AllOfMeteringCharges struct {
	// Description Description of the charge
	Description *string `json:"description,omitempty"`

	// DisplayName Display name of the charge
	DisplayName string `json:"displayName"`

	// MaximumValue The upper limit of the charge if the charge could occur in a range
	MaximumValue *string `json:"maximumValue,omitempty"`

	// MinimumValue Minimum value of the charge if the charge is a range or the absolute value of the charge if no range is specified
	MinimumValue string `json:"minimumValue"`

	// Period The charges that occur on a schedule indicates the frequency. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
	Period *string `json:"period,omitempty"`
}

// EnergyPlanDiscounts Optional list of discounts available for the contract
type EnergyPlanDiscounts = []struct {
	// Category The type of the discount.  Mandatory if the discount type is CONDITIONAL
	Category *EnergyPlanDiscountsCategory `json:"category,omitempty"`

	// Description The description of the discount
	Description *string `json:"description,omitempty"`

	// DisplayName The display name of the discount
	DisplayName string `json:"displayName"`

	// EndDate Optional end date for the discount after which the discount is no longer available
	EndDate *string `json:"endDate,omitempty"`

	// FixedAmount Required if methodUType is fixedAmount
	FixedAmount *struct {
		// Amount The amount of the discount
		Amount string `json:"amount"`
	} `json:"fixedAmount,omitempty"`

	// MethodUType The method of calculation of the discount
	MethodUType EnergyPlanDiscountsMethodUType `json:"methodUType"`

	// PercentOfBill Required if methodUType is percentOfBill
	PercentOfBill *struct {
		// Rate The rate of the discount applied to the bill amount
		Rate string `json:"rate"`
	} `json:"percentOfBill,omitempty"`

	// PercentOfUse Required if methodUType is percentOfUse
	PercentOfUse *struct {
		// Rate The rate of the discount applied to the usageamount
		Rate string `json:"rate"`
	} `json:"percentOfUse,omitempty"`

	// PercentOverThreshold Required if methodUType is percentOverThreshold
	PercentOverThreshold *struct {
		// Rate The rate of the discount over the usage amount
		Rate string `json:"rate"`

		// UsageAmount The usage amount threshold above which the discount applies
		UsageAmount string `json:"usageAmount"`
	} `json:"percentOverThreshold,omitempty"`

	// Type The type of the discount
	Type EnergyPlanDiscountsType `json:"type"`
}

// EnergyPlanDiscountsCategory The type of the discount.  Mandatory if the discount type is CONDITIONAL
type EnergyPlanDiscountsCategory string

// EnergyPlanDiscountsMethodUType The method of calculation of the discount
type EnergyPlanDiscountsMethodUType string

// EnergyPlanDiscountsType The type of the discount
type EnergyPlanDiscountsType string

// EnergyPlanEligibility Eligibility restrictions or requirements
type EnergyPlanEligibility = []struct {
	// Description A description of the eligibility restriction
	Description *string `json:"description,omitempty"`

	// Information Information of the eligibility restriction specific to the type of the restriction
	Information string `json:"information"`

	// Type The type of the eligibility restriction.<br/>The CONTINGENT_PLAN value indicates that the plan is contingent on the customer taking up an alternate fuel plan from the same retailer (for instance, if the fuelType is ELECTRICITY then a GAS plan from the same retailer must be taken up)
	Type EnergyPlanEligibilityType `json:"type"`
}

// EnergyPlanEligibilityType The type of the eligibility restriction.<br/>The CONTINGENT_PLAN value indicates that the plan is contingent on the customer taking up an alternate fuel plan from the same retailer (for instance, if the fuelType is ELECTRICITY then a GAS plan from the same retailer must be taken up)
type EnergyPlanEligibilityType string

// EnergyPlanFees An array of fees applicable to the plan
type EnergyPlanFees = []struct {
	// Amount The fee amount. Required if term is not PERCENT_OF_BILL
	Amount *string `json:"amount,omitempty"`

	// Description A description of the fee
	Description *string `json:"description,omitempty"`

	// Rate The fee rate. Required if term is PERCENT_OF_BILL
	Rate *string `json:"rate,omitempty"`

	// Term The term of the fee
	Term EnergyPlanFeesTerm `json:"term"`

	// Type The type of the fee
	Type EnergyPlanFeesType `json:"type"`
}

// EnergyPlanFeesTerm The term of the fee
type EnergyPlanFeesTerm string

// EnergyPlanFeesType The type of the fee
type EnergyPlanFeesType string

// EnergyPlanGreenPowerCharges Optional list of charges applicable to green power
type EnergyPlanGreenPowerCharges = []struct {
	// Description The description of the charge
	Description *string `json:"description,omitempty"`

	// DisplayName The display name of the charge
	DisplayName string `json:"displayName"`

	// Scheme The applicable green power scheme
	Scheme EnergyPlanGreenPowerChargesScheme `json:"scheme"`

	// Tiers Array of charge tiers based on the percentage of green power used for the period implied by the type.  Array is in order of increasing percentage of green power
	Tiers []struct {
		// Amount The amount of the charge if the type implies the application of a fixed amount
		Amount *string `json:"amount,omitempty"`

		// PercentGreen The upper percentage of green power used applicable for this tier
		PercentGreen string `json:"percentGreen"`

		// Rate The rate of the charge if the type implies the application of a rate
		Rate *string `json:"rate,omitempty"`
	} `json:"tiers"`

	// Type The type of charge
	Type EnergyPlanGreenPowerChargesType `json:"type"`
}

// EnergyPlanGreenPowerChargesScheme The applicable green power scheme
type EnergyPlanGreenPowerChargesScheme string

// EnergyPlanGreenPowerChargesType The type of charge
type EnergyPlanGreenPowerChargesType string

// EnergyPlanIncentives Optional list of incentives available for the contract
type EnergyPlanIncentives = []struct {
	// Category The type of the incentive
	Category EnergyPlanIncentivesCategory `json:"category"`

	// Description The description of the incentive
	Description string `json:"description"`

	// DisplayName The display name of the incentive
	DisplayName string `json:"displayName"`

	// Eligibility A display message outlining an eligibility criteria that may apply
	Eligibility *string `json:"eligibility,omitempty"`
}

// EnergyPlanIncentivesCategory The type of the incentive
type EnergyPlanIncentivesCategory string

// EnergyPlanListResponse defines model for EnergyPlanListResponse.
type EnergyPlanListResponse struct {
	Data  EnergyPlanListResponseData `json:"data"`
	Links LinksPaginated             `json:"links"`
	Meta  MetaPaginated              `json:"meta"`
}

// EnergyPlanListResponseData defines model for EnergyPlanListResponse_data.
type EnergyPlanListResponseData struct {
	// Plans Array of plans
	Plans []EnergyPlan `json:"plans"`
}

// EnergyPlanResponseV2 defines model for EnergyPlanResponseV2.
type EnergyPlanResponseV2 struct {
	Data  EnergyPlanDetailV2 `json:"data"`
	Links Links              `json:"links"`
	Meta  *Meta              `json:"meta,omitempty"`
}

// EnergyPlanSolarFeedInTariffV2 Array of feed in tariffs for solar power
type EnergyPlanSolarFeedInTariffV2 = []struct {
	// Description A description of the tariff
	Description *string `json:"description,omitempty"`

	// DisplayName The name of the tariff
	DisplayName string `json:"displayName"`

	// EndDate The end date of the application of the feed in tariff
	EndDate *string `json:"endDate,omitempty"`

	// PayerType The type of the payer
	PayerType EnergyPlanSolarFeedInTariffV2PayerType `json:"payerType"`

	// Scheme The applicable scheme
	Scheme EnergyPlanSolarFeedInTariffV2Scheme `json:"scheme"`

	// SingleTariff Represents a constant tariff.  Mandatory if tariffUType is set to singleTariff
	SingleTariff *struct {
		// Rates Array of feed in rates
		Rates []struct {
			// MeasureUnit The measurement unit of rate. Assumed to be KWH if absent
			MeasureUnit *EnergyPlanSolarFeedInTariffV2SingleTariffRatesMeasureUnit `json:"measureUnit,omitempty"`

			// UnitPrice Unit price of usage per measure unit (exclusive of GST)
			UnitPrice string `json:"unitPrice"`

			// Volume Volume that this rate applies to. Only applicable for stepped rates where different rates apply for different volumes of usage in a period
			Volume *float32 `json:"volume,omitempty"`
		} `json:"rates"`
	} `json:"singleTariff,omitempty"`

	// StartDate The start date of the application of the feed in tariff
	StartDate *string `json:"startDate,omitempty"`

	// TariffUType The type of the payer
	TariffUType EnergyPlanSolarFeedInTariffV2TariffUType `json:"tariffUType"`

	// TimeVaryingTariffs Represents a tariff based on time.  Mandatory if tariffUType is set to timeVaryingTariffs
	TimeVaryingTariffs *struct {
		// Rates Array of feed in rates
		Rates *[]struct {
			// MeasureUnit The measurement unit of rate. Assumed to be KWH if absent
			MeasureUnit *EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsRatesMeasureUnit `json:"measureUnit,omitempty"`

			// UnitPrice Unit price of usage per measure unit (exclusive of GST)
			UnitPrice string `json:"unitPrice"`

			// Volume Volume that this rate applies to. Only applicable for stepped rates where different rates apply for different volumes of usage in a period
			Volume *float32 `json:"volume,omitempty"`
		} `json:"rates,omitempty"`

		// TimeVariations Array of time periods for which this tariff is applicable
		TimeVariations []struct {
			// Days The days that the tariff applies to. At least one entry required
			Days []EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsTimeVariationsDays `json:"days"`

			// EndTime The end of the time period per day for which the tariff applies.  If absent assumes end of day (ie. one second before midnight)
			EndTime *string `json:"endTime,omitempty"`

			// StartTime The beginning of the time period per day for which the tariff applies.  If absent assumes start of day (ie. midnight)
			StartTime *string `json:"startTime,omitempty"`
		} `json:"timeVariations"`

		// Type The type of the charging time period. If absent applies to all periods
		Type *EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsType `json:"type,omitempty"`
	} `json:"timeVaryingTariffs,omitempty"`
}

// EnergyPlanSolarFeedInTariffV2PayerType The type of the payer
type EnergyPlanSolarFeedInTariffV2PayerType string

// EnergyPlanSolarFeedInTariffV2Scheme The applicable scheme
type EnergyPlanSolarFeedInTariffV2Scheme string

// EnergyPlanSolarFeedInTariffV2SingleTariffRatesMeasureUnit The measurement unit of rate. Assumed to be KWH if absent
type EnergyPlanSolarFeedInTariffV2SingleTariffRatesMeasureUnit string

// EnergyPlanSolarFeedInTariffV2TariffUType The type of the payer
type EnergyPlanSolarFeedInTariffV2TariffUType string

// EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsRatesMeasureUnit The measurement unit of rate. Assumed to be KWH if absent
type EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsRatesMeasureUnit string

// EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsTimeVariationsDays defines model for EnergyPlanSolarFeedInTariffV2.TimeVaryingTariffs.TimeVariations.Days.
type EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsTimeVariationsDays string

// EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsType The type of the charging time period. If absent applies to all periods
type EnergyPlanSolarFeedInTariffV2TimeVaryingTariffsType string

// EnergyPlanTariffPeriod Array of tariff periods
type EnergyPlanTariffPeriod = []struct {
	// DailySupplyCharges The amount of access charge for the tariff period, in dollars per day exclusive of GST.
	DailySupplyCharges *string `json:"dailySupplyCharges,omitempty"`

	// DemandCharges Array of demand charges.  Required if rateBlockUType is demandCharges
	DemandCharges *[]struct {
		// Amount The charge amount per  measure unit exclusive of GST
		Amount string `json:"amount"`

		// ChargePeriod Charge period for the demand tariff
		ChargePeriod EnergyPlanTariffPeriodDemandChargesChargePeriod `json:"chargePeriod"`

		// Days The days that the demand tariff applies to
		Days *[]EnergyPlanTariffPeriodDemandChargesDays `json:"days,omitempty"`

		// Description Description of the charge
		Description *string `json:"description,omitempty"`

		// DisplayName Display name of the charge
		DisplayName string `json:"displayName"`

		// EndTime End of the period
		EndTime string `json:"endTime"`

		// MaxDemand Maximum demand for this demand tariff in kW.  If present, must be higher than the value of the minDemand field
		MaxDemand *string `json:"maxDemand,omitempty"`

		// MeasureUnit The measurement unit of charge amount. Assumed to be KWH if absent
		MeasureUnit *EnergyPlanTariffPeriodDemandChargesMeasureUnit `json:"measureUnit,omitempty"`

		// MeasurementPeriod Application period for the demand tariff
		MeasurementPeriod EnergyPlanTariffPeriodDemandChargesMeasurementPeriod `json:"measurementPeriod"`

		// MinDemand Minimum demand for this demand tariff in kW.  If absent then 0 is assumed
		MinDemand *string `json:"minDemand,omitempty"`

		// StartTime Start of the period
		StartTime string `json:"startTime"`
	} `json:"demandCharges,omitempty"`

	// DisplayName The name of the tariff period
	DisplayName string `json:"displayName"`

	// EndDate The end date of the tariff period in a calendar year.  Formatted in mm-dd format
	EndDate string `json:"endDate"`

	// RateBlockUType Specifies the type of rate applicable to this tariff period
	RateBlockUType EnergyPlanTariffPeriodRateBlockUType `json:"rateBlockUType"`

	// SingleRate Object representing a single rate.  Required if rateBlockUType is singleRate
	SingleRate *struct {
		// Description Description of the rate
		Description *string `json:"description,omitempty"`

		// DisplayName Display name of the rate
		DisplayName string `json:"displayName"`

		// GeneralUnitPrice The block rate (unit price) for any usage above the included fixed usage, in dollars per kWh inclusive of GST.  Only required if pricingModel field is QUOTA
		GeneralUnitPrice *string `json:"generalUnitPrice,omitempty"`

		// Period Usage period for which the block rate applies. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
		Period *string `json:"period,omitempty"`

		// Rates Array of controlled load rates in order of usage volume
		Rates []struct {
			// MeasureUnit The measurement unit of rate. Assumed to be KWH if absent
			MeasureUnit *EnergyPlanTariffPeriodSingleRateRatesMeasureUnit `json:"measureUnit,omitempty"`

			// UnitPrice Unit price of usage per measure unit (exclusive of GST)
			UnitPrice string `json:"unitPrice"`

			// Volume Volume in kWh that this rate applies to.  Only applicable for stepped rates where different rates apply for different volumes of usage in a period
			Volume *float32 `json:"volume,omitempty"`
		} `json:"rates"`
	} `json:"singleRate,omitempty"`

	// StartDate The start date of the tariff period in a calendar year.  Formatted in mm-dd format
	StartDate string `json:"startDate"`

	// TimeOfUseRates Array of objects representing time of use rates.  Required if rateBlockUType is timeOfUseRates
	TimeOfUseRates *[]struct {
		// Description Description of the rate
		Description *string `json:"description,omitempty"`

		// DisplayName Display name of the rate
		DisplayName string `json:"displayName"`

		// Rates Array of controlled load rates in order of usage volume
		Rates []struct {
			// MeasureUnit The measurement unit of rate. Assumed to be KWH if absent
			MeasureUnit *EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnit `json:"measureUnit,omitempty"`

			// UnitPrice Unit price of usage per  measure unit (exclusive of GST)
			UnitPrice string `json:"unitPrice"`

			// Volume Volume in kWh that this rate applies to.  Only applicable for stepped rates where different rates apply for different volumes of usage in a period
			Volume *float32 `json:"volume,omitempty"`
		} `json:"rates"`

		// TimeOfUse Array of times of use
		TimeOfUse []struct {
			// Days The days that the rate applies to
			Days []EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDays `json:"days"`

			// EndTime End of the period
			EndTime string `json:"endTime"`

			// StartTime Start of the period
			StartTime string `json:"startTime"`
		} `json:"timeOfUse"`

		// Type The type of usage that the rate applies to
		Type EnergyPlanTariffPeriodTimeOfUseRatesType `json:"type"`
	} `json:"timeOfUseRates,omitempty"`

	// TimeZone Specifies the charge specific time zone for calculation of the time of use thresholds. If absent, timezone value in EnergyPlanContract is assumed.
	TimeZone *EnergyPlanTariffPeriodTimeZone `json:"timeZone,omitempty"`

	// Type Type of charge. Assumed to be other if absent
	Type *EnergyPlanTariffPeriodType `json:"type,omitempty"`
}

// EnergyPlanTariffPeriodDemandChargesChargePeriod Charge period for the demand tariff
type EnergyPlanTariffPeriodDemandChargesChargePeriod string

// EnergyPlanTariffPeriodDemandChargesDays defines model for EnergyPlanTariffPeriod.DemandCharges.Days.
type EnergyPlanTariffPeriodDemandChargesDays string

// EnergyPlanTariffPeriodDemandChargesMeasureUnit The measurement unit of charge amount. Assumed to be KWH if absent
type EnergyPlanTariffPeriodDemandChargesMeasureUnit string

// EnergyPlanTariffPeriodDemandChargesMeasurementPeriod Application period for the demand tariff
type EnergyPlanTariffPeriodDemandChargesMeasurementPeriod string

// EnergyPlanTariffPeriodRateBlockUType Specifies the type of rate applicable to this tariff period
type EnergyPlanTariffPeriodRateBlockUType string

// EnergyPlanTariffPeriodSingleRateRatesMeasureUnit The measurement unit of rate. Assumed to be KWH if absent
type EnergyPlanTariffPeriodSingleRateRatesMeasureUnit string

// EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnit The measurement unit of rate. Assumed to be KWH if absent
type EnergyPlanTariffPeriodTimeOfUseRatesRatesMeasureUnit string

// EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDays defines model for EnergyPlanTariffPeriod.TimeOfUseRates.TimeOfUse.Days.
type EnergyPlanTariffPeriodTimeOfUseRatesTimeOfUseDays string

// EnergyPlanTariffPeriodTimeOfUseRatesType The type of usage that the rate applies to
type EnergyPlanTariffPeriodTimeOfUseRatesType string

// EnergyPlanTariffPeriodTimeZone Specifies the charge specific time zone for calculation of the time of use thresholds. If absent, timezone value in EnergyPlanContract is assumed.
type EnergyPlanTariffPeriodTimeZone string

// EnergyPlanTariffPeriodType Type of charge. Assumed to be other if absent
type EnergyPlanTariffPeriodType string

// EnergyPlanAdditionalInformation Object that contains links to additional information on specific topics
type EnergyPlanAdditionalInformation struct {
	// BundleUri A link to detail on bundles that this plan can be a part of
	BundleUri *string `json:"bundleUri,omitempty"`

	// EligibilityUri A link to detail on eligibility criteria for the plan
	EligibilityUri *string `json:"eligibilityUri,omitempty"`

	// OverviewUri A link to a general overview of the plan
	OverviewUri *string `json:"overviewUri,omitempty"`

	// PricingUri A link to detail on pricing for the plan
	PricingUri *string `json:"pricingUri,omitempty"`

	// TermsUri A link to terms and conditions for the plan
	TermsUri *string `json:"termsUri,omitempty"`
}

// EnergyPlanGeography Describes the geographical area that the plan is available for.  If absent then it is assumed the plan is not geographically limited
type EnergyPlanGeography struct {
	// Distributors Array of distributors for the plan. Must have at least one entry
	Distributors []string `json:"distributors"`

	// ExcludedPostcodes Array of valid Australian postcodes that are specifically excluded from the plan.  Each element is a single four digit postcode (e.g. 3000) or a range of postcodes defined by two four digit postcodes and a hyphen (e.g. 3000-3999)
	ExcludedPostcodes *[]string `json:"excludedPostcodes,omitempty"`

	// IncludedPostcodes Array of valid Australian postcodes that are included from the plan.  If absent defaults to all non-excluded postcodes.  Each element is a single four digit postcode (e.g. 3000) or a range of postcodes defined by two four digit postcodes and a hyphen (e.g. 3000-3999)
	IncludedPostcodes *[]string `json:"includedPostcodes,omitempty"`
}

// EnergyServicePoint defines model for EnergyServicePoint.
type EnergyServicePoint struct {
	ConsumerProfile *EnergyServicePointConsumerProfile `json:"consumerProfile,omitempty"`

	// IsGenerator This flag determines whether the energy at this connection point is to be treated as consumer load or as a generating unit(this may include generator auxiliary loads). If absent defaults to false. <br>**Note:** Only applicable for scheduled or semischeduled generators, does not indicate on site generation by consumer
	IsGenerator *bool `json:"isGenerator,omitempty"`

	// JurisdictionCode Jurisdiction code to which the service point belongs.This code defines the jurisdictional rules which apply to the service point. Note the details of enumeration values below:<ul><li>**ALL** - All Jurisdictions</li><li>**ACT** - Australian Capital Territory</li><li>**NEM** - National Electricity Market</li><li>**NSW** - New South Wales</li><li>**QLD** - Queensland</li><li>**SA** - South Australia</li><li>**TAS** - Tasmania</li><li>**VIC** - Victoria</li></ul>
	JurisdictionCode EnergyServicePointJurisdictionCode `json:"jurisdictionCode"`

	// LastUpdateDateTime The date and time that the information for this service point was modified
	LastUpdateDateTime string `json:"lastUpdateDateTime"`

	// NationalMeteringId The independent ID of the service point, known in the industry as the NMI
	NationalMeteringId string `json:"nationalMeteringId"`

	// ServicePointClassification The classification of the service point as defined in MSATS procedures
	ServicePointClassification EnergyServicePointServicePointClassification `json:"servicePointClassification"`

	// ServicePointId Tokenised ID of the service point to be used for referring to the service point in the CDR API suite. To be created in accordance with CDR ID permanence requirements
	ServicePointId string `json:"servicePointId"`

	// ServicePointStatus Code used to indicate the status of the service point. Note the details for the enumeration values below:<ul><li>**ACTIVE** - An active, energised, service point</li><li>**DE_ENERGISED** - The service point exists but is deenergised</li><li>**EXTINCT** - The service point has been permanently decommissioned</li><li>**GREENFIELD** - Applies to a service point that has never been energised</li><li>**OFF_MARKET** - Applies when the service point is no longer settled in the NEM</li></ul>
	ServicePointStatus EnergyServicePointServicePointStatus `json:"servicePointStatus"`

	// ValidFromDate The latest start date from which the constituent data sets of this service point became valid
	ValidFromDate string `json:"validFromDate"`
}

// EnergyServicePointJurisdictionCode Jurisdiction code to which the service point belongs.This code defines the jurisdictional rules which apply to the service point. Note the details of enumeration values below:<ul><li>**ALL** - All Jurisdictions</li><li>**ACT** - Australian Capital Territory</li><li>**NEM** - National Electricity Market</li><li>**NSW** - New South Wales</li><li>**QLD** - Queensland</li><li>**SA** - South Australia</li><li>**TAS** - Tasmania</li><li>**VIC** - Victoria</li></ul>
type EnergyServicePointJurisdictionCode string

// EnergyServicePointServicePointClassification The classification of the service point as defined in MSATS procedures
type EnergyServicePointServicePointClassification string

// EnergyServicePointServicePointStatus Code used to indicate the status of the service point. Note the details for the enumeration values below:<ul><li>**ACTIVE** - An active, energised, service point</li><li>**DE_ENERGISED** - The service point exists but is deenergised</li><li>**EXTINCT** - The service point has been permanently decommissioned</li><li>**GREENFIELD** - Applies to a service point that has never been energised</li><li>**OFF_MARKET** - Applies when the service point is no longer settled in the NEM</li></ul>
type EnergyServicePointServicePointStatus string

// EnergyServicePointDetail defines model for EnergyServicePointDetail.
type EnergyServicePointDetail struct {
	ConsumerProfile        *EnergyServicePointConsumerProfile             `json:"consumerProfile,omitempty"`
	DistributionLossFactor EnergyServicePointDetailDistributionLossFactor `json:"distributionLossFactor"`

	// IsGenerator This flag determines whether the energy at this connection point is to be treated as consumer load or as a generating unit(this may include generator auxiliary loads). If absent defaults to false. <br>**Note:** Only applicable for scheduled or semischeduled generators, does not indicate on site generation by consumer
	IsGenerator *bool `json:"isGenerator,omitempty"`

	// JurisdictionCode Jurisdiction code to which the service point belongs.This code defines the jurisdictional rules which apply to the service point. Note the details of enumeration values below:<ul><li>**ALL** - All Jurisdictions</li><li>**ACT** - Australian Capital Territory</li><li>**NEM** - National Electricity Market</li><li>**NSW** - New South Wales</li><li>**QLD** - Queensland</li><li>**SA** - South Australia</li><li>**TAS** - Tasmania</li><li>**VIC** - Victoria</li></ul>
	JurisdictionCode EnergyServicePointDetailJurisdictionCode `json:"jurisdictionCode"`

	// LastUpdateDateTime The date and time that the information for this service point was modified
	LastUpdateDateTime string                `json:"lastUpdateDateTime"`
	Location           CommonPhysicalAddress `json:"location"`

	// Meters The meters associated with the service point. This may be empty where there are no meters physically installed at the service point
	Meters *[]EnergyServicePointDetailMeters `json:"meters,omitempty"`

	// NationalMeteringId The independent ID of the service point, known in the industry as the NMI
	NationalMeteringId  string                                        `json:"nationalMeteringId"`
	RelatedParticipants []EnergyServicePointDetailRelatedParticipants `json:"relatedParticipants"`

	// ServicePointClassification The classification of the service point as defined in MSATS procedures
	ServicePointClassification EnergyServicePointDetailServicePointClassification `json:"servicePointClassification"`

	// ServicePointId The tokenised ID of the service point for use in the CDR APIs.  Created according to the CDR rules for ID permanence
	ServicePointId string `json:"servicePointId"`

	// ServicePointStatus Code used to indicate the status of the service point. Note the details for the enumeration values below:<ul><li>**ACTIVE** - An active, energised, service point</li><li>**DE_ENERGISED** - The service point exists but is deenergised</li><li>**EXTINCT** - The service point has been permanently decommissioned</li><li>**GREENFIELD** - Applies to a service point that has never been energised</li><li>**OFF_MARKET** - Applies when the service point is no longer settled in the NEM</li></ul>
	ServicePointStatus EnergyServicePointDetailServicePointStatus `json:"servicePointStatus"`

	// ValidFromDate The latest start date from which the constituent data sets of this service point became valid
	ValidFromDate string `json:"validFromDate"`
}

// EnergyServicePointDetailJurisdictionCode Jurisdiction code to which the service point belongs.This code defines the jurisdictional rules which apply to the service point. Note the details of enumeration values below:<ul><li>**ALL** - All Jurisdictions</li><li>**ACT** - Australian Capital Territory</li><li>**NEM** - National Electricity Market</li><li>**NSW** - New South Wales</li><li>**QLD** - Queensland</li><li>**SA** - South Australia</li><li>**TAS** - Tasmania</li><li>**VIC** - Victoria</li></ul>
type EnergyServicePointDetailJurisdictionCode string

// EnergyServicePointDetailServicePointClassification The classification of the service point as defined in MSATS procedures
type EnergyServicePointDetailServicePointClassification string

// EnergyServicePointDetailServicePointStatus Code used to indicate the status of the service point. Note the details for the enumeration values below:<ul><li>**ACTIVE** - An active, energised, service point</li><li>**DE_ENERGISED** - The service point exists but is deenergised</li><li>**EXTINCT** - The service point has been permanently decommissioned</li><li>**GREENFIELD** - Applies to a service point that has never been energised</li><li>**OFF_MARKET** - Applies when the service point is no longer settled in the NEM</li></ul>
type EnergyServicePointDetailServicePointStatus string

// EnergyServicePointDetailResponse defines model for EnergyServicePointDetailResponse.
type EnergyServicePointDetailResponse struct {
	Data  EnergyServicePointDetail `json:"data"`
	Links Links                    `json:"links"`
	Meta  *Meta                    `json:"meta,omitempty"`
}

// EnergyServicePointDetailDistributionLossFactor defines model for EnergyServicePointDetail_distributionLossFactor.
type EnergyServicePointDetailDistributionLossFactor struct {
	// Code A code used to identify data loss factor for the service point values.  Refer to AEMO distribution loss factor documents for each financial year to interpret
	Code string `json:"code"`

	// Description Description of the data loss factor code and value
	Description string `json:"description"`

	// LossValue The value associated with the loss factor code
	LossValue string `json:"lossValue"`
}

// EnergyServicePointDetailMeters defines model for EnergyServicePointDetail_meters.
type EnergyServicePointDetailMeters struct {
	// MeterId The meter ID uniquely identifies a meter for a given service point.  It is unique in the context of the service point.  It is not globally unique
	MeterId string `json:"meterId"`

	// Registers Usage data registers available from the meter. This may be empty where there are no meters physically installed at the service point
	Registers *[]EnergyServicePointDetailRegisters `json:"registers,omitempty"`

	// Specifications Technical characteristics of the meter
	Specifications EnergyServicePointDetailSpecifications `json:"specifications"`
}

// EnergyServicePointDetailRegisters defines model for EnergyServicePointDetail_registers.
type EnergyServicePointDetailRegisters struct {
	// AveragedDailyLoad The energy delivered through a connection point or metering point over an extended period normalised to a 'per day' basis (kWh). This value is calculated annually.
	AveragedDailyLoad *float32 `json:"averagedDailyLoad,omitempty"`

	// ConsumptionType Actual/Subtractive Indicator. Note the details of enumeration values below: <ul><li>**ACTUAL** implies volume of energy actually metered between two dates</li><li>**CUMULATIVE** indicates a meter reading for a specific date. A second Meter Reading is required to determine the consumption between those two Meter Reading dates</li></ul>
	ConsumptionType *EnergyServicePointDetailRegistersConsumptionType `json:"consumptionType,omitempty"`

	// ControlledLoad Indicates whether the energy recorded by this register is created under a Controlled Load regime
	ControlledLoad *bool `json:"controlledLoad,omitempty"`

	// Multiplier Multiplier required to take a register value and turn it into a value representing billable energy
	Multiplier *float32 `json:"multiplier,omitempty"`

	// NetworkTariffCode The Network Tariff Code is a free text field containing a code supplied and published by the local network service provider
	NetworkTariffCode *string `json:"networkTariffCode,omitempty"`

	// RegisterConsumptionType Indicates the consumption type of register
	RegisterConsumptionType EnergyServicePointDetailRegistersRegisterConsumptionType `json:"registerConsumptionType"`

	// RegisterId Unique identifier of the register within this service point.  Is not globally unique
	RegisterId string `json:"registerId"`

	// RegisterSuffix Register suffix of the meter register where the meter reads are obtained
	RegisterSuffix *string `json:"registerSuffix,omitempty"`

	// TimeOfDay Code to identify the time validity of register contents
	TimeOfDay *EnergyServicePointDetailRegistersTimeOfDay `json:"timeOfDay,omitempty"`

	// UnitOfMeasure The unit of measure for data held in this register
	UnitOfMeasure *string `json:"unitOfMeasure,omitempty"`
}

// EnergyServicePointDetailRegistersConsumptionType Actual/Subtractive Indicator. Note the details of enumeration values below: <ul><li>**ACTUAL** implies volume of energy actually metered between two dates</li><li>**CUMULATIVE** indicates a meter reading for a specific date. A second Meter Reading is required to determine the consumption between those two Meter Reading dates</li></ul>
type EnergyServicePointDetailRegistersConsumptionType string

// EnergyServicePointDetailRegistersRegisterConsumptionType Indicates the consumption type of register
type EnergyServicePointDetailRegistersRegisterConsumptionType string

// EnergyServicePointDetailRegistersTimeOfDay Code to identify the time validity of register contents
type EnergyServicePointDetailRegistersTimeOfDay string

// EnergyServicePointDetailRelatedParticipants defines model for EnergyServicePointDetail_relatedParticipants.
type EnergyServicePointDetailRelatedParticipants struct {
	// Party The name of the party/organisation related to this service point
	Party string `json:"party"`

	// Role The role performed by this participant in relation to the service point. Note the details of enumeration values below: <ul><li>**FRMP** - Financially Responsible Market Participant</li><li>**LNSP** - Local Network Service Provider or Embedded Network Manager for child connection points</li><li>**DRSP** - wholesale Demand Response and/or market ancillary Service Provider and note that where it is not relevant for a NMI it will not be included</li></ul>
	Role EnergyServicePointDetailRelatedParticipantsRole `json:"role"`
}

// EnergyServicePointDetailRelatedParticipantsRole The role performed by this participant in relation to the service point. Note the details of enumeration values below: <ul><li>**FRMP** - Financially Responsible Market Participant</li><li>**LNSP** - Local Network Service Provider or Embedded Network Manager for child connection points</li><li>**DRSP** - wholesale Demand Response and/or market ancillary Service Provider and note that where it is not relevant for a NMI it will not be included</li></ul>
type EnergyServicePointDetailRelatedParticipantsRole string

// EnergyServicePointDetailSpecifications Technical characteristics of the meter
type EnergyServicePointDetailSpecifications struct {
	// InstallationType The metering Installation type code indicates whether the metering installation has to be manually read. Note the details of enumeration values below: <ul><li>**BASIC** - Accumulation Meter  Type 6</li><li>**COMMS1** - Interval Meter with communications  Type 1</li><li>**COMMS2** - Interval Meter with communications  Type 2</li><li>**COMMS3** - Interval Meter with communications  Type 3</li><li>**COMMS4** - Interval Meter with communications  Type 4</li><li>**COMMS4C** - CT connected metering installation that meets the minimum services specifications</li><li>**COMMS4D** - Whole current metering installation that meets the minimum services specifications</li><li>**MRAM** - Small customer metering installation  Type 4A</li><li>**MRIM** - Manually Read Interval Meter  Type 5</li><li>**UMCP** - Unmetered Supply  Type 7</li><li>**VICAMI** - A relevant metering installation as defined in clause 9.9C of the NER</li><li>**NCONUML** - Non-contestable unmeter load - Introduced as part of Global Settlement</li></ul>
	InstallationType EnergyServicePointDetailSpecificationsInstallationType `json:"installationType"`

	// Manufacturer Free text field to identify the manufacturer of the installed meter
	Manufacturer *string `json:"manufacturer,omitempty"`

	// Model Free text field to identify the meter manufacturers designation for the meter model
	Model *string `json:"model,omitempty"`

	// NextScheduledReadDate This date is the next scheduled meter read date (NSRD) if a manual Meter Reading is required
	NextScheduledReadDate *string `json:"nextScheduledReadDate,omitempty"`

	// ReadType Code to denote the method and frequency of Meter Reading. The value is formatted as follows: <ul><li>First Character = Remote (R) or Manual (M)</li><li>Second Character = Mode: T = telephone W = wireless P = powerline I = infra-red G = galvanic V = visual </li><li>Third Character = Frequency of Scheduled Meter Readings: 1 = Twelve times per year 2 = Six times per year 3 = Four times per year D = Daily or weekly</li><li>Optional Fourth Character = to identify what interval length the meter is capable of reading. This includes five, 15 and 30 minute granularity as the following: A  5 minute B  15 minute C  30 minute D  Cannot convert to 5 minute (i.e. due to metering installation de-energised) M - Manually Read Accumulation Meter</li></ul> For example, <ul><li>MV3 = Manual, Visual, Quarterly</li> <li>MV3M = Manual, Visual, Quarterly, Manually Read Accumulation Meter</li> <li>RWDC = Remote, Wireless, Daily, 30 minutes interval</li></ul>
	ReadType *string `json:"readType,omitempty"`

	// Status A code to denote the status of the meter. Note the details of enumeration values below: <ul><li>**CURRENT** -Applies when a meter is current and not disconnected</li><li>**DISCONNECTED** - Applies when a meter is present but has been remotely disconnected</li></ul>
	Status EnergyServicePointDetailSpecificationsStatus `json:"status"`
}

// EnergyServicePointDetailSpecificationsInstallationType The metering Installation type code indicates whether the metering installation has to be manually read. Note the details of enumeration values below: <ul><li>**BASIC** - Accumulation Meter  Type 6</li><li>**COMMS1** - Interval Meter with communications  Type 1</li><li>**COMMS2** - Interval Meter with communications  Type 2</li><li>**COMMS3** - Interval Meter with communications  Type 3</li><li>**COMMS4** - Interval Meter with communications  Type 4</li><li>**COMMS4C** - CT connected metering installation that meets the minimum services specifications</li><li>**COMMS4D** - Whole current metering installation that meets the minimum services specifications</li><li>**MRAM** - Small customer metering installation  Type 4A</li><li>**MRIM** - Manually Read Interval Meter  Type 5</li><li>**UMCP** - Unmetered Supply  Type 7</li><li>**VICAMI** - A relevant metering installation as defined in clause 9.9C of the NER</li><li>**NCONUML** - Non-contestable unmeter load - Introduced as part of Global Settlement</li></ul>
type EnergyServicePointDetailSpecificationsInstallationType string

// EnergyServicePointDetailSpecificationsStatus A code to denote the status of the meter. Note the details of enumeration values below: <ul><li>**CURRENT** -Applies when a meter is current and not disconnected</li><li>**DISCONNECTED** - Applies when a meter is present but has been remotely disconnected</li></ul>
type EnergyServicePointDetailSpecificationsStatus string

// EnergyServicePointListResponse defines model for EnergyServicePointListResponse.
type EnergyServicePointListResponse struct {
	Data  EnergyServicePointListResponseData `json:"data"`
	Links LinksPaginated                     `json:"links"`
	Meta  MetaPaginated                      `json:"meta"`
}

// EnergyServicePointListResponseData defines model for EnergyServicePointListResponse_data.
type EnergyServicePointListResponseData struct {
	ServicePoints []EnergyServicePoint `json:"servicePoints"`
}

// EnergyServicePointConsumerProfile defines model for EnergyServicePoint_consumerProfile.
type EnergyServicePointConsumerProfile struct {
	// Classification A code that defines the consumer class as defined in the National Energy Retail Regulations, or in overriding Jurisdictional instruments
	Classification *EnergyServicePointConsumerProfileClassification `json:"classification,omitempty"`

	// Threshold A code that defines the consumption threshold as defined in the National Energy Retail Regulations, or in overriding Jurisdictional instruments. Note the details of enumeration values below: <ul><li>**LOW** - Consumption is less than the lower consumption threshold as defined in the National Energy Retail Regulations</li><li>**MEDIUM** - Consumption is equal to or greater than the lower consumption threshold, but less than the upper consumption threshold, as defined in the National Energy Retail Regulations</li><li>**HIGH** - Consumption is equal to or greater than the upper consumption threshold as defined in the National Energy Retail Regulations</li></ul>
	Threshold *EnergyServicePointConsumerProfileThreshold `json:"threshold,omitempty"`
}

// EnergyServicePointConsumerProfileClassification A code that defines the consumer class as defined in the National Energy Retail Regulations, or in overriding Jurisdictional instruments
type EnergyServicePointConsumerProfileClassification string

// EnergyServicePointConsumerProfileThreshold A code that defines the consumption threshold as defined in the National Energy Retail Regulations, or in overriding Jurisdictional instruments. Note the details of enumeration values below: <ul><li>**LOW** - Consumption is less than the lower consumption threshold as defined in the National Energy Retail Regulations</li><li>**MEDIUM** - Consumption is equal to or greater than the lower consumption threshold, but less than the upper consumption threshold, as defined in the National Energy Retail Regulations</li><li>**HIGH** - Consumption is equal to or greater than the upper consumption threshold as defined in the National Energy Retail Regulations</li></ul>
type EnergyServicePointConsumerProfileThreshold string

// EnergyUsageListResponse defines model for EnergyUsageListResponse.
type EnergyUsageListResponse struct {
	Data  EnergyUsageListResponseData `json:"data"`
	Links LinksPaginated              `json:"links"`
	Meta  MetaPaginated               `json:"meta"`
}

// EnergyUsageListResponseData defines model for EnergyUsageListResponse_data.
type EnergyUsageListResponseData struct {
	// Reads Array of meter reads sorted by NMI in ascending order followed by readStartDate in descending order
	Reads []EnergyUsageRead `json:"reads"`
}

// EnergyUsageRead defines model for EnergyUsageRead.
type EnergyUsageRead struct {
	// BasicRead Mandatory if readUType is set to basicRead
	BasicRead *EnergyUsageReadBasicRead `json:"basicRead,omitempty"`

	// ControlledLoad Indicates whether the energy recorded by this register is created under a Controlled Load regime
	ControlledLoad *bool `json:"controlledLoad,omitempty"`

	// IntervalRead Mandatory if readUType is set to intervalRead
	IntervalRead *EnergyUsageReadIntervalRead `json:"intervalRead,omitempty"`

	// MeterId Meter id/serial number as it appears in customers bill. ID permanence rules do not apply.
	MeterId *string `json:"meterId,omitempty"`

	// ReadEndDate Date when the meter reads end in AEST.  If absent then assumed to be equal to readStartDate.  In this case the entry represents data for a single date specified by readStartDate.
	ReadEndDate *string `json:"readEndDate,omitempty"`

	// ReadStartDate Date when the meter reads start in AEST and assumed to start from 12:00 am AEST.
	ReadStartDate string `json:"readStartDate"`

	// ReadUType Specify the type of the meter read data
	ReadUType EnergyUsageReadReadUType `json:"readUType"`

	// RegisterId Register ID of the meter register where the meter reads are obtained
	RegisterId *string `json:"registerId,omitempty"`

	// RegisterSuffix Register suffix of the meter register where the meter reads are obtained
	RegisterSuffix string `json:"registerSuffix"`

	// ServicePointId Tokenised ID of the service point to be used for referring to the service point in the CDR API suite.  To be created in accordance with CDR ID permanence requirements
	ServicePointId string `json:"servicePointId"`

	// UnitOfMeasure Unit of measure of the meter reads. Refer to Appendix B of <a href='https://www.aemo.com.au/-/media/files/stakeholder_consultation/consultations/nem-consultations/2019/5ms-metering-package-2/final-determination/mdff-specification-nem12-nem13-v21-final-determination-clean.pdf?la=en&hash=03FCBA0D60E091DE00F2361AE76206EA'>MDFF Specification NEM12 NEM13 v2.1</a> for a list of possible values.
	UnitOfMeasure *string `json:"unitOfMeasure,omitempty"`
}

// EnergyUsageReadReadUType Specify the type of the meter read data
type EnergyUsageReadReadUType string

// EnergyUsageReadBasicRead Mandatory if readUType is set to basicRead
type EnergyUsageReadBasicRead struct {
	// Quality The quality of the read taken.  If absent then assumed to be ACTUAL
	Quality *EnergyUsageReadBasicReadQuality `json:"quality,omitempty"`

	// Value Meter read value.  If positive then it means consumption, if negative it means export
	Value float32 `json:"value"`
}

// EnergyUsageReadBasicReadQuality The quality of the read taken.  If absent then assumed to be ACTUAL
type EnergyUsageReadBasicReadQuality string

// EnergyUsageReadIntervalRead Mandatory if readUType is set to intervalRead
type EnergyUsageReadIntervalRead struct {
	// AggregateValue The aggregate sum of the interval read values. If positive then it means net consumption, if negative it means net export
	AggregateValue float32 `json:"aggregateValue"`

	// IntervalReads Array of Interval read values. If positive then it means consumption, if negative it means export. Required when interval-reads query parameter equals FULL or  MIN_30.<br>Each read value indicates the read for the interval specified by readIntervalLength beginning at midnight of readStartDate (for example 00:00 to 00:30 would be the first reading in a 30 minute Interval)
	IntervalReads *[]float32 `json:"intervalReads,omitempty"`

	// ReadIntervalLength Read interval length in minutes. Required when interval-reads query parameter equals FULL or MIN_30
	ReadIntervalLength *int `json:"readIntervalLength,omitempty"`

	// ReadQualities  Specifies quality of reads that are not ACTUAL.  For read indices that are not specified, quality is assumed to be ACTUAL. If not present, all quality of all reads are assumed to be actual. Required when interval-reads query parameter equals FULL or MIN_30
	ReadQualities *[]EnergyUsageReadIntervalReadReadQualities `json:"readQualities,omitempty"`
}

// EnergyUsageReadIntervalReadReadQualities defines model for EnergyUsageRead_intervalRead_readQualities.
type EnergyUsageReadIntervalReadReadQualities struct {
	// EndInterval End interval for read quality flag
	EndInterval int `json:"endInterval"`

	// Quality The quality of the read taken
	Quality EnergyUsageReadIntervalReadReadQualitiesQuality `json:"quality"`

	// StartInterval Start interval for read quality flag. First read begins at 1
	StartInterval int `json:"startInterval"`
}

// EnergyUsageReadIntervalReadReadQualitiesQuality The quality of the read taken
type EnergyUsageReadIntervalReadReadQualitiesQuality string

// Links defines model for Links.
type Links struct {
	// Self Fully qualified link that generated the current response document
	Self string `json:"self"`
}

// LinksPaginated defines model for LinksPaginated.
type LinksPaginated struct {
	// First URI to the first page of this set. Mandatory if this response is not the first page
	First *string `json:"first,omitempty"`

	// Last URI to the last page of this set. Mandatory if this response is not the last page
	Last *string `json:"last,omitempty"`

	// Next URI to the next page of this set. Mandatory if this response is not the last page
	Next *string `json:"next,omitempty"`

	// Prev URI to the previous page of this set. Mandatory if this response is not the first page
	Prev *string `json:"prev,omitempty"`

	// Self Fully qualified link that generated the current response document
	Self string `json:"self"`
}

// Meta defines model for Meta.
type Meta = map[string]interface{}

// MetaPaginated defines model for MetaPaginated.
type MetaPaginated struct {
	// TotalPages The total number of pages in the full set. See [pagination](#pagination).
	TotalPages int `json:"totalPages"`

	// TotalRecords The total number of records in the full set. See [pagination](#pagination).
	TotalRecords int `json:"totalRecords"`
}

// ResponseErrorListV2 defines model for ResponseErrorListV2.
type ResponseErrorListV2 struct {
	Errors []ResponseErrorListV2Errors `json:"errors"`
}

// ResponseErrorListV2Errors defines model for ResponseErrorListV2_errors.
type ResponseErrorListV2Errors struct {
	// Code The code of the error encountered. Where the error is specific to the respondent, an application-specific error code, expressed as a string value. If the error is application-specific, the URN code that the specific error extends must be provided in the meta object. Otherwise, the value is the error code URN.
	Code string `json:"code"`

	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail string `json:"detail"`

	// Meta Additional data for customised error codes
	Meta *ResponseErrorListV2Meta `json:"meta,omitempty"`

	// Title A short, human-readable summary of the problem that MUST NOT change from occurrence to occurrence of the problem represented by the error code.
	Title string `json:"title"`
}

// ResponseErrorListV2Meta Additional data for customised error codes
type ResponseErrorListV2Meta struct {
	// Urn The CDR error code URN which the application-specific error code extends. Mandatory if the error `code` is an application-specific error rather than a standardised error code.
	Urn *string `json:"urn,omitempty"`
}

// AccountIdList defines model for accountIdList.
type AccountIdList struct {
	Data struct {
		// AccountIds Array of specific accountIds to obtain data for
		AccountIds []string `json:"accountIds"`
	} `json:"data"`
	Meta *Meta `json:"meta,omitempty"`
}

// ServicePointIdList defines model for servicePointIdList.
type ServicePointIdList struct {
	Data struct {
		// ServicePointIds Array of specific servicePointIds to obtain data for
		ServicePointIds []string `json:"servicePointIds"`
	} `json:"data"`
	Meta *Meta `json:"meta,omitempty"`
}

// ListAccountsParams defines parameters for ListAccounts.
type ListAccountsParams struct {
	// OpenStatus Used to filter results according to open/closed status. Values can be OPEN, CLOSED or ALL. If absent then ALL is assumed
	OpenStatus *ListAccountsParamsOpenStatus `form:"open-status,omitempty" json:"open-status,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListAccountsParamsOpenStatus defines parameters for ListAccounts.
type ListAccountsParamsOpenStatus string

// ListBalancesBulkParams defines parameters for ListBalancesBulk.
type ListBalancesBulkParams struct {
	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListBalancesForAccountsJSONBody defines parameters for ListBalancesForAccounts.
type ListBalancesForAccountsJSONBody struct {
	Data struct {
		// AccountIds Array of specific accountIds to obtain data for
		AccountIds []string `json:"accountIds"`
	} `json:"data"`
	Meta *Meta `json:"meta,omitempty"`
}

// ListBalancesForAccountsParams defines parameters for ListBalancesForAccounts.
type ListBalancesForAccountsParams struct {
	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListBillingBulkParams defines parameters for ListBillingBulk.
type ListBillingBulkParams struct {
	// NewestTime Constrain the request to records with effective time at or before this date/time.  If absent defaults to current date/time.  Format is aligned to DateTimeString common type
	NewestTime *string `form:"newest-time,omitempty" json:"newest-time,omitempty"`

	// OldestTime Constrain the request to records with effective time at or after this date/time. If absent defaults to newest-time minus 12 months.  Format is aligned to DateTimeString common type
	OldestTime *string `form:"oldest-time,omitempty" json:"oldest-time,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListBillingForAccountsJSONBody defines parameters for ListBillingForAccounts.
type ListBillingForAccountsJSONBody struct {
	Data struct {
		// AccountIds Array of specific accountIds to obtain data for
		AccountIds []string `json:"accountIds"`
	} `json:"data"`
	Meta *Meta `json:"meta,omitempty"`
}

// ListBillingForAccountsParams defines parameters for ListBillingForAccounts.
type ListBillingForAccountsParams struct {
	// NewestTime Constrain the request to records with effective time at or before this date/time.  If absent defaults to current date/time.  Format is aligned to DateTimeString common type
	NewestTime *string `form:"newest-time,omitempty" json:"newest-time,omitempty"`

	// OldestTime Constrain the request to records with effective time at or after this date/time. If absent defaults to newest-time minus 12 months.  Format is aligned to DateTimeString common type
	OldestTime *string `form:"oldest-time,omitempty" json:"oldest-time,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListInvoicesBulkParams defines parameters for ListInvoicesBulk.
type ListInvoicesBulkParams struct {
	// NewestDate Constrain the request to records with issue date at or before this date.  If absent defaults to current date.  Format is aligned to DateString common type
	NewestDate *string `form:"newest-date,omitempty" json:"newest-date,omitempty"`

	// OldestDate Constrain the request to records with issue date at or after this date. If absent defaults to newest-date minus 24 months.  Format is aligned to DateString common type
	OldestDate *string `form:"oldest-date,omitempty" json:"oldest-date,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListInvoicesForAccountsJSONBody defines parameters for ListInvoicesForAccounts.
type ListInvoicesForAccountsJSONBody struct {
	Data struct {
		// AccountIds Array of specific accountIds to obtain data for
		AccountIds []string `json:"accountIds"`
	} `json:"data"`
	Meta *Meta `json:"meta,omitempty"`
}

// ListInvoicesForAccountsParams defines parameters for ListInvoicesForAccounts.
type ListInvoicesForAccountsParams struct {
	// NewestDate Constrain the request to records with issue date at or before this date.  If absent defaults to current date.  Format is aligned to DateString common type
	NewestDate *string `form:"newest-date,omitempty" json:"newest-date,omitempty"`

	// OldestDate Constrain the request to records with issue date at or after this date. If absent defaults to newest-date minus 24 months.  Format is aligned to DateString common type
	OldestDate *string `form:"oldest-date,omitempty" json:"oldest-date,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// GetAccountParams defines parameters for GetAccount.
type GetAccountParams struct {
	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// GetBalanceForAccountParams defines parameters for GetBalanceForAccount.
type GetBalanceForAccountParams struct {
	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// GetBillingForAccountParams defines parameters for GetBillingForAccount.
type GetBillingForAccountParams struct {
	// NewestTime Constrain the request to records with effective time at or before this date/time.  If absent defaults to current date/time.  Format is aligned to DateTimeString common type
	NewestTime *string `form:"newest-time,omitempty" json:"newest-time,omitempty"`

	// OldestTime Constrain the request to records with effective time at or after this date/time. If absent defaults to newest-time minus 12 months.  Format is aligned to DateTimeString common type
	OldestTime *string `form:"oldest-time,omitempty" json:"oldest-time,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// GetConcessionsParams defines parameters for GetConcessions.
type GetConcessionsParams struct {
	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// GetInvoicesForAccountParams defines parameters for GetInvoicesForAccount.
type GetInvoicesForAccountParams struct {
	// NewestDate Constrain the request to records with issue date at or before this date.  If absent defaults to current date.  Format is aligned to DateString common type
	NewestDate *string `form:"newest-date,omitempty" json:"newest-date,omitempty"`

	// OldestDate Constrain the request to records with issue date at or after this date. If absent defaults to newest-date minus 24 months.  Format is aligned to DateString common type
	OldestDate *string `form:"oldest-date,omitempty" json:"oldest-date,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// GetPaymentScheduleParams defines parameters for GetPaymentSchedule.
type GetPaymentScheduleParams struct {
	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListServicePointsParams defines parameters for ListServicePoints.
type ListServicePointsParams struct {
	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListDERBulkParams defines parameters for ListDERBulk.
type ListDERBulkParams struct {
	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListDERForServicePointsJSONBody defines parameters for ListDERForServicePoints.
type ListDERForServicePointsJSONBody struct {
	Data struct {
		// ServicePointIds Array of specific servicePointIds to obtain data for
		ServicePointIds []string `json:"servicePointIds"`
	} `json:"data"`
	Meta *Meta `json:"meta,omitempty"`
}

// ListDERForServicePointsParams defines parameters for ListDERForServicePoints.
type ListDERForServicePointsParams struct {
	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListUsageBulkParams defines parameters for ListUsageBulk.
type ListUsageBulkParams struct {
	// IntervalReads Type of interval reads. Any one of the valid values for this field can be supplied. If absent defaults to NONE
	IntervalReads *ListUsageBulkParamsIntervalReads `form:"interval-reads,omitempty" json:"interval-reads,omitempty"`

	// OldestDate Constrain the request to records with effective date at or after this date. If absent defaults to newest-date minus 24 months.  Format is aligned to DateString common type
	OldestDate *string `form:"oldest-date,omitempty" json:"oldest-date,omitempty"`

	// NewestDate Constrain the request to records with effective date at or before this date.  If absent defaults to current date.  Format is aligned to DateString common type
	NewestDate *string `form:"newest-date,omitempty" json:"newest-date,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListUsageBulkParamsIntervalReads defines parameters for ListUsageBulk.
type ListUsageBulkParamsIntervalReads string

// ListUsageForServicePointsJSONBody defines parameters for ListUsageForServicePoints.
type ListUsageForServicePointsJSONBody struct {
	Data struct {
		// ServicePointIds Array of specific servicePointIds to obtain data for
		ServicePointIds []string `json:"servicePointIds"`
	} `json:"data"`
	Meta *Meta `json:"meta,omitempty"`
}

// ListUsageForServicePointsParams defines parameters for ListUsageForServicePoints.
type ListUsageForServicePointsParams struct {
	// OldestDate Constrain the request to records with effective date at or after this date. If absent defaults to newest-date minus 24 months.  Format is aligned to DateString common type
	OldestDate *string `form:"oldest-date,omitempty" json:"oldest-date,omitempty"`

	// NewestDate Constrain the request to records with effective date at or before this date.  If absent defaults to current date.  Format is aligned to DateString common type
	NewestDate *string `form:"newest-date,omitempty" json:"newest-date,omitempty"`

	// IntervalReads Type of interval reads. Any one of the valid values for this field can be supplied. If absent defaults to NONE
	IntervalReads *ListUsageForServicePointsParamsIntervalReads `form:"interval-reads,omitempty" json:"interval-reads,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// ListUsageForServicePointsParamsIntervalReads defines parameters for ListUsageForServicePoints.
type ListUsageForServicePointsParamsIntervalReads string

// GetServicePointParams defines parameters for GetServicePoint.
type GetServicePointParams struct {
	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// GetDERForServicePointParams defines parameters for GetDERForServicePoint.
type GetDERForServicePointParams struct {
	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// GetUsageForServicePointParams defines parameters for GetUsageForServicePoint.
type GetUsageForServicePointParams struct {
	// OldestDate Constrain the request to records with effective date at or after this date. If absent defaults to newest-date minus 24 months.  Format is aligned to DateString common type
	OldestDate *string `form:"oldest-date,omitempty" json:"oldest-date,omitempty"`

	// NewestDate Constrain the request to records with effective date at or before this date.  If absent defaults to current date.  Format is aligned to DateString common type
	NewestDate *string `form:"newest-date,omitempty" json:"newest-date,omitempty"`

	// IntervalReads Type of interval reads. Any one of the valid values for this field can be supplied. If absent defaults to NONE
	IntervalReads *GetUsageForServicePointParamsIntervalReads `form:"interval-reads,omitempty" json:"interval-reads,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`

	// XFapiInteractionId An **[[RFC4122]](#nref-RFC4122)** UUID used as a correlation id. If provided, the data holder must play back this value in the x-fapi-interaction-id response header. If not provided a **[[RFC4122]](#nref-RFC4122)** UUID value is required to be provided in the response header to track the interaction.
	XFapiInteractionId *string `json:"x-fapi-interaction-id,omitempty"`

	// XFapiAuthDate The time when the customer last logged in to the Data Recipient Software Product as described in **[[FAPI-R-Draft]](#nref-FAPI-R-Draft)**.  Required for all resource calls (customer present and unattended). Not required for unauthenticated calls.
	XFapiAuthDate *string `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIpAddress The customer's original IP address if the customer is currently logged in to the data recipient. The presence of this header indicates that the API is being called in a customer present context. Not to be included for unauthenticated calls.
	XFapiCustomerIpAddress *string `json:"x-fapi-customer-ip-address,omitempty"`

	// XCdsClientHeaders The customer's original standard http headers [Base64](#common-field-types) encoded, including the original User Agent header, if the customer is currently logged in to the data recipient. Mandatory for customer present calls.  Not required for unattended or unauthenticated calls.
	XCdsClientHeaders *string `json:"x-cds-client-headers,omitempty"`
}

// GetUsageForServicePointParamsIntervalReads defines parameters for GetUsageForServicePoint.
type GetUsageForServicePointParamsIntervalReads string

// ListPlansParams defines parameters for ListPlans.
type ListPlansParams struct {
	// Type Used to filter results on the type field.  Any one of the valid values for this field can be supplied plus 'ALL'.  If absent defaults to 'ALL'
	Type *ListPlansParamsType `form:"type,omitempty" json:"type,omitempty"`

	// FuelType Used to filter results on the fuelType field.  Any one of the valid values for this field can be supplied plus 'ALL'.  If absent defaults to 'ALL'
	FuelType *ListPlansParamsFuelType `form:"fuelType,omitempty" json:"fuelType,omitempty"`

	// Effective Allows for the filtering of plans based on whether the current time is within the period of time defined as effective by the effectiveFrom and effectiveTo fields. Valid values are CURRENT, FUTURE and ALL. If absent defaults to 'CURRENT'
	Effective *ListPlansParamsEffective `form:"effective,omitempty" json:"effective,omitempty"`

	// UpdatedSince Only include plans that have been updated after the specified date and time.  If absent defaults to include all plans
	UpdatedSince *string `form:"updated-since,omitempty" json:"updated-since,omitempty"`

	// Brand Used to filter results on the brand field.  If absent defaults to include all plans
	Brand *string `form:"brand,omitempty" json:"brand,omitempty"`

	// Page Page of results to request (standard pagination)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Page size to request.  Default is 25 (standard pagination)
	PageSize *int `form:"page-size,omitempty" json:"page-size,omitempty"`

	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`
}

// ListPlansParamsType defines parameters for ListPlans.
type ListPlansParamsType string

// ListPlansParamsFuelType defines parameters for ListPlans.
type ListPlansParamsFuelType string

// ListPlansParamsEffective defines parameters for ListPlans.
type ListPlansParamsEffective string

// GetPlanParams defines parameters for GetPlan.
type GetPlanParams struct {
	// XV Version of the API end point requested by the client. Must be set to a positive integer. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If the value of [x-min-v](#request-headers) is equal to or higher than the value of [x-v](#request-headers) then the [x-min-v](#request-headers) header should be treated as absent. If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable. See [HTTP Headers](#request-headers)
	XV string `json:"x-v"`

	// XMinV Minimum version of the API end point requested by the client. Must be set to a positive integer if provided. The data holder should respond with the highest supported version between [x-min-v](#request-headers) and [x-v](#request-headers). If all versions requested are not supported then the data holder must respond with a 406 Not Acceptable.
	XMinV *string `json:"x-min-v,omitempty"`
}

// ListBalancesForAccountsJSONRequestBody defines body for ListBalancesForAccounts for application/json ContentType.
type ListBalancesForAccountsJSONRequestBody ListBalancesForAccountsJSONBody

// ListBillingForAccountsJSONRequestBody defines body for ListBillingForAccounts for application/json ContentType.
type ListBillingForAccountsJSONRequestBody ListBillingForAccountsJSONBody

// ListInvoicesForAccountsJSONRequestBody defines body for ListInvoicesForAccounts for application/json ContentType.
type ListInvoicesForAccountsJSONRequestBody ListInvoicesForAccountsJSONBody

// ListDERForServicePointsJSONRequestBody defines body for ListDERForServicePoints for application/json ContentType.
type ListDERForServicePointsJSONRequestBody ListDERForServicePointsJSONBody

// ListUsageForServicePointsJSONRequestBody defines body for ListUsageForServicePoints for application/json ContentType.
type ListUsageForServicePointsJSONRequestBody ListUsageForServicePointsJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListAccounts request
	ListAccounts(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBalancesBulk request
	ListBalancesBulk(ctx context.Context, params *ListBalancesBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBalancesForAccountsWithBody request with any body
	ListBalancesForAccountsWithBody(ctx context.Context, params *ListBalancesForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListBalancesForAccounts(ctx context.Context, params *ListBalancesForAccountsParams, body ListBalancesForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBillingBulk request
	ListBillingBulk(ctx context.Context, params *ListBillingBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBillingForAccountsWithBody request with any body
	ListBillingForAccountsWithBody(ctx context.Context, params *ListBillingForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListBillingForAccounts(ctx context.Context, params *ListBillingForAccountsParams, body ListBillingForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInvoicesBulk request
	ListInvoicesBulk(ctx context.Context, params *ListInvoicesBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInvoicesForAccountsWithBody request with any body
	ListInvoicesForAccountsWithBody(ctx context.Context, params *ListInvoicesForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListInvoicesForAccounts(ctx context.Context, params *ListInvoicesForAccountsParams, body ListInvoicesForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccount request
	GetAccount(ctx context.Context, accountId string, params *GetAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBalanceForAccount request
	GetBalanceForAccount(ctx context.Context, accountId string, params *GetBalanceForAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBillingForAccount request
	GetBillingForAccount(ctx context.Context, accountId string, params *GetBillingForAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConcessions request
	GetConcessions(ctx context.Context, accountId string, params *GetConcessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvoicesForAccount request
	GetInvoicesForAccount(ctx context.Context, accountId string, params *GetInvoicesForAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPaymentSchedule request
	GetPaymentSchedule(ctx context.Context, accountId string, params *GetPaymentScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListServicePoints request
	ListServicePoints(ctx context.Context, params *ListServicePointsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDERBulk request
	ListDERBulk(ctx context.Context, params *ListDERBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDERForServicePointsWithBody request with any body
	ListDERForServicePointsWithBody(ctx context.Context, params *ListDERForServicePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListDERForServicePoints(ctx context.Context, params *ListDERForServicePointsParams, body ListDERForServicePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsageBulk request
	ListUsageBulk(ctx context.Context, params *ListUsageBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsageForServicePointsWithBody request with any body
	ListUsageForServicePointsWithBody(ctx context.Context, params *ListUsageForServicePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListUsageForServicePoints(ctx context.Context, params *ListUsageForServicePointsParams, body ListUsageForServicePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServicePoint request
	GetServicePoint(ctx context.Context, servicePointId string, params *GetServicePointParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDERForServicePoint request
	GetDERForServicePoint(ctx context.Context, servicePointId string, params *GetDERForServicePointParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsageForServicePoint request
	GetUsageForServicePoint(ctx context.Context, servicePointId string, params *GetUsageForServicePointParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPlans request
	ListPlans(ctx context.Context, params *ListPlansParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlan request
	GetPlan(ctx context.Context, planId string, params *GetPlanParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListAccounts(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBalancesBulk(ctx context.Context, params *ListBalancesBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBalancesBulkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBalancesForAccountsWithBody(ctx context.Context, params *ListBalancesForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBalancesForAccountsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBalancesForAccounts(ctx context.Context, params *ListBalancesForAccountsParams, body ListBalancesForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBalancesForAccountsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBillingBulk(ctx context.Context, params *ListBillingBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBillingBulkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBillingForAccountsWithBody(ctx context.Context, params *ListBillingForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBillingForAccountsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBillingForAccounts(ctx context.Context, params *ListBillingForAccountsParams, body ListBillingForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBillingForAccountsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInvoicesBulk(ctx context.Context, params *ListInvoicesBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInvoicesBulkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInvoicesForAccountsWithBody(ctx context.Context, params *ListInvoicesForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInvoicesForAccountsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInvoicesForAccounts(ctx context.Context, params *ListInvoicesForAccountsParams, body ListInvoicesForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInvoicesForAccountsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccount(ctx context.Context, accountId string, params *GetAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBalanceForAccount(ctx context.Context, accountId string, params *GetBalanceForAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBalanceForAccountRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBillingForAccount(ctx context.Context, accountId string, params *GetBillingForAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBillingForAccountRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConcessions(ctx context.Context, accountId string, params *GetConcessionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConcessionsRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvoicesForAccount(ctx context.Context, accountId string, params *GetInvoicesForAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvoicesForAccountRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPaymentSchedule(ctx context.Context, accountId string, params *GetPaymentScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPaymentScheduleRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListServicePoints(ctx context.Context, params *ListServicePointsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListServicePointsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDERBulk(ctx context.Context, params *ListDERBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDERBulkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDERForServicePointsWithBody(ctx context.Context, params *ListDERForServicePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDERForServicePointsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDERForServicePoints(ctx context.Context, params *ListDERForServicePointsParams, body ListDERForServicePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDERForServicePointsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsageBulk(ctx context.Context, params *ListUsageBulkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsageBulkRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsageForServicePointsWithBody(ctx context.Context, params *ListUsageForServicePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsageForServicePointsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsageForServicePoints(ctx context.Context, params *ListUsageForServicePointsParams, body ListUsageForServicePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsageForServicePointsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServicePoint(ctx context.Context, servicePointId string, params *GetServicePointParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicePointRequest(c.Server, servicePointId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDERForServicePoint(ctx context.Context, servicePointId string, params *GetDERForServicePointParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDERForServicePointRequest(c.Server, servicePointId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsageForServicePoint(ctx context.Context, servicePointId string, params *GetUsageForServicePointParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsageForServicePointRequest(c.Server, servicePointId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPlans(ctx context.Context, params *ListPlansParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPlansRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlan(ctx context.Context, planId string, params *GetPlanParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlanRequest(c.Server, planId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAccountsRequest generates requests for ListAccounts
func NewListAccountsRequest(server string, params *ListAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OpenStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "open-status", runtime.ParamLocationQuery, *params.OpenStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)

		if params.XMinV != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-min-v", headerParam1)
		}

		if params.XFapiInteractionId != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-interaction-id", headerParam2)
		}

		if params.XFapiAuthDate != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-auth-date", headerParam3)
		}

		if params.XFapiCustomerIpAddress != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-customer-ip-address", headerParam4)
		}

		if params.XCdsClientHeaders != nil {
			var headerParam5 string

			headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-cds-client-headers", headerParam5)
		}

	}

	return req, nil
}

// NewListBalancesBulkRequest generates requests for ListBalancesBulk
func NewListBalancesBulkRequest(server string, params *ListBalancesBulkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/balances")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)

		if params.XMinV != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-min-v", headerParam1)
		}

		if params.XFapiInteractionId != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-interaction-id", headerParam2)
		}

		if params.XFapiAuthDate != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-auth-date", headerParam3)
		}

		if params.XFapiCustomerIpAddress != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-customer-ip-address", headerParam4)
		}

		if params.XCdsClientHeaders != nil {
			var headerParam5 string

			headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-cds-client-headers", headerParam5)
		}

	}

	return req, nil
}

// NewListBalancesForAccountsRequest calls the generic ListBalancesForAccounts builder with application/json body
func NewListBalancesForAccountsRequest(server string, params *ListBalancesForAccountsParams, body ListBalancesForAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListBalancesForAccountsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewListBalancesForAccountsRequestWithBody generates requests for ListBalancesForAccounts with any type of body
func NewListBalancesForAccountsRequestWithBody(server string, params *ListBalancesForAccountsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/balances")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)

		if params.XMinV != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-min-v", headerParam1)
		}

		if params.XFapiInteractionId != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-interaction-id", headerParam2)
		}

		if params.XFapiAuthDate != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-auth-date", headerParam3)
		}

		if params.XFapiCustomerIpAddress != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-customer-ip-address", headerParam4)
		}

		if params.XCdsClientHeaders != nil {
			var headerParam5 string

			headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-cds-client-headers", headerParam5)
		}

	}

	return req, nil
}

// NewListBillingBulkRequest generates requests for ListBillingBulk
func NewListBillingBulkRequest(server string, params *ListBillingBulkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/billing")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NewestTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-time", runtime.ParamLocationQuery, *params.NewestTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OldestTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-time", runtime.ParamLocationQuery, *params.OldestTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)

		if params.XMinV != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-min-v", headerParam1)
		}

		if params.XFapiInteractionId != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-interaction-id", headerParam2)
		}

		if params.XFapiAuthDate != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-auth-date", headerParam3)
		}

		if params.XFapiCustomerIpAddress != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-customer-ip-address", headerParam4)
		}

		if params.XCdsClientHeaders != nil {
			var headerParam5 string

			headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-cds-client-headers", headerParam5)
		}

	}

	return req, nil
}

// NewListBillingForAccountsRequest calls the generic ListBillingForAccounts builder with application/json body
func NewListBillingForAccountsRequest(server string, params *ListBillingForAccountsParams, body ListBillingForAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListBillingForAccountsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewListBillingForAccountsRequestWithBody generates requests for ListBillingForAccounts with any type of body
func NewListBillingForAccountsRequestWithBody(server string, params *ListBillingForAccountsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/billing")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NewestTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-time", runtime.ParamLocationQuery, *params.NewestTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OldestTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-time", runtime.ParamLocationQuery, *params.OldestTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)

		if params.XMinV != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-min-v", headerParam1)
		}

		if params.XFapiInteractionId != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-interaction-id", headerParam2)
		}

		if params.XFapiAuthDate != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-auth-date", headerParam3)
		}

		if params.XFapiCustomerIpAddress != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-customer-ip-address", headerParam4)
		}

		if params.XCdsClientHeaders != nil {
			var headerParam5 string

			headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-cds-client-headers", headerParam5)
		}

	}

	return req, nil
}

// NewListInvoicesBulkRequest generates requests for ListInvoicesBulk
func NewListInvoicesBulkRequest(server string, params *ListInvoicesBulkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/invoices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NewestDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-date", runtime.ParamLocationQuery, *params.NewestDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OldestDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-date", runtime.ParamLocationQuery, *params.OldestDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)

		if params.XMinV != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-min-v", headerParam1)
		}

		if params.XFapiInteractionId != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-interaction-id", headerParam2)
		}

		if params.XFapiAuthDate != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-auth-date", headerParam3)
		}

		if params.XFapiCustomerIpAddress != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-customer-ip-address", headerParam4)
		}

		if params.XCdsClientHeaders != nil {
			var headerParam5 string

			headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-cds-client-headers", headerParam5)
		}

	}

	return req, nil
}

// NewListInvoicesForAccountsRequest calls the generic ListInvoicesForAccounts builder with application/json body
func NewListInvoicesForAccountsRequest(server string, params *ListInvoicesForAccountsParams, body ListInvoicesForAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListInvoicesForAccountsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewListInvoicesForAccountsRequestWithBody generates requests for ListInvoicesForAccounts with any type of body
func NewListInvoicesForAccountsRequestWithBody(server string, params *ListInvoicesForAccountsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/invoices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NewestDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-date", runtime.ParamLocationQuery, *params.NewestDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OldestDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-date", runtime.ParamLocationQuery, *params.OldestDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)

		if params.XMinV != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-min-v", headerParam1)
		}

		if params.XFapiInteractionId != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-interaction-id", headerParam2)
		}

		if params.XFapiAuthDate != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-auth-date", headerParam3)
		}

		if params.XFapiCustomerIpAddress != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-customer-ip-address", headerParam4)
		}

		if params.XCdsClientHeaders != nil {
			var headerParam5 string

			headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-cds-client-headers", headerParam5)
		}

	}

	return req, nil
}

// NewGetAccountRequest generates requests for GetAccount
func NewGetAccountRequest(server string, accountId string, params *GetAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)

		if params.XMinV != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-min-v", headerParam1)
		}

		if params.XFapiInteractionId != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-interaction-id", headerParam2)
		}

		if params.XFapiAuthDate != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-auth-date", headerParam3)
		}

		if params.XFapiCustomerIpAddress != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-customer-ip-address", headerParam4)
		}

		if params.XCdsClientHeaders != nil {
			var headerParam5 string

			headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-cds-client-headers", headerParam5)
		}

	}

	return req, nil
}

// NewGetBalanceForAccountRequest generates requests for GetBalanceForAccount
func NewGetBalanceForAccountRequest(server string, accountId string, params *GetBalanceForAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/%s/balance", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)

		if params.XMinV != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-min-v", headerParam1)
		}

		if params.XFapiInteractionId != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-interaction-id", headerParam2)
		}

		if params.XFapiAuthDate != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-auth-date", headerParam3)
		}

		if params.XFapiCustomerIpAddress != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-customer-ip-address", headerParam4)
		}

		if params.XCdsClientHeaders != nil {
			var headerParam5 string

			headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-cds-client-headers", headerParam5)
		}

	}

	return req, nil
}

// NewGetBillingForAccountRequest generates requests for GetBillingForAccount
func NewGetBillingForAccountRequest(server string, accountId string, params *GetBillingForAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/%s/billing", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NewestTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-time", runtime.ParamLocationQuery, *params.NewestTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OldestTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-time", runtime.ParamLocationQuery, *params.OldestTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)

		if params.XMinV != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-min-v", headerParam1)
		}

		if params.XFapiInteractionId != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-interaction-id", headerParam2)
		}

		if params.XFapiAuthDate != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-auth-date", headerParam3)
		}

		if params.XFapiCustomerIpAddress != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-customer-ip-address", headerParam4)
		}

		if params.XCdsClientHeaders != nil {
			var headerParam5 string

			headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-cds-client-headers", headerParam5)
		}

	}

	return req, nil
}

// NewGetConcessionsRequest generates requests for GetConcessions
func NewGetConcessionsRequest(server string, accountId string, params *GetConcessionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/%s/concessions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)

		if params.XMinV != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-min-v", headerParam1)
		}

		if params.XFapiInteractionId != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-interaction-id", headerParam2)
		}

		if params.XFapiAuthDate != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-auth-date", headerParam3)
		}

		if params.XFapiCustomerIpAddress != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-customer-ip-address", headerParam4)
		}

		if params.XCdsClientHeaders != nil {
			var headerParam5 string

			headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-cds-client-headers", headerParam5)
		}

	}

	return req, nil
}

// NewGetInvoicesForAccountRequest generates requests for GetInvoicesForAccount
func NewGetInvoicesForAccountRequest(server string, accountId string, params *GetInvoicesForAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/%s/invoices", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NewestDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-date", runtime.ParamLocationQuery, *params.NewestDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OldestDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-date", runtime.ParamLocationQuery, *params.OldestDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)

		if params.XMinV != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-min-v", headerParam1)
		}

		if params.XFapiInteractionId != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-interaction-id", headerParam2)
		}

		if params.XFapiAuthDate != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-auth-date", headerParam3)
		}

		if params.XFapiCustomerIpAddress != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-customer-ip-address", headerParam4)
		}

		if params.XCdsClientHeaders != nil {
			var headerParam5 string

			headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-cds-client-headers", headerParam5)
		}

	}

	return req, nil
}

// NewGetPaymentScheduleRequest generates requests for GetPaymentSchedule
func NewGetPaymentScheduleRequest(server string, accountId string, params *GetPaymentScheduleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/accounts/%s/payment-schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)

		if params.XMinV != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-min-v", headerParam1)
		}

		if params.XFapiInteractionId != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-interaction-id", headerParam2)
		}

		if params.XFapiAuthDate != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-auth-date", headerParam3)
		}

		if params.XFapiCustomerIpAddress != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-customer-ip-address", headerParam4)
		}

		if params.XCdsClientHeaders != nil {
			var headerParam5 string

			headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-cds-client-headers", headerParam5)
		}

	}

	return req, nil
}

// NewListServicePointsRequest generates requests for ListServicePoints
func NewListServicePointsRequest(server string, params *ListServicePointsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/electricity/servicepoints")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)

		if params.XMinV != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-min-v", headerParam1)
		}

		if params.XFapiInteractionId != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-interaction-id", headerParam2)
		}

		if params.XFapiAuthDate != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-auth-date", headerParam3)
		}

		if params.XFapiCustomerIpAddress != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-customer-ip-address", headerParam4)
		}

		if params.XCdsClientHeaders != nil {
			var headerParam5 string

			headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-cds-client-headers", headerParam5)
		}

	}

	return req, nil
}

// NewListDERBulkRequest generates requests for ListDERBulk
func NewListDERBulkRequest(server string, params *ListDERBulkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/electricity/servicepoints/der")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)

		if params.XMinV != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-min-v", headerParam1)
		}

		if params.XFapiInteractionId != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-interaction-id", headerParam2)
		}

		if params.XFapiAuthDate != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-auth-date", headerParam3)
		}

		if params.XFapiCustomerIpAddress != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-customer-ip-address", headerParam4)
		}

		if params.XCdsClientHeaders != nil {
			var headerParam5 string

			headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-cds-client-headers", headerParam5)
		}

	}

	return req, nil
}

// NewListDERForServicePointsRequest calls the generic ListDERForServicePoints builder with application/json body
func NewListDERForServicePointsRequest(server string, params *ListDERForServicePointsParams, body ListDERForServicePointsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListDERForServicePointsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewListDERForServicePointsRequestWithBody generates requests for ListDERForServicePoints with any type of body
func NewListDERForServicePointsRequestWithBody(server string, params *ListDERForServicePointsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/electricity/servicepoints/der")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)

		if params.XMinV != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-min-v", headerParam1)
		}

		if params.XFapiInteractionId != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-interaction-id", headerParam2)
		}

		if params.XFapiAuthDate != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-auth-date", headerParam3)
		}

		if params.XFapiCustomerIpAddress != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-customer-ip-address", headerParam4)
		}

		if params.XCdsClientHeaders != nil {
			var headerParam5 string

			headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-cds-client-headers", headerParam5)
		}

	}

	return req, nil
}

// NewListUsageBulkRequest generates requests for ListUsageBulk
func NewListUsageBulkRequest(server string, params *ListUsageBulkParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/electricity/servicepoints/usage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IntervalReads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval-reads", runtime.ParamLocationQuery, *params.IntervalReads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OldestDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-date", runtime.ParamLocationQuery, *params.OldestDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NewestDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-date", runtime.ParamLocationQuery, *params.NewestDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)

		if params.XMinV != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-min-v", headerParam1)
		}

		if params.XFapiInteractionId != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-interaction-id", headerParam2)
		}

		if params.XFapiAuthDate != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-auth-date", headerParam3)
		}

		if params.XFapiCustomerIpAddress != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-customer-ip-address", headerParam4)
		}

		if params.XCdsClientHeaders != nil {
			var headerParam5 string

			headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-cds-client-headers", headerParam5)
		}

	}

	return req, nil
}

// NewListUsageForServicePointsRequest calls the generic ListUsageForServicePoints builder with application/json body
func NewListUsageForServicePointsRequest(server string, params *ListUsageForServicePointsParams, body ListUsageForServicePointsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListUsageForServicePointsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewListUsageForServicePointsRequestWithBody generates requests for ListUsageForServicePoints with any type of body
func NewListUsageForServicePointsRequestWithBody(server string, params *ListUsageForServicePointsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/electricity/servicepoints/usage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OldestDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-date", runtime.ParamLocationQuery, *params.OldestDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NewestDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-date", runtime.ParamLocationQuery, *params.NewestDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IntervalReads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval-reads", runtime.ParamLocationQuery, *params.IntervalReads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)

		if params.XMinV != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-min-v", headerParam1)
		}

		if params.XFapiInteractionId != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-interaction-id", headerParam2)
		}

		if params.XFapiAuthDate != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-auth-date", headerParam3)
		}

		if params.XFapiCustomerIpAddress != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-customer-ip-address", headerParam4)
		}

		if params.XCdsClientHeaders != nil {
			var headerParam5 string

			headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-cds-client-headers", headerParam5)
		}

	}

	return req, nil
}

// NewGetServicePointRequest generates requests for GetServicePoint
func NewGetServicePointRequest(server string, servicePointId string, params *GetServicePointParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "servicePointId", runtime.ParamLocationPath, servicePointId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/electricity/servicepoints/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)

		if params.XMinV != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-min-v", headerParam1)
		}

		if params.XFapiInteractionId != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-interaction-id", headerParam2)
		}

		if params.XFapiAuthDate != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-auth-date", headerParam3)
		}

		if params.XFapiCustomerIpAddress != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-customer-ip-address", headerParam4)
		}

		if params.XCdsClientHeaders != nil {
			var headerParam5 string

			headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-cds-client-headers", headerParam5)
		}

	}

	return req, nil
}

// NewGetDERForServicePointRequest generates requests for GetDERForServicePoint
func NewGetDERForServicePointRequest(server string, servicePointId string, params *GetDERForServicePointParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "servicePointId", runtime.ParamLocationPath, servicePointId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/electricity/servicepoints/%s/der", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)

		if params.XMinV != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-min-v", headerParam1)
		}

		if params.XFapiInteractionId != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-interaction-id", headerParam2)
		}

		if params.XFapiAuthDate != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-auth-date", headerParam3)
		}

		if params.XFapiCustomerIpAddress != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-customer-ip-address", headerParam4)
		}

		if params.XCdsClientHeaders != nil {
			var headerParam5 string

			headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-cds-client-headers", headerParam5)
		}

	}

	return req, nil
}

// NewGetUsageForServicePointRequest generates requests for GetUsageForServicePoint
func NewGetUsageForServicePointRequest(server string, servicePointId string, params *GetUsageForServicePointParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "servicePointId", runtime.ParamLocationPath, servicePointId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/electricity/servicepoints/%s/usage", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OldestDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oldest-date", runtime.ParamLocationQuery, *params.OldestDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NewestDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newest-date", runtime.ParamLocationQuery, *params.NewestDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IntervalReads != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "interval-reads", runtime.ParamLocationQuery, *params.IntervalReads); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)

		if params.XMinV != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-min-v", headerParam1)
		}

		if params.XFapiInteractionId != nil {
			var headerParam2 string

			headerParam2, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-interaction-id", runtime.ParamLocationHeader, *params.XFapiInteractionId)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-interaction-id", headerParam2)
		}

		if params.XFapiAuthDate != nil {
			var headerParam3 string

			headerParam3, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-auth-date", runtime.ParamLocationHeader, *params.XFapiAuthDate)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-auth-date", headerParam3)
		}

		if params.XFapiCustomerIpAddress != nil {
			var headerParam4 string

			headerParam4, err = runtime.StyleParamWithLocation("simple", false, "x-fapi-customer-ip-address", runtime.ParamLocationHeader, *params.XFapiCustomerIpAddress)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-fapi-customer-ip-address", headerParam4)
		}

		if params.XCdsClientHeaders != nil {
			var headerParam5 string

			headerParam5, err = runtime.StyleParamWithLocation("simple", false, "x-cds-client-headers", runtime.ParamLocationHeader, *params.XCdsClientHeaders)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-cds-client-headers", headerParam5)
		}

	}

	return req, nil
}

// NewListPlansRequest generates requests for ListPlans
func NewListPlansRequest(server string, params *ListPlansParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/plans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FuelType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fuelType", runtime.ParamLocationQuery, *params.FuelType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Effective != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "effective", runtime.ParamLocationQuery, *params.Effective); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated-since", runtime.ParamLocationQuery, *params.UpdatedSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Brand != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "brand", runtime.ParamLocationQuery, *params.Brand); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page-size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)

		if params.XMinV != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-min-v", headerParam1)
		}

	}

	return req, nil
}

// NewGetPlanRequest generates requests for GetPlan
func NewGetPlanRequest(server string, planId string, params *GetPlanParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "planId", runtime.ParamLocationPath, planId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/energy/plans/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "x-v", runtime.ParamLocationHeader, params.XV)
		if err != nil {
			return nil, err
		}

		req.Header.Set("x-v", headerParam0)

		if params.XMinV != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "x-min-v", runtime.ParamLocationHeader, *params.XMinV)
			if err != nil {
				return nil, err
			}

			req.Header.Set("x-min-v", headerParam1)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAccountsWithResponse request
	ListAccountsWithResponse(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*ListAccountsResponse, error)

	// ListBalancesBulkWithResponse request
	ListBalancesBulkWithResponse(ctx context.Context, params *ListBalancesBulkParams, reqEditors ...RequestEditorFn) (*ListBalancesBulkResponse, error)

	// ListBalancesForAccountsWithBodyWithResponse request with any body
	ListBalancesForAccountsWithBodyWithResponse(ctx context.Context, params *ListBalancesForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListBalancesForAccountsResponse, error)

	ListBalancesForAccountsWithResponse(ctx context.Context, params *ListBalancesForAccountsParams, body ListBalancesForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListBalancesForAccountsResponse, error)

	// ListBillingBulkWithResponse request
	ListBillingBulkWithResponse(ctx context.Context, params *ListBillingBulkParams, reqEditors ...RequestEditorFn) (*ListBillingBulkResponse, error)

	// ListBillingForAccountsWithBodyWithResponse request with any body
	ListBillingForAccountsWithBodyWithResponse(ctx context.Context, params *ListBillingForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListBillingForAccountsResponse, error)

	ListBillingForAccountsWithResponse(ctx context.Context, params *ListBillingForAccountsParams, body ListBillingForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListBillingForAccountsResponse, error)

	// ListInvoicesBulkWithResponse request
	ListInvoicesBulkWithResponse(ctx context.Context, params *ListInvoicesBulkParams, reqEditors ...RequestEditorFn) (*ListInvoicesBulkResponse, error)

	// ListInvoicesForAccountsWithBodyWithResponse request with any body
	ListInvoicesForAccountsWithBodyWithResponse(ctx context.Context, params *ListInvoicesForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListInvoicesForAccountsResponse, error)

	ListInvoicesForAccountsWithResponse(ctx context.Context, params *ListInvoicesForAccountsParams, body ListInvoicesForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListInvoicesForAccountsResponse, error)

	// GetAccountWithResponse request
	GetAccountWithResponse(ctx context.Context, accountId string, params *GetAccountParams, reqEditors ...RequestEditorFn) (*GetAccountResponse, error)

	// GetBalanceForAccountWithResponse request
	GetBalanceForAccountWithResponse(ctx context.Context, accountId string, params *GetBalanceForAccountParams, reqEditors ...RequestEditorFn) (*GetBalanceForAccountResponse, error)

	// GetBillingForAccountWithResponse request
	GetBillingForAccountWithResponse(ctx context.Context, accountId string, params *GetBillingForAccountParams, reqEditors ...RequestEditorFn) (*GetBillingForAccountResponse, error)

	// GetConcessionsWithResponse request
	GetConcessionsWithResponse(ctx context.Context, accountId string, params *GetConcessionsParams, reqEditors ...RequestEditorFn) (*GetConcessionsResponse, error)

	// GetInvoicesForAccountWithResponse request
	GetInvoicesForAccountWithResponse(ctx context.Context, accountId string, params *GetInvoicesForAccountParams, reqEditors ...RequestEditorFn) (*GetInvoicesForAccountResponse, error)

	// GetPaymentScheduleWithResponse request
	GetPaymentScheduleWithResponse(ctx context.Context, accountId string, params *GetPaymentScheduleParams, reqEditors ...RequestEditorFn) (*GetPaymentScheduleResponse, error)

	// ListServicePointsWithResponse request
	ListServicePointsWithResponse(ctx context.Context, params *ListServicePointsParams, reqEditors ...RequestEditorFn) (*ListServicePointsResponse, error)

	// ListDERBulkWithResponse request
	ListDERBulkWithResponse(ctx context.Context, params *ListDERBulkParams, reqEditors ...RequestEditorFn) (*ListDERBulkResponse, error)

	// ListDERForServicePointsWithBodyWithResponse request with any body
	ListDERForServicePointsWithBodyWithResponse(ctx context.Context, params *ListDERForServicePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListDERForServicePointsResponse, error)

	ListDERForServicePointsWithResponse(ctx context.Context, params *ListDERForServicePointsParams, body ListDERForServicePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListDERForServicePointsResponse, error)

	// ListUsageBulkWithResponse request
	ListUsageBulkWithResponse(ctx context.Context, params *ListUsageBulkParams, reqEditors ...RequestEditorFn) (*ListUsageBulkResponse, error)

	// ListUsageForServicePointsWithBodyWithResponse request with any body
	ListUsageForServicePointsWithBodyWithResponse(ctx context.Context, params *ListUsageForServicePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListUsageForServicePointsResponse, error)

	ListUsageForServicePointsWithResponse(ctx context.Context, params *ListUsageForServicePointsParams, body ListUsageForServicePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListUsageForServicePointsResponse, error)

	// GetServicePointWithResponse request
	GetServicePointWithResponse(ctx context.Context, servicePointId string, params *GetServicePointParams, reqEditors ...RequestEditorFn) (*GetServicePointResponse, error)

	// GetDERForServicePointWithResponse request
	GetDERForServicePointWithResponse(ctx context.Context, servicePointId string, params *GetDERForServicePointParams, reqEditors ...RequestEditorFn) (*GetDERForServicePointResponse, error)

	// GetUsageForServicePointWithResponse request
	GetUsageForServicePointWithResponse(ctx context.Context, servicePointId string, params *GetUsageForServicePointParams, reqEditors ...RequestEditorFn) (*GetUsageForServicePointResponse, error)

	// ListPlansWithResponse request
	ListPlansWithResponse(ctx context.Context, params *ListPlansParams, reqEditors ...RequestEditorFn) (*ListPlansResponse, error)

	// GetPlanWithResponse request
	GetPlanWithResponse(ctx context.Context, planId string, params *GetPlanParams, reqEditors ...RequestEditorFn) (*GetPlanResponse, error)
}

type ListAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyAccountListResponseV2
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBalancesBulkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyBalanceListResponse
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListBalancesBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBalancesBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBalancesForAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyBalanceListResponse
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListBalancesForAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBalancesForAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBillingBulkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyBillingListResponse
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListBillingBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBillingBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBillingForAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyBillingListResponse
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListBillingForAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBillingForAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInvoicesBulkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyInvoiceListResponse
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListInvoicesBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInvoicesBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInvoicesForAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyInvoiceListResponse
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListInvoicesForAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInvoicesForAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyAccountDetailResponseV3
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBalanceForAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyBalanceResponse
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetBalanceForAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBalanceForAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBillingForAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyBillingListResponse
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetBillingForAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBillingForAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConcessionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyConcessionsResponse
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetConcessionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConcessionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvoicesForAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyInvoiceListResponse
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetInvoicesForAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvoicesForAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPaymentScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyPaymentScheduleResponse
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetPaymentScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPaymentScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListServicePointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyServicePointListResponse
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListServicePointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServicePointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDERBulkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyDerListResponse
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListDERBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDERBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDERForServicePointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyDerListResponse
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListDERForServicePointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDERForServicePointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsageBulkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyUsageListResponse
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListUsageBulkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsageBulkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsageForServicePointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyUsageListResponse
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListUsageForServicePointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsageForServicePointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicePointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyServicePointDetailResponse
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetServicePointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicePointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDERForServicePointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyDerDetailResponse
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetDERForServicePointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDERForServicePointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsageForServicePointResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyUsageListResponse
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetUsageForServicePointResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsageForServicePointResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPlansResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyPlanListResponse
	JSON400      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
	JSON422      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r ListPlansResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPlansResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlanResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EnergyPlanResponseV2
	JSON400      *ResponseErrorListV2
	JSON404      *ResponseErrorListV2
	JSON406      *ResponseErrorListV2
}

// Status returns HTTPResponse.Status
func (r GetPlanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAccountsWithResponse request returning *ListAccountsResponse
func (c *ClientWithResponses) ListAccountsWithResponse(ctx context.Context, params *ListAccountsParams, reqEditors ...RequestEditorFn) (*ListAccountsResponse, error) {
	rsp, err := c.ListAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAccountsResponse(rsp)
}

// ListBalancesBulkWithResponse request returning *ListBalancesBulkResponse
func (c *ClientWithResponses) ListBalancesBulkWithResponse(ctx context.Context, params *ListBalancesBulkParams, reqEditors ...RequestEditorFn) (*ListBalancesBulkResponse, error) {
	rsp, err := c.ListBalancesBulk(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBalancesBulkResponse(rsp)
}

// ListBalancesForAccountsWithBodyWithResponse request with arbitrary body returning *ListBalancesForAccountsResponse
func (c *ClientWithResponses) ListBalancesForAccountsWithBodyWithResponse(ctx context.Context, params *ListBalancesForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListBalancesForAccountsResponse, error) {
	rsp, err := c.ListBalancesForAccountsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBalancesForAccountsResponse(rsp)
}

func (c *ClientWithResponses) ListBalancesForAccountsWithResponse(ctx context.Context, params *ListBalancesForAccountsParams, body ListBalancesForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListBalancesForAccountsResponse, error) {
	rsp, err := c.ListBalancesForAccounts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBalancesForAccountsResponse(rsp)
}

// ListBillingBulkWithResponse request returning *ListBillingBulkResponse
func (c *ClientWithResponses) ListBillingBulkWithResponse(ctx context.Context, params *ListBillingBulkParams, reqEditors ...RequestEditorFn) (*ListBillingBulkResponse, error) {
	rsp, err := c.ListBillingBulk(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBillingBulkResponse(rsp)
}

// ListBillingForAccountsWithBodyWithResponse request with arbitrary body returning *ListBillingForAccountsResponse
func (c *ClientWithResponses) ListBillingForAccountsWithBodyWithResponse(ctx context.Context, params *ListBillingForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListBillingForAccountsResponse, error) {
	rsp, err := c.ListBillingForAccountsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBillingForAccountsResponse(rsp)
}

func (c *ClientWithResponses) ListBillingForAccountsWithResponse(ctx context.Context, params *ListBillingForAccountsParams, body ListBillingForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListBillingForAccountsResponse, error) {
	rsp, err := c.ListBillingForAccounts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBillingForAccountsResponse(rsp)
}

// ListInvoicesBulkWithResponse request returning *ListInvoicesBulkResponse
func (c *ClientWithResponses) ListInvoicesBulkWithResponse(ctx context.Context, params *ListInvoicesBulkParams, reqEditors ...RequestEditorFn) (*ListInvoicesBulkResponse, error) {
	rsp, err := c.ListInvoicesBulk(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInvoicesBulkResponse(rsp)
}

// ListInvoicesForAccountsWithBodyWithResponse request with arbitrary body returning *ListInvoicesForAccountsResponse
func (c *ClientWithResponses) ListInvoicesForAccountsWithBodyWithResponse(ctx context.Context, params *ListInvoicesForAccountsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListInvoicesForAccountsResponse, error) {
	rsp, err := c.ListInvoicesForAccountsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInvoicesForAccountsResponse(rsp)
}

func (c *ClientWithResponses) ListInvoicesForAccountsWithResponse(ctx context.Context, params *ListInvoicesForAccountsParams, body ListInvoicesForAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListInvoicesForAccountsResponse, error) {
	rsp, err := c.ListInvoicesForAccounts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInvoicesForAccountsResponse(rsp)
}

// GetAccountWithResponse request returning *GetAccountResponse
func (c *ClientWithResponses) GetAccountWithResponse(ctx context.Context, accountId string, params *GetAccountParams, reqEditors ...RequestEditorFn) (*GetAccountResponse, error) {
	rsp, err := c.GetAccount(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountResponse(rsp)
}

// GetBalanceForAccountWithResponse request returning *GetBalanceForAccountResponse
func (c *ClientWithResponses) GetBalanceForAccountWithResponse(ctx context.Context, accountId string, params *GetBalanceForAccountParams, reqEditors ...RequestEditorFn) (*GetBalanceForAccountResponse, error) {
	rsp, err := c.GetBalanceForAccount(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBalanceForAccountResponse(rsp)
}

// GetBillingForAccountWithResponse request returning *GetBillingForAccountResponse
func (c *ClientWithResponses) GetBillingForAccountWithResponse(ctx context.Context, accountId string, params *GetBillingForAccountParams, reqEditors ...RequestEditorFn) (*GetBillingForAccountResponse, error) {
	rsp, err := c.GetBillingForAccount(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBillingForAccountResponse(rsp)
}

// GetConcessionsWithResponse request returning *GetConcessionsResponse
func (c *ClientWithResponses) GetConcessionsWithResponse(ctx context.Context, accountId string, params *GetConcessionsParams, reqEditors ...RequestEditorFn) (*GetConcessionsResponse, error) {
	rsp, err := c.GetConcessions(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConcessionsResponse(rsp)
}

// GetInvoicesForAccountWithResponse request returning *GetInvoicesForAccountResponse
func (c *ClientWithResponses) GetInvoicesForAccountWithResponse(ctx context.Context, accountId string, params *GetInvoicesForAccountParams, reqEditors ...RequestEditorFn) (*GetInvoicesForAccountResponse, error) {
	rsp, err := c.GetInvoicesForAccount(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvoicesForAccountResponse(rsp)
}

// GetPaymentScheduleWithResponse request returning *GetPaymentScheduleResponse
func (c *ClientWithResponses) GetPaymentScheduleWithResponse(ctx context.Context, accountId string, params *GetPaymentScheduleParams, reqEditors ...RequestEditorFn) (*GetPaymentScheduleResponse, error) {
	rsp, err := c.GetPaymentSchedule(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPaymentScheduleResponse(rsp)
}

// ListServicePointsWithResponse request returning *ListServicePointsResponse
func (c *ClientWithResponses) ListServicePointsWithResponse(ctx context.Context, params *ListServicePointsParams, reqEditors ...RequestEditorFn) (*ListServicePointsResponse, error) {
	rsp, err := c.ListServicePoints(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListServicePointsResponse(rsp)
}

// ListDERBulkWithResponse request returning *ListDERBulkResponse
func (c *ClientWithResponses) ListDERBulkWithResponse(ctx context.Context, params *ListDERBulkParams, reqEditors ...RequestEditorFn) (*ListDERBulkResponse, error) {
	rsp, err := c.ListDERBulk(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDERBulkResponse(rsp)
}

// ListDERForServicePointsWithBodyWithResponse request with arbitrary body returning *ListDERForServicePointsResponse
func (c *ClientWithResponses) ListDERForServicePointsWithBodyWithResponse(ctx context.Context, params *ListDERForServicePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListDERForServicePointsResponse, error) {
	rsp, err := c.ListDERForServicePointsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDERForServicePointsResponse(rsp)
}

func (c *ClientWithResponses) ListDERForServicePointsWithResponse(ctx context.Context, params *ListDERForServicePointsParams, body ListDERForServicePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListDERForServicePointsResponse, error) {
	rsp, err := c.ListDERForServicePoints(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDERForServicePointsResponse(rsp)
}

// ListUsageBulkWithResponse request returning *ListUsageBulkResponse
func (c *ClientWithResponses) ListUsageBulkWithResponse(ctx context.Context, params *ListUsageBulkParams, reqEditors ...RequestEditorFn) (*ListUsageBulkResponse, error) {
	rsp, err := c.ListUsageBulk(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsageBulkResponse(rsp)
}

// ListUsageForServicePointsWithBodyWithResponse request with arbitrary body returning *ListUsageForServicePointsResponse
func (c *ClientWithResponses) ListUsageForServicePointsWithBodyWithResponse(ctx context.Context, params *ListUsageForServicePointsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListUsageForServicePointsResponse, error) {
	rsp, err := c.ListUsageForServicePointsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsageForServicePointsResponse(rsp)
}

func (c *ClientWithResponses) ListUsageForServicePointsWithResponse(ctx context.Context, params *ListUsageForServicePointsParams, body ListUsageForServicePointsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListUsageForServicePointsResponse, error) {
	rsp, err := c.ListUsageForServicePoints(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsageForServicePointsResponse(rsp)
}

// GetServicePointWithResponse request returning *GetServicePointResponse
func (c *ClientWithResponses) GetServicePointWithResponse(ctx context.Context, servicePointId string, params *GetServicePointParams, reqEditors ...RequestEditorFn) (*GetServicePointResponse, error) {
	rsp, err := c.GetServicePoint(ctx, servicePointId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicePointResponse(rsp)
}

// GetDERForServicePointWithResponse request returning *GetDERForServicePointResponse
func (c *ClientWithResponses) GetDERForServicePointWithResponse(ctx context.Context, servicePointId string, params *GetDERForServicePointParams, reqEditors ...RequestEditorFn) (*GetDERForServicePointResponse, error) {
	rsp, err := c.GetDERForServicePoint(ctx, servicePointId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDERForServicePointResponse(rsp)
}

// GetUsageForServicePointWithResponse request returning *GetUsageForServicePointResponse
func (c *ClientWithResponses) GetUsageForServicePointWithResponse(ctx context.Context, servicePointId string, params *GetUsageForServicePointParams, reqEditors ...RequestEditorFn) (*GetUsageForServicePointResponse, error) {
	rsp, err := c.GetUsageForServicePoint(ctx, servicePointId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsageForServicePointResponse(rsp)
}

// ListPlansWithResponse request returning *ListPlansResponse
func (c *ClientWithResponses) ListPlansWithResponse(ctx context.Context, params *ListPlansParams, reqEditors ...RequestEditorFn) (*ListPlansResponse, error) {
	rsp, err := c.ListPlans(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPlansResponse(rsp)
}

// GetPlanWithResponse request returning *GetPlanResponse
func (c *ClientWithResponses) GetPlanWithResponse(ctx context.Context, planId string, params *GetPlanParams, reqEditors ...RequestEditorFn) (*GetPlanResponse, error) {
	rsp, err := c.GetPlan(ctx, planId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlanResponse(rsp)
}

// ParseListAccountsResponse parses an HTTP response from a ListAccountsWithResponse call
func ParseListAccountsResponse(rsp *http.Response) (*ListAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyAccountListResponseV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListBalancesBulkResponse parses an HTTP response from a ListBalancesBulkWithResponse call
func ParseListBalancesBulkResponse(rsp *http.Response) (*ListBalancesBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBalancesBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyBalanceListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListBalancesForAccountsResponse parses an HTTP response from a ListBalancesForAccountsWithResponse call
func ParseListBalancesForAccountsResponse(rsp *http.Response) (*ListBalancesForAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBalancesForAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyBalanceListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListBillingBulkResponse parses an HTTP response from a ListBillingBulkWithResponse call
func ParseListBillingBulkResponse(rsp *http.Response) (*ListBillingBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBillingBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyBillingListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListBillingForAccountsResponse parses an HTTP response from a ListBillingForAccountsWithResponse call
func ParseListBillingForAccountsResponse(rsp *http.Response) (*ListBillingForAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBillingForAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyBillingListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListInvoicesBulkResponse parses an HTTP response from a ListInvoicesBulkWithResponse call
func ParseListInvoicesBulkResponse(rsp *http.Response) (*ListInvoicesBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInvoicesBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyInvoiceListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListInvoicesForAccountsResponse parses an HTTP response from a ListInvoicesForAccountsWithResponse call
func ParseListInvoicesForAccountsResponse(rsp *http.Response) (*ListInvoicesForAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInvoicesForAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyInvoiceListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetAccountResponse parses an HTTP response from a GetAccountWithResponse call
func ParseGetAccountResponse(rsp *http.Response) (*GetAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyAccountDetailResponseV3
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetBalanceForAccountResponse parses an HTTP response from a GetBalanceForAccountWithResponse call
func ParseGetBalanceForAccountResponse(rsp *http.Response) (*GetBalanceForAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBalanceForAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyBalanceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetBillingForAccountResponse parses an HTTP response from a GetBillingForAccountWithResponse call
func ParseGetBillingForAccountResponse(rsp *http.Response) (*GetBillingForAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBillingForAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyBillingListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetConcessionsResponse parses an HTTP response from a GetConcessionsWithResponse call
func ParseGetConcessionsResponse(rsp *http.Response) (*GetConcessionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConcessionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyConcessionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetInvoicesForAccountResponse parses an HTTP response from a GetInvoicesForAccountWithResponse call
func ParseGetInvoicesForAccountResponse(rsp *http.Response) (*GetInvoicesForAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvoicesForAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyInvoiceListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetPaymentScheduleResponse parses an HTTP response from a GetPaymentScheduleWithResponse call
func ParseGetPaymentScheduleResponse(rsp *http.Response) (*GetPaymentScheduleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPaymentScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyPaymentScheduleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseListServicePointsResponse parses an HTTP response from a ListServicePointsWithResponse call
func ParseListServicePointsResponse(rsp *http.Response) (*ListServicePointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListServicePointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyServicePointListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListDERBulkResponse parses an HTTP response from a ListDERBulkWithResponse call
func ParseListDERBulkResponse(rsp *http.Response) (*ListDERBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDERBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyDerListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListDERForServicePointsResponse parses an HTTP response from a ListDERForServicePointsWithResponse call
func ParseListDERForServicePointsResponse(rsp *http.Response) (*ListDERForServicePointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDERForServicePointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyDerListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListUsageBulkResponse parses an HTTP response from a ListUsageBulkWithResponse call
func ParseListUsageBulkResponse(rsp *http.Response) (*ListUsageBulkResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsageBulkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyUsageListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListUsageForServicePointsResponse parses an HTTP response from a ListUsageForServicePointsWithResponse call
func ParseListUsageForServicePointsResponse(rsp *http.Response) (*ListUsageForServicePointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsageForServicePointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyUsageListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetServicePointResponse parses an HTTP response from a GetServicePointWithResponse call
func ParseGetServicePointResponse(rsp *http.Response) (*GetServicePointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicePointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyServicePointDetailResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetDERForServicePointResponse parses an HTTP response from a GetDERForServicePointWithResponse call
func ParseGetDERForServicePointResponse(rsp *http.Response) (*GetDERForServicePointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDERForServicePointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyDerDetailResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}

// ParseGetUsageForServicePointResponse parses an HTTP response from a GetUsageForServicePointWithResponse call
func ParseGetUsageForServicePointResponse(rsp *http.Response) (*GetUsageForServicePointResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsageForServicePointResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyUsageListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListPlansResponse parses an HTTP response from a ListPlansWithResponse call
func ParseListPlansResponse(rsp *http.Response) (*ListPlansResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPlansResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyPlanListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetPlanResponse parses an HTTP response from a GetPlanWithResponse call
func ParseGetPlanResponse(rsp *http.Response) (*GetPlanResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EnergyPlanResponseV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ResponseErrorListV2
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	}

	return response, nil
}
